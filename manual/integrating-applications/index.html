<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]--><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Asciidoctor 1.5.8"><title>Integrating Applications with Syndesis</title><link rel="stylesheet" href="/css/syndesis.css?t=1603456468263"><link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet"><link rel="icon" type="image/png" href="https://syndesis.io/images/favicon.png"></head><body class="page book toc2 toc-left" id="integrating-applications"><div id="wrapper"><a href="https://github.com/syndesisio" class="github-corner hidden-md-down" aria-label="View source on Github" rel="nofollow" target="_blank"><svg width="74" height="74" viewBox="0 0 250 250" style="fill:#fff;z-index:2000;color:#0088ce;mix-blend-mode:screen;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7
          120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9
          125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6
          C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0
          C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1
          C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4
          C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9
          C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5
          C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9
          L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><nav class="navbar topnav fixed-top navbar-inverse bg-primary navbar-toggleable-md sps sps--abv"><button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#top-nav" aria-controls="top-nav" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button> <a href="/" title="Syndesis - Open source integration platform"><svg id="artwork" xmlns="http://www.w3.org/2000/svg" width="190px" height="39.33px" viewBox="0 0 1300 300" preserveAspectRatio="xMidYMin slice"><defs><style>.cls-1{fill:#9adde8}.cls-2{fill:#49badc}.cls-3{fill:#fff}</style></defs><title>Syndesis - Open source integration platform</title><polygon class="cls-1" points="129.95 98.77 33.99 144.38 122.22 167.37 218.18 121.75 129.95 98.77"/><polygon class="cls-2" points="218.18 121.75 218.18 121.75 122.22 167.37 242.17 198.61 218.18 121.75"/><polygon class="cls-1" points="154.99 86.86 131 10 10 67.52 129.95 98.77 154.99 86.86"/><polygon class="cls-2" points="33.99 144.38 129.95 98.77 10 67.52 10 67.52 33.99 144.38"/><polygon class="cls-2" points="189.64 25.27 131 10 154.99 86.86 213.63 102.14 189.64 25.27"/><polygon class="cls-2" points="38.54 164 62.53 240.86 121.17 256.13 121.17 256.13 97.18 179.27 97.18 179.27 38.54 164"/><polygon class="cls-1" points="242.17 198.61 122.22 167.37 97.18 179.27 121.17 256.13 242.17 198.61"/><path class="cls-3" d="M358.91,210.23c-23.57,0-43.44-17.22-44.06-41.6H329.2c.41,22.74,17.21,29.3,37.09,29.3,16.6,0,35.65-9.63,35.65-28.48,0-14.76-10.65-21.73-23.15-25.82-24-8-60.45-15.58-60.45-47.55,0-25.82,23.77-40,47.13-40,19.47,0,44.88,6.77,48.15,35.25H399.28c-.41-18.24-17-23-32.17-23-15.37,0-34.43,7.79-34.43,25.82,0,42,83.61,23,83.61,74C416.29,200.39,388.62,210.23,358.91,210.23Z"/><path class="cls-3" d="M484.32,143.22l-54.51-84h17l45.29,71.52L537.4,59.2h14.34l-54.1,83.61v64.34H484.32Z"/><path class="cls-3" d="M572.24,59.2H587.4L669,189.32h.41V59.2h13.32v148h-16.8L586,79.28h-.41V207.15H572.24Z"/><path class="cls-3" d="M760,59.2c48.56,0,76.23,25,76.23,74s-27.67,74-76.23,74H720V59.2Zm3.27,135.66c41.6,0,58.61-24.39,58.61-61.69,0-43.64-25.61-62.91-67.62-61.68h-20.9V194.86Z"/><path class="cls-3" d="M870.19,207.15V59.2H958.1V71.49H883.51v53.08h71.73v12.29H883.51v58h77.67v12.29Z"/><path class="cls-3" d="M1030.44,210.23c-23.56,0-43.44-17.22-44.05-41.6h14.34c.41,22.74,17.21,29.3,37.09,29.3,16.6,0,35.66-9.63,35.66-28.48,0-14.76-10.66-21.73-23.16-25.82-24-8-60.45-15.58-60.45-47.55,0-25.82,23.77-40,47.13-40,19.47,0,44.88,6.77,48.16,35.25h-14.35c-.41-18.24-17-23-32.17-23-15.37,0-34.43,7.79-34.43,25.82,0,42,83.61,23,83.61,74C1087.82,200.39,1060.16,210.23,1030.44,210.23Z"/><path class="cls-3" d="M1121.63,207.15V58.58H1135V207.15Z"/><path class="cls-3" d="M1212.62,210.23c-23.56,0-43.44-17.22-44.06-41.6h14.35c.41,22.74,17.21,29.3,37.09,29.3,16.6,0,35.66-9.63,35.66-28.48,0-14.76-10.66-21.73-23.16-25.82-24-8-60.45-15.58-60.45-47.55,0-25.82,23.77-40,47.13-40,19.47,0,44.88,6.77,48.16,35.25H1253c-.41-18.24-17-23-32.17-23-15.37,0-34.43,7.79-34.43,25.82,0,42,83.61,23,83.61,74C1270,200.39,1242.34,210.23,1212.62,210.23Z"/></svg></a><div class="collapse navbar-collapse" id="top-nav"><ul class="navbar-nav ml-auto mt-2 mt-md-0 mr-lg-4"><li class="nav-item ml-lg-3 ml-0"><a class="nav-link" href="/quickstart">Quickstart</a></li><li class="nav-item ml-lg-3 ml-0"><a class="nav-link" href="/docs">Documentation</a></li><li class="nav-item ml-lg-3 ml-0"><a class="nav-link" href="/blog">Blog</a></li><li class="nav-item ml-lg-3 ml-0"><a class="nav-link" href="/faq">FAQ</a></li><li class="nav-item ml-lg-3 ml-0"><a class="nav-link" href="/community">Community</a></li><li class="nav-item ml-lg-3 ml-0"><a class="nav-link" href="/about">About</a></li></ul></div></nav><div class="article"><div id="header"><h1>Integrating Applications with Syndesis</h1><div id="toc" class="toc2"><div id="toctitle">On this page</div><ul class="sectlevel1"><li><a href="#high-level-overview_ug">High level overview of Syndesis</a></li><li><a href="#how-to-get-ready_ug">How to get ready to create integrations</a></li><li><a href="#connecting-to-applications_ug">About connections to applications that you want to integrate</a></li><li><a href="#creating-integrations_ug">Creating integrations</a></li><li><a href="#trigger-integrations-with-api-calls_ug">Creating an integration that is triggered by a REST API call</a></li><li><a href="#triggering-integrations-with-http-requests_ug">Creating an integration that is triggered by an HTTP request (Webhook)</a></li><li><a href="#mapping-data_ug">Mapping integration data to fields for the next connection</a></li><li><a href="#managing-integrations_ug">Managing integrations</a></li><li><a href="#customizing_ug">Customizing Syndesis</a></li></ul></div></div><div id="content"><div id="preamble"><div class="sectionbody"><div class="paragraph"><p>This guide provides information and instructions for using Syndesis&#8217;s web interface to integrate applications.</p></div><div class="paragraph"><p>The content in this guide is organized as follows:</p></div><div class="ulist"><ul><li><p><a href="#high-level-overview_ug">High level overview of Syndesis</a></p></li><li><p><a href="#how-to-get-ready_ug">How to get ready to create integrations</a></p></li><li><p><a href="#connecting-to-applications_ug">About connections to applications that you want to integrate</a></p></li><li><p><a href="#creating-integrations_ug">Creating integrations</a></p></li><li><p><a href="#trigger-integrations-with-api-calls_ug">Creating an integration that is triggered by a REST API call</a></p></li><li><p><a href="#triggering-integrations-with-http-requests_ug">Creating an integration that is triggered by an HTTP request (Webhook)</a></p></li><li><p><a href="#mapping-data_ug">Mapping integration data to fields for the next connection</a></p></li><li><p><a href="#managing-integrations_ug">Managing integrations</a></p></li><li><p><a href="#customizing_ug">Customizing Syndesis</a></p></li></ul></div><div class="paragraph"><p>To learn how to use Syndesis by creating sample integrations, see: <a href="https://zregvart.github.io/syndesis.io/manual/tutorials/">Sample Integration Tutorials</a>.</p></div></div></div><div class="sect1"><h2 id="high-level-overview_ug">High level overview of Syndesis</h2><div class="sectionbody"><div class="paragraph"><p>With Syndesis, you can obtain data from an application or service, operate on that data if you need to, and then send the data to a completely different application or service. No coding is required to accomplish this.</p></div><div class="paragraph"><p>The following topics provide a high-level overview of Syndesis:</p></div><div class="ulist"><ul><li><p><a href="#how-it-works_high">How Syndesis works</a></p></li><li><p><a href="#user-types_high">Who Syndesis is for</a></p></li><li><p><a href="#benefits_high">Benefits of using Syndesis</a></p></li><li><p><a href="#description-of-constructs_high">Descriptions of Syndesis constructs</a></p></li></ul></div><div class="sect2"><h3 id="how-it-works_high">How Syndesis works</h3><div class="paragraph"><p>Syndesis provides a web browser interface that lets you integrate two or more different applications or services without writing code. It also provides features that allow you to introduce code if it is needed for complex use cases.</p></div><div class="paragraph"><p>Syndesis lets you enable data transfer between different applications. For example, a business analyst can use Syndesis to capture tweets that mention customers and then leverage the data obtained from Twitter to update Salesforce accounts. Another example is a service that makes stock trade recommendations. You can use Syndesis to capture recommendations for buying or selling stocks of interest and forward those recommendations to a service that automates stock transfers.</p></div><div class="paragraph"><p>To create and run a simple integration, the main steps are:</p></div><div class="olist arabic"><ol class="arabic"><li><p>Create a connection to each application that you want to integrate.</p></li><li><p>Select the start connection. This connection is to the application that contains the data that you want to share with another application.</p><div class="paragraph"><p>Alternatively, you can start the integration with a timer or a webhook that accepts an HTTP request.</p></div></li><li><p>Select the finish connection. This connection is to the application that receives data from the start connection and that completes the integration.</p></li><li><p>Map data fields from the start connection to data fields in the finish connection.</p></li><li><p>Give the integration a name.</p></li><li><p>Click <strong>Publish</strong> to start running the integration.</p></li></ol></div><div class="paragraph"><p>Another kind of integration is an API provider integration. An API provider integration allows REST API clients to invoke commands that trigger execution of the integration. To create and run an API provider integration, you upload an OpenAPI 3 (or 2) document to Syndesis. This document specifies the operations that clients can call. For each operation, you specify and configure the flow of connections and steps, such as data mapper or filter steps, that executes that operation. A simple integration has one primary flow while an API provider integration has a primary flow for each operation.</p></div><div class="paragraph"><p>The Syndesis dashboard lets you monitor and manage integrations. You can see which integrations are running, and you can start, stop, and edit integrations.</p></div></div><div class="sect2"><h3 id="user-types_high">Who Syndesis is for</h3><div class="paragraph"><p>Syndesis is for business experts in, for example, finance, human resources, or marketing, who do not want to write code in order to share data between two different applications. Their use of a variety of software-as-a-service (SaaS) applications gives them an understanding of business requirements, workflows, and relevant data.</p></div><div class="paragraph"><p>As a business user, you can use Syndesis to:</p></div><div class="ulist"><ul><li><p>Capture tweets that mention your company, filter them, and create new contacts in your Salesforce environment when the tweet is from an unknown source.</p></li><li><p>Identify Salesforce lead updates and then execute a SQL stored procedure to keep your related database up to date.</p></li><li><p>Subscribe for orders received by an AMQ broker and then operate on those orders with a custom API.</p></li><li><p>Obtain data from an Amazon S3 bucket and add it to a Dropbox folder.</p></li></ul></div><div class="paragraph"><p>These are just a few examples of what a business user can do without writing code.</p></div></div><div class="sect2"><h3 id="benefits_high">Benefits of using Syndesis</h3><div class="paragraph"><p>Syndesis has a number of benefits:</p></div><div class="ulist"><ul><li><p>Integrate data from different applications or services without writing code.</p></li><li><p>Run the integration on OpenShift Online in the public cloud or on OpenShift Container Platform on site.</p></li><li><p>Use the visual data mapper to map data fields in one application to data fields in another application.</p></li><li><p>Leverage all the benefits of open source software. You can extend features, and customize interfaces. If Syndesis does not provide a connector for an application or service that you want to integrate then a developer can create the connector that you need.</p></li></ul></div></div><div class="sect2"><h3 id="description-of-constructs_high">Descriptions of Syndesis constructs</h3><div class="paragraph"><p>To use Syndesis, you create an integration by working with connectors, connections, actions, steps, and flows. It is helpful to have a basic understanding each of these constructs.</p></div><div class="paragraph"><p>Each installation of Syndesis is referred to as a Syndesis environment. When Red Hat installs and manages your Syndesis environment, it is running on OpenShift Online or on OpenShift Dedicated. When you install and manage a Syndesis environment, it is usually running on OpenShift Container Platform, but it can be running on OpenShift Dedicated.</p></div><div class="paragraph"><div class="title">Integrations</div><p>In Syndesis, there are simple integrations and API provider integrations.</p></div><div class="paragraph"><p>A simple integration is a set of ordered steps that Syndesis executes. This set includes:</p></div><div class="ulist"><ul><li><p>A step that connects to an application to start the integration. This connection provides the initial data that the integration operates on. A subsequent connection can provide additional data.</p></li><li><p>A step that connects to an application to complete the integration. This connection receives any data that was output from previous steps and finishes the integration.</p></li><li><p>Optional additional steps that connect to applications between the start and finish connections. Depending on the position of the additional connection in the sequence of integration steps, an additional connection can do any or all of the following:</p><div class="ulist"><ul><li><p>Provide additional data for the integration to operate on</p></li><li><p>Process the integration data</p></li><li><p>Output processing results to the integration</p></li></ul></div></li><li><p>Optional steps that operate on data between connections to applications. Typically, there is a step that maps data fields from the previous connection to data fields that the next connection uses.</p></li></ul></div><div class="paragraph"><p>An API provider integration publishes a REST API service for which you provided an OpenAPI schema. A call from a REST API client triggers execution of an API provider integration. The call can invoke any operation that the REST API implements. While a simple integration has one primary flow of execution, an API provider integration has a primary flow for each operation. Each operation flow connects to the applications and processes the data according to the steps that you added to that operation&#8217;s flow when you created the integration. Each operation flow ends by returning a response that you specify to the client whose call triggered execution of the integration.</p></div><div class="paragraph"><div class="title">Connectors</div><p>Syndesis provides a set of connectors. A connector represents a specific application that you want to obtain data from or send data to. Each connector is a template for creating a connection to that specific application. For example, you use the Salesforce connector to create a connection to Salesforce.</p></div><div class="paragraph"><p>An application that you want to connect to might use the OAuth protocol to authenticate users. In this case, you register your Syndesis environment as a client that can access that application. The registration is associated with the connector for that application. You need to register a particular Syndesis environment only once with each application that uses OAuth. The registration extends to each connection that you create from that connector.</p></div><div class="paragraph"><p>If Syndesis does not provide a connector that you need, a developer can create the required connector.</p></div><div class="paragraph"><div class="title">Connections</div><p>Before you can create an integration, you must create a connection to each application or service that you want to obtain data from or send data to. To create a connection, you select a connector and add configuration information. For example, to connect to an AMQ broker in an integration, you create a connection by selecting the AMQ connector, and then following prompts to identify the broker to connect to and the account to use for the connection.</p></div><div class="paragraph"><p>A connection is one specific instance of the connector that it is created from. You can create any number of connections from one connector. For example, you can use the AMQ connector to create three AMQ connections where each connection accesses a different broker.</p></div><div class="paragraph"><p>To create a simple integration, you select a connection to start the integration, a connection to end the integration, and optionally one or more connections for accessing additional applications. To create an API provider integration, you can add one or more connections to each operation flow. Any number of integrations and operation flows can use the same connection. A particular integration or flow can use the same connection more than once.</p></div><div class="paragraph"><p>For details, see <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#connecting-to-applications_ug">About connections to applications that you want to integrate</a>.</p></div><div class="paragraph"><div class="title">Actions</div><p>In an integration, each connection performs exactly one action. As you create an integration, you choose a connection to add to the flow and then you choose the action that the connection performs. For example, when you add a Salesforce connection to a flow, you choose from a set of actions that includes, but is not limited to, creating a Salesforce account, updating a Salesforce account, and searching Salesforce.</p></div><div class="paragraph"><p>Some actions require additional configuration and Syndesis prompts you for this information.</p></div><div class="paragraph"><div class="title">Steps</div><p>A simple integration is a set of ordered steps. In an API provider integration, each operation flow is a set of ordered steps.</p></div><div class="paragraph"><p>Each step operates on data. Some steps operate on data while connected to an application or service outside Syndesis. These steps are connections. Between connections, there can be other steps that operate on data in Syndesis. Typically, the set of steps includes a step that maps data fields used in a previous connection to data fields that are used in the next connection in the flow. Except for the start connection in a simple integration, each step operates on data it receives from the previous steps.</p></div><div class="paragraph"><p>To operate on data between connections, Syndesis provides steps for:</p></div><div class="ulist"><ul><li><p>Mapping data fields in one application to data fields in another application.</p></li><li><p>Filtering data so that the integration continues only when the data being processed meets criteria that you define.</p></li><li><p>Spliting a collection of records into individual records so that Syndesis executes subsequent steps iteratively, once for each record.</p></li><li><p>Aggregating individual records into a collection so that Syndesis executes subsequent steps once for the collection.</p></li><li><p>Generating equivalent, consistent output by inserting data into a Freemarker, Mustache, or Velocity template.</p></li><li><p>Logging information in addition to the default logging that Syndesis automatically provides.</p></li></ul></div><div class="paragraph"><p>To operate on data between connections in a way that is not built into Syndesis, you can upload an extension that provides a custom step. See <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#developing-extensions_custom">Developing Syndesis extensions</a>.</p></div><div class="paragraph"><div class="title">Flow</div><p>A flow is a set of ordered steps that an integration executes.</p></div><div class="paragraph"><p>A simple integration has one primary flow. An API provider integration has a primary flow for each operation that the REST API defines. Each operation&#8217;s primary flow is the set of steps that processes a call that invokes that operation.</p></div><div class="paragraph"><p>A primary flow can have conditional flows. An integration evaluates a condition that you specify to determine whether to execute its associated flow.</p></div><div class="paragraph"><p>In a flow, each step can operate on the data that is output from the previous steps. To determine the steps that you need in a flow, see <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#plan_ready">Considerations for planning your integrations</a>.</p></div></div></div></div><div class="sect1"><h2 id="how-to-get-ready_ug">How to get ready to create integrations</h2><div class="sectionbody"><div class="paragraph"><p>Some planning and an understanding of the workflow for creating an integration can help you create integrations that meet your needs. The following topics provide information for getting ready to create integrations.</p></div><div class="ulist"><ul><li><p><a href="#plan_ready">Considerations for planning your integrations</a></p></li><li><p><a href="#workflow-overview_ready">General workflow for creating a simple integration</a></p></li><li><p><a href="#workflow-example_ready">Example workflow for creating a Salesforce to database simple integration</a></p></li></ul></div><div class="sect2"><h3 id="plan_ready">Considerations for planning your integrations</h3><div class="paragraph"><p>Consider the following questions before you create an integration.</p></div><div class="paragraph"><p>How do you want to trigger execution of the integration?</p></div><div class="ulist"><ul><li><p>Do you want to set a timer to trigger execution at intervals that you specify?</p></li><li><p>Do you want to send an HTTP request?</p></li><li><p>Do you want to connect to an application to obtain data from?</p><div class="ulist"><ul><li><p>In that application, what triggers the action that obtains the data? For example, an integration that starts by obtaining data from Twitter might trigger on a Twitter mention.</p></li><li><p>What are the data fields of interest?</p></li><li><p>What credentials does Syndesis use to access this application?</p></li></ul></div></li><li><p>Do you want to publish a REST API service so that a client can invoke a REST API call that triggers execution of the flow for an operation?</p><div class="ulist"><ul><li><p>Is the OpenAPI schema for the service already defined?</p></li><li><p>If not, what operations will the service define?</p></li></ul></div></li></ul></div><div class="paragraph"><p>To finish a simple integration:</p></div><div class="ulist"><ul><li><p>Is there an application that receives the data or do you want to send information to the integration&#8217;s log?</p></li><li><p>If you are sending data to an application, what action does the integration perform?</p></li><li><p>What are the data fields of interest?</p></li><li><p>What credentials does Syndesis use to access this application?</p></li></ul></div><div class="paragraph"><p>In a flow&#8217;s set of steps:</p></div><div class="ulist"><ul><li><p>Do you need to access any other applications? For any other applications that need to be accessed:</p><div class="ulist"><ul><li><p>Which application does the flow need to connect to?</p></li><li><p>What action should the connection perform?</p></li><li><p>What are the data fields of interest?</p></li><li><p>What credentials should the connection use to connect to this application?</p></li></ul></div></li><li><p>Does the flow need to operate on the data between connections? For example:</p><div class="ulist"><ul><li><p>Should the flow filter the data it operates on?</p></li><li><p>Do field names differ between source and target applications? If they do then data mapping is required.</p></li><li><p>Does the flow operate on a collection? If it does, can the flow use the data mapper to process the collection or does the flow need to split a collection into individual records? Does the flow need to aggregate records into a collection?</p></li><li><p>Would a template be helpful for outputting data in a consistent form?</p></li><li><p>Do you want to send information about messages being processed to the integration&#8217;s log?</p></li><li><p>Does the flow need to operate on the data in some customized way?</p></li></ul></div></li><li><p>Do you need to vary the execution flow according to the content of the integration data? That is, are conditional flows required?</p></li></ul></div></div><div class="sect2"><h3 id="workflow-overview_ready">General workflow for creating a simple integration</h3><div class="paragraph"><p>After you log in to the Syndesis console, you can start creating connections to the applications that you want to integrate. For each application that you want to integrate and that uses the OAuth protocol, register Syndesis as a client of that application. Applications that you must register with include:</p></div><div class="ulist"><ul><li><p>Dropbox</p></li><li><p>Google applications (Gmail, Calendar, Sheets)</p></li><li><p>Salesforce</p></li><li><p>SAP Concur</p></li><li><p>Twitter</p></li></ul></div><div class="paragraph"><p>With registration in place for those applications, the workflow for creating a simple integration looks like this:</p></div><div class="paragraph"><p><span class="image"><img src="images/integrating-applications/general-workflow.png" alt="general workflow"></span></p></div><div class="paragraph"><div class="title">Additional resource</div><p><a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#overview-benefit-api-provider-integrations_api-provider">Benefit, overview, and workflow for creating API provider integrations</a>.</p></div></div><div class="sect2"><h3 id="workflow-example_ready">Example workflow for creating a Salesforce to database simple integration</h3><div class="paragraph"><p>The best way to understand the workflow for using Syndesis to create a simple integration is to create the sample integrations by following the instructions in the <a href="https://zregvart.github.io/syndesis.io/manual/tutorials/">sample integration tutorials</a>.</p></div><div class="paragraph"><p>The following diagram shows the workflow for creating the sample Salesforce to Database integration.</p></div><div class="paragraph"><p><span class="image"><img src="images/integrating-applications/sample-workflow.png" alt="sample workflow"></span></p></div><div class="paragraph"><p>After you publish an integration, the Syndesis dashboard displays <strong>Running</strong> next to the integration name when the integration is ready to be executed.</p></div><div class="paragraph"><div class="title">Additional resource</div><p><a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#configure-publish-api-provider-quickstart_api-provider">Importing and publishing the example API provider quickstart integration</a>.</p></div></div></div></div><div class="sect1"><h2 id="connecting-to-applications_ug">About connections to applications that you want to integrate</h2><div class="sectionbody"><div class="paragraph"><p>To connect to applications that you want to integrate, the main steps are:</p></div><div class="olist arabic"><ol class="arabic"><li><p>Create a connection to each application or service that you want to integrate.</p></li><li><p>Create an integration that has a connection to each application that you want to integrate.</p></li></ol></div><div class="paragraph"><p>The procedure for creating a connection varies for each application or service. The details for creating each kind of connection and configuring it for a particular integration are in <a href="https://zregvart.github.io/syndesis.io/manual/connecting/">Connecting to Applications and Services</a>.</p></div><div class="paragraph"><p>The following topics provide general information about connections:</p></div><div class="ulist"><ul><li><p><a href="#about-creating-connections_connections">About creating connections from Syndesis to applications</a></p></li><li><p><a href="#general-procedure-for-obtaining-authorization_connections">General procedure for obtaining authorization</a></p></li><li><p><a href="#about-connection-validation_connections">About connection validation</a></p></li><li><p><a href="#about-adding-connections-to-integrations_connections">About adding connections to integrations</a></p></li><li><p><a href="#viewing-and-editing-connection-information_connections">How to view and edit connection information</a></p></li><li><p><a href="#creating-connections-from-custom-connectors_connections">About creating a connection from a custom connector</a></p></li></ul></div><div class="sect2"><h3 id="about-creating-connections_connections">About creating connections from Syndesis to applications</h3><div class="paragraph"><p>To create a connection, you select the connector for the application that you want to connect to and then enter values in input fields to configure a connection to that application. The configuration details that you need to provide vary for each application. After configuring the connection, you give it a name that helps you distinguish it from any other connections to the same application. Optionally, you can specify a description of the connection.</p></div><div class="paragraph"><p>You can use the same connector to create any number of connections to that application. For example, you might use the AMQ connector to create three different connections. Each AMQ connection could specify a different broker.</p></div><div class="paragraph"><p>For examples, see:</p></div><div class="ulist"><ul><li><p><a href="https://zregvart.github.io/syndesis.io/manual/connecting/#create-amq-connection_amq">Create AMQ connections</a></p></li><li><p><a href="https://zregvart.github.io/syndesis.io/manual/connecting/#creating-http-connections_http">Create HTTP and HTTPS connections</a></p></li><li><p><a href="https://zregvart.github.io/syndesis.io/manual/connecting/#creating-slack-connections_slack">Create Slack connections</a></p></li></ul></div></div><div class="sect2"><h3 id="general-procedure-for-obtaining-authorization_connections">General procedure for obtaining authorization</h3><div class="paragraph"><p>In an integration, you might want to connect to an application that uses the OAuth protocol to authenticate access requests. To do this, you must register your installation of Syndesis for access to that application. Registration authorizes all connections from your Syndesis installation to a given application. For example, if you register your Syndesis installation with Salesforce, all connections from your Syndesis installation to Salesforce use the same Salesforce client ID and the same Salesforce client secret that registration provided.</p></div><div class="paragraph"><p>In each Syndesis environment, for each application that uses OAuth, only one registration of Syndesis as a client is required. This registration lets you create multiple connections and each connection can use different user credentials.</p></div><div class="paragraph"><p>While the specific steps vary for each OAuth application that you want to connect to, registration always provides your Syndesis environment with a client ID and a client secret. Some applications use other labels for the client ID and client secret. For example, Salesforce generates a consumer key and a consumer secret.</p></div><div class="paragraph"><p>For some OAuth applications, Syndesis provides an entry in its <strong>Settings</strong> page for adding the client ID and client secret that registration provides. To see which applications this applies to, in the left panel of Syndesis, click <strong>Settings</strong>.</p></div><div class="ulist"><div class="title">Prerequisites</div><ul><li><p>In the Syndesis <strong>Settings</strong> page, there is an entry for the application that uses the OAuth protocol to authorize access.</p></li></ul></div><div class="olist arabic"><div class="title">Procedure overview</div><ol class="arabic"><li><p>In the Syndesis <strong>OAuth Application Management</strong> page, expand the entry for the application with which you want to register Syndesis. This displays the client ID and client secret fields.</p></li><li><p>Near the top of the <strong>OAuth Application Management</strong> page, where you see <code><strong>During registration, enter this callback URL:</strong></code>, copy that URL to the clipboard.</p></li><li><p>In another browser tab, go to the web site for the application that you want to register with and perform the steps that are required to obtain a client ID and secret. One of these steps requires you to enter the callback URL for your Syndesis environment. Paste the URL that you copied to the clipboard in the second step.</p></li><li><p>In Syndesis, on the <strong>Settings</strong> page, paste the client ID and client secret and save the settings.</p></li></ol></div><div class="ulist"><div class="title">Additional resources</div><ul><li><p>Examples of registering applications that have entries in the <strong>Settings</strong> page:</p><div class="ulist"><ul><li><p><a href="https://zregvart.github.io/syndesis.io/manual/connecting/#register-with-salesforce_salesforce">Registering Syndesis as a Salesforce client</a></p></li><li><p><a href="https://zregvart.github.io/syndesis.io/manual/connecting/#register-with-twitter_twitter">Registering Syndesis as a Twitter client</a></p></li></ul></div></li><li><p>Example of registering with an application that does not have an entry in the Syndesis <strong>Settings</strong> page: <a href="https://zregvart.github.io/syndesis.io/manual/connecting/#register-with-dropbox_dropbox">Registering Syndesis as a Dropbox client</a></p></li><li><p>Information about using custom connectors that let you access applications that use the OAuth protocol: <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#creating-connections-from-custom-connectors_connections">About creating a connection from a custom connector</a>.</p></li></ul></div></div><div class="sect2"><h3 id="about-connection-validation_connections">About connection validation</h3><div class="paragraph"><p>After obtaining authorization for Syndesis to access an application that uses OAuth, you can create one or more connections to that application. When you create a connection to an OAuth application, Syndesis validates it to confirm that authorization is in place. At any time, you can validate the connection again to ensure that authorization is still in place.</p></div><div class="paragraph"><p>Some OAuth applications grant access tokens that have an expiration date. If the access token expires, you can reconnect to the application to obtain a new access token.</p></div><div class="paragraph"><p>To validate a connection that uses OAuth or to obtain a new access token for an OAuth application:</p></div><div class="olist arabic"><ol class="arabic"><li><p>In the left panel, click <strong>Connections</strong>.</p></li><li><p>Click the connection that you want to validate or for which you want to obtain a new access token.</p></li><li><p>In the connection&#8217;s details page, click <strong>Validate</strong> or click <strong>Reconnect</strong>.</p></li></ol></div><div class="paragraph"><p>If validation or reconnection fails, then check with the application/service provider to determine if the application&#8217;s OAuth keys, IDs, tokens, or secrets are still valid. It is possible that an item has expired or been revoked.</p></div><div class="paragraph"><p>If you find that an OAuth item is invalid, has expired, or been revoked, obtain new values and paste them into the Syndesis settings for the application. See the instructions in <a href="https://zregvart.github.io/syndesis.io/manual/connecting/">Connecting to Applications and Services</a> for registering the application whose connection did not validate. With the updated settings in place, follow the instructions above to try to validate the updated connection. If validation is successful, and there is a running integration that is using this connection, restart the integration. To restart an integration, stop it and then start it.</p></div><div class="paragraph"><p>If validation fails and reconnection fails but everything appears to be valid at the service provider, then try reregistering your Syndesis environment with the application and then recreate the connection. Syndesis validates the connection when you recreate it. If you recreate the connection, and there is an integration that is using the connection, then you must edit the integration to delete the old connection and add the new connection. If the integration is running, then you must stop it and restart it.</p></div></div><div class="sect2"><h3 id="about-adding-connections-to-integrations_connections">About adding connections to integrations</h3><div class="paragraph"><p>When you add a connection to a simple integration or to an operation flow, Syndesis displays a list of the actions that the connection can perform when it connects to the application. You must select exactly one action. In a running integration, each connection performs only the action you choose. For example, when you add a Twitter connection as an integration&#8217;s start connection, you might choose the <strong>Mention</strong> action, which monitors Twitter for tweets that mention your Twitter handle.</p></div><div class="paragraph"><p>Selection of some actions prompts you to specify one or more parameters, which configure the action. For example, if you add a Salesforce connection to an integration and choose the <strong>On create</strong> action then you must indicate the type of object whose creation you are interested in, such as a lead or a contact.</p></div></div><div class="sect2"><h3 id="viewing-and-editing-connection-information_connections">How to view and edit connection information</h3><div class="paragraph"><p>After you create a connection, Syndesis assigns an internal identifier to the connection. This identifier does not change. You can change the connection&#8217;s name, description, or configuration values and Syndesis recognizes it as the same connection.</p></div><div class="paragraph"><p>There are two ways to view and edit information about a connection:</p></div><div class="ulist"><ul><li><p>In the left panel, click <strong>Connections</strong> and then click any connection to view its details.</p></li><li><p>In the left panel, click <strong>Integrations</strong> and then view any integration to see its summary page. In the integration&#8217;s flow diagram:</p><div class="ulist"><ul><li><p>For a simple integration, click a connection icon to view that connection&#8217;s details.</p></li><li><p>For an API provider integration, click view <span class="image"><img src="images/integrating-applications/ApiProviderReturnIcon.png" alt="flows icon"></span>to display the integration&#8217;s operation list. Click the operation whose flow contains the connection that you want to view details for.</p></li></ul></div></li></ul></div><div class="paragraph"><p>On the <strong>Connection Details</strong> page, for the connection that you want to edit, click <span class="image"><img src="images/integrating-applications/PencilForEditing.png" alt="Edit"></span>next to a field to edit that field. Or, for some connections, below the configuration fields, click <strong>Edit</strong> to change configuration values. If you change any values, be sure to click <strong>Save</strong>.</p></div><div class="paragraph"><p>If you update a connection that is used in an integration that is running, you must republish the integration.</p></div><div class="paragraph"><p>For connections to applications that use the OAuth protocol to authorize access, you cannot change the login credentials that the connection uses. To connect to the application and use different login credentials, you must create a new connection.</p></div></div><div class="sect2"><h3 id="creating-connections-from-custom-connectors_connections">About creating a connection from a custom connector</h3><div class="paragraph"><p>After you upload an extension that defines a custom connector, the custom connector is available for use. You use custom connectors to create connections in the same way that you use Syndesis-provided connectors to create connections.</p></div><div class="paragraph"><p>A custom connector might be for an application that uses the OAuth protocol. Before you create a connection from this kind of connector, you must register your Syndesis environment for access to the application that the connector is for. You do this in the interface for the application that the connector is for. The details for how to register your Syndesis environment vary for each application.</p></div><div class="paragraph"><p>For example, suppose the custom connector is for creating connections to Yammer. You would need to register your Syndesis environment by creating a new application within Yammer. Registration provides a Yammer client ID for Syndesis and a Yammer client secret value for Syndesis. A connection from your Syndesis environment to Yammer must provide these two values.</p></div><div class="paragraph"><p>Note that an application might use different names for these values, such as consumer ID or consumer secret.</p></div><div class="paragraph"><p>After you register your Syndesis environment, you can create a connection to the application. When you configure the connection, there should be parameters for entering the client ID and the client secret. If these parameters are not available, you need to talk with the extension developer and ask for an updated extension that lets you specify the client ID and client secret.</p></div></div></div></div><div class="sect1"><h2 id="creating-integrations_ug">Creating integrations</h2><div class="sectionbody"><div class="paragraph"><p>After some planning and preparation, you are ready to create an integration. In the Syndesis web interface, when you click <strong>Create Integration</strong>, Syndesis guides you through the procedure to create an integration.</p></div><div class="ulist"><div class="title">Prerequisites</div><ul><li><p><a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#plan_ready">Considerations for planning your integrations</a></p></li><li><p>According to the kind of integration that you want to create:</p><div class="ulist"><ul><li><p>An understanding of the <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#workflow-overview_ready">general workflow for creating a simple integration</a></p></li><li><p>An understanding of the <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#overview-benefit-api-provider-integrations_api-provider">general workflow for creating an API provider integration</a></p></li></ul></div></li></ul></div><div class="paragraph"><p>The following topics provide information and instructions for creating an integration:</p></div><div class="ulist"><ul><li><p><a href="#preparing-to-create-an-integration_create">Preparation for creating an integration</a></p></li><li><p><a href="#alternatives-for-triggering-integration-execution_create">Alternatives for triggering integration execution</a></p></li><li><p><a href="#procedure-for-creating-an-integration_create">General procedure for creating a simple integration</a></p></li><li><p><a href="#add-timer-connection_create">Adding a timer connection to trigger integration execution</a></p></li><li><p><a href="#how-to-process-a-collection-in-a-flow_create">Integration behavior when the data is in a collection</a></p></li><li><p><a href="#about-adding-steps_create">About adding steps between connections</a></p></li><li><p><a href="#evaluating-integration-data-to-determine-execution-flow_create">Evaluating integration data to determine the execution flow</a></p></li><li><p><a href="#add-data-mapping-step_create">Adding a data mapper step</a></p></li><li><p><a href="#add-basic-filter-step_create">Adding a basic filter step</a></p></li><li><p><a href="#add-advanced-filter-step_create">Adding an advanced filter step</a></p></li><li><p><a href="#add-template-step_create">Adding a template step</a></p></li><li><p><a href="#add-custom-step_create">Adding a custom step</a></p></li></ul></div><div class="sect2"><h3 id="preparing-to-create-an-integration_create">Preparation for creating an integration</h3><div class="paragraph"><p>Preparation for creating an integration starts with answers to the questions listed in <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#plan_ready">Considerations for planning your integrations</a>. After you have a plan for the integration, you need to do the following before you can create the integration:</p></div><div class="olist arabic"><ol class="arabic"><li><p>Determine whether an application that you want to connect to uses the OAuth protocol. For each application that uses OAuth, register Syndesis as a client that is authorized to access that application. Applications that use the OAuth protocol include:</p><div class="ulist"><ul><li><p>Dropbox</p></li><li><p>Google applications (Gmail, Calendar, Sheets)</p></li><li><p>Salesforce</p></li><li><p>SAP Concur</p></li><li><p>Twitter</p></li></ul></div></li><li><p>Determine whether an application that you want to connect to uses HTTP basic authentication. For each application that does, identify the user name and password for accessing that application. You need to provide this information when you create the connection.</p></li><li><p>For each application that you want to integrate, create a connection.</p></li></ol></div><div class="ulist"><div class="title">Additional resources</div><ul><li><p><a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#general-procedure-for-obtaining-authorization_connections">General procedure for obtaining authorization</a></p></li><li><p><a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#about-creating-connections_connections">About creating connections</a></p></li></ul></div></div><div class="sect2"><h3 id="alternatives-for-triggering-integration-execution_create">Alternatives for triggering integration execution</h3><div class="paragraph"><p>When you create an integration, the first step in the integration determines how execution of the integration is triggered. The first step in an integration can be one of the following:</p></div><div class="ulist"><ul><li><p><strong><a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#connecting-to-applications_ug">Connection to an application or service</a></strong>. You configure the connection for the particular application or service. Examples:</p><div class="ulist"><ul><li><p>A connection to Twitter can monitor tweets and trigger execution of a simple integration when a tweet contains text that you specified.</p></li><li><p>A connection to Salesforce can trigger execution of a simple integration when anyone creates a new lead.</p></li><li><p>A connection to AWS S3 can periodically poll a particular bucket and trigger execution of a simple integration when the bucket contains files.</p></li></ul></div></li><li><p><strong><a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#add-timer-connection_create">Timer</a></strong>. Syndesis triggers execution of a simple integration at the interval that you specify. This can be a simple timer or a <code>cron</code> job.</p></li><li><p><strong><a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#triggering-integrations-with-http-requests_ug">Webhook</a></strong>. A client can send an HTTP <code>GET</code> or <code>POST</code> request to an HTTP endpoint that Syndesis exposes. The request triggers execution of the simple integration.</p></li><li><p><strong><a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#trigger-integrations-with-api-calls_ug">API Provider</a></strong>. An API provider integration starts with a REST API service. This REST API service is defined by an OpenAPI 3 (or 2) document that you provide when you create an API provider integration. After you publish an API provider integration, Syndesis deploys the REST API service on OpenShift. Any client with network access to the integration endpoints can trigger execution of the integration.</p></li></ul></div></div><div class="sect2"><h3 id="procedure-for-creating-an-integration_create">General procedure for creating a simple integration</h3><div class="paragraph"><p>Syndesis guides you through the procedure for creating a simple integration. It prompts you to choose the start connection, the finish connection, optional middle connections, and other steps. When your integration is complete, you can publish it so that it is running or you can save it for publication at a later time.</p></div><div class="paragraph"><p>To learn about the procedure for creating an API provider integration, see <a href="#create-api-provider-integration_api-provider">Creating an API provider integration</a>.</p></div><div class="ulist"><div class="title">Prerequisites</div><ul><li><p>You have a plan for what the steps in the integration will be.</p></li><li><p>You created a connection to each application or service that you want to connect to in this integration.</p></li></ul></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the left panel in Syndesis, click <strong>Integrations</strong>.</p></li><li><p>Click <strong>Create Integration</strong>.</p></li><li><p>Choose and configure the start connection:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>On the <strong>Choose a connection</strong> page, click the connection that you want to use to start the integration. When this integration is running, Syndesis will connect to this application and obtain data that you want the integration to operate on.</p></li><li><p>On the <strong>Choose an action</strong> page, select the action you want this connection to perform. The available actions vary for each connection.</p></li><li><p>On the page for configuring the action, enter values in the fields.</p></li><li><p>Optionally, if the connection requires data type specification, Syndesis prompts you to click <strong>Next</strong> to specify the input and/or output type of the action.</p></li><li><p>Click <strong>Next</strong> to add the start connection.</p></li></ol></div><div class="paragraph"><p>As an alternative to connecting to an application, a start connection can be a timer that triggers integration execution at intervals that you specify or it can be a webhook that accepts HTTP requests.</p></div><div class="paragraph"><p>+ After you choose and configure the start connection, Syndesis prompts you to choose the finish connection.</p></div></li><li><p>Choose and configure the finish connection:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>On the <strong>Choose a connection</strong> page, click the connection you want to use to complete the integration. When this integration is running, Syndesis will connect to this application with the data that the integration has been operating on.</p></li><li><p>On the <strong>Choose an action</strong> page, select the action you want this connection to perform. The available actions vary for each connection.</p></li><li><p>On the page for configuring the action, enter values in the fields.</p></li><li><p>Optionally, if the connection requires data type specification, Syndesis prompts you to click <strong>Next</strong> to specify the input and/or output type of the action.</p></li><li><p>Click <strong>Next</strong> to add the finish connection.</p></li></ol></div><div class="paragraph"><p>As an alternative to connecting to an application, a finish connection can send information to the integration&#8217;s log about the messages that the integration processed. To do this, select <strong>Log</strong> when Syndesis prompts you to choose the finish connection.</p></div></li><li><p>Optionally, add one or more connections between the start connection and the finish connection. For each connection, choose its action and enter any required configuration details.</p></li><li><p>Optionally, add one or more steps that operate on integration data between connections. See <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#about-adding-steps_create">About adding steps between connections</a>.</p></li><li><p>In the integration visualization, look for any <span class="image"><img src="images/tutorials/WarningIcon.png" alt="Warning"></span>icons. These warnings indicate that a data mapper step is needed before this connection. Add the required data mapper steps.</p></li><li><p>When the integration contains all needed steps, click <strong>Save</strong> or <strong>Publish</strong> according to whether you want to start running the integration.</p></li><li><p>In the <strong>Name</strong> field, enter a name that distinguishes this integration from any other integrations.</p></li><li><p>Optionally, in the <strong>Description</strong> field, enter a description, for example, you can indicate what this integration does.</p></li><li><p>Optionally, from the list of library extensions that you have imported, you can select one or more library extensions to associate with the integration. Note that you must have already imported a library <code>.jar</code> file as a Syndesis extension if you want it to appear in this list so that you can select it.</p><div class="paragraph"><p>For more information about library extensions, see <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#develop-library-extensions_extensions">How to develop library extensions</a>.</p></div></li><li><p>If you are ready to start running the integration, click <strong>Save and publish</strong>.</p><div class="paragraph"><p>Syndesis displays the integration summary. You can see that Syndesis is in the process of publishing it. It may take a few moments for the status of the integration to become <strong>Running</strong>.</p></div><div class="paragraph"><p>If you do not want to publish the integration, click <strong>Save</strong>. Syndesis saves the integration and displays its flow visualization. You can continue editing it. Or, in the breadcrumbs at the top of the page, click <strong>Integrations</strong> to display the list of integrations. If you saved but did not publish the integration, then <strong>Stopped</strong> appears on the integration&#8217;s entry.</p></div></li></ol></div></div><div class="sect2"><h3 id="add-timer-connection_create">Adding a timer connection to trigger integration execution</h3><div class="paragraph"><p>To trigger execution of an integration according to a schedule that you specify, add a timer connection as a simple integration&#8217;s start connection. A timer connection cannot be in the middle of a flow nor at the end of a flow.</p></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In Syndesis, on the left, click <strong>Integrations</strong>.</p></li><li><p>Click <strong>Create Integration</strong>.</p></li><li><p>On the <strong>Choose a connection</strong> page, click <strong>Timer</strong>.</p><div class="paragraph"><p>Syndesis provides a <strong>Timer</strong> connection; you do not need to create a timer connection.</p></div></li><li><p>On the <strong>Choose an action</strong> page, select <strong>Cron</strong> or <strong>Simple</strong>.</p><div class="ulist"><ul><li><p>A <code>cron</code> timer requires a <code>cron</code> expression that specifies the schedule for triggering integration execution.</p></li><li><p>A simple timer prompts you to specify a period and its time unit, for example, <code>5 seconds</code>, <code>1 hour</code>. Available units are milliseconds, seconds, minutes, hours, days.</p></li></ul></div></li><li><p>According the type of timer that you are adding, enter a <code>cron</code> expression or a period with a selected time unit.</p></li><li><p>Click <strong>Next</strong> to add the <strong>Timer</strong> connection as the integration&#8217;s start connection.</p></li></ol></div></div><div class="sect2"><h3 id="how-to-process-a-collection-in-a-flow_create">Integration behavior when the data is in a collection</h3><div class="paragraph"><p>Sometimes, a connection returns a collection, which contains multiple values that are all the same type. When a connection returns a collection, the flow can operate on the collection in a number of ways, including:</p></div><div class="ulist"><ul><li><p>Execute each step once for the collection.</p></li><li><p>Execute each step once for each element in the collection.</p></li><li><p>Execute some steps once for the collection and execute other steps once for each element in the collection.</p></li></ul></div><div class="paragraph"><p>To decide how to operate on a collection in a flow, you need to know which applications the flow connects to, whether they can handle collections, and what you want the flow to accomplish. You can then use the information in the following topics to add steps to a flow that processes a collection:</p></div><div class="ulist"><ul><li><p><a href="#about-data-types-and-collections_collection">About data types and collections in the data mapper</a></p></li><li><p><a href="#about-processing-collections_collection">About processing collections</a></p></li><li><p><a href="#using-data-mapper-to-process-collections_collection">Using the data mapper to process collections</a></p></li><li><p><a href="#add-split-step_collection">Adding a split step</a></p></li><li><p><a href="#add-aggregate-step_collection">Adding an aggregate step</a></p></li><li><p><a href="#example-processing-collection_collection">Example of processing a collection in a flow</a></p></li></ul></div><div class="sect3"><h4 id="about-data-types-and-collections_collection">About data types and collections in the data mapper</h4><div class="paragraph"><p>In the data mapper, a field can be:</p></div><div class="ulist"><ul><li><p>A <strong>primitive</strong> type that stores a single value. Examples of primitive types include <code>boolean</code>, <code>char</code>, <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, and <code>double</code>. A primitive type is not expandable because it is a single field.</p></li><li><p>A <strong>complex</strong> type that consists of multiple fields of different types. You define the child fields of a complex type at design time. In the data mapper, a complex type is expandable so that you can view its child fields.</p></li></ul></div><div class="paragraph"><p>Each type of field (primitive and complex) can also be a collection. A collection is a single field that can have multiple values. The number of items in a collection is determined at runtime. At design time, in the data mapper, a collection is indicated by <span class="image"><img src="images/integrating-applications/collection-icon.png" alt="the Collection icon"></span>. Whether a collection is expandable in the data mapper interface is determined by its type. When a collection is a primitive type, it is not expandable. When a collection is a complex type, then the data mapper is expandable to display the collections child fields. You can map from/to each field.</p></div><div class="paragraph"><p>Here are some examples:</p></div><div class="ulist"><ul><li><p><code>ID</code> is a primitive type field (<code>int</code>). At runtime, an employee can have only one <code>ID</code>. For example, <code>ID=823</code>. Therefore, <code>ID</code> is a primitive type that is not also a collection. In the data mapper, <code>ID</code> is not expandable.</p></li><li><p><code>email</code> is a primitive type field (string). At runtime, an employee can have multiple <code>email</code> values. For example, <code>email&lt;0&gt;=<a href="mailto:aslan@home.com">aslan@home.com</a></code> and <code>email&lt;1&gt;=<a href="mailto:aslan@business.com">aslan@business.com</a></code>. Therefore, <code>email</code> is a primitive type that also is a collection. The data mapper uses <span class="image"><img src="images/integrating-applications/collection-icon.png" alt="the Collection icon"></span>to indicate that the <code>email</code> field is a collection but <code>email</code> is not expandable because it is a primitive type (it does not have child fields).</p></li><li><p><code>employee</code> is a complex object field that has several child fields, including <code>ID</code> and <code>email</code>. At runtime, <code>employee</code> is also a collection, because the company has many employees.<br>At design time, the data mapper uses <span class="image"><img src="images/integrating-applications/collection-icon.png" alt="the Collection icon"></span>to indicate that <code>employee</code> is a collection. The <code>employee</code> field is expandable because it is a complex type that has child fields.</p></li></ul></div></div><div class="sect3"><h4 id="about-processing-collections_collection">About processing collections</h4><div class="paragraph"><p>The easiest way for a flow to process a collection is to use the data mapper to map fields that are in a source collection to fields that are in a target collection. For many flows, this is all that is required. For example, a flow might obtain a collection of employee records from a database and then insert those records into a spreadsheet. Between the database connection and the Google Sheets connection, a data mapper step maps the database fields to the Google Sheets fields. Since both the source and the target are collections, when Syndesis executes the flow, it calls the Google Sheets connection once. In that call, Syndesis iterates through the records and correctly populates the spreadsheet.</p></div><div class="paragraph"><p>In some flows, you might need to split a collection into individual objects. For example, consider a flow that connects to a database and obtains a collection of employees who will lose allotted time off if they do not use it before a certain date. The flow then needs to send an email notification to each of these employees. In this flow, you would add a split step after the database connection. You would then add a data mapper step that maps the source fields for an employee record to target fields in a Gmail connection that sends a message. When Syndesis executes the flow, it executes the data mapper step and the Gmail connection once for each employee.</p></div><div class="paragraph"><p>Sometimes, after you split a collection in a flow, and after the flow executes some steps once for each element that was in the collection, you want the flow to operate on the collection again. Consider the example in the previous paragraph. Suppose that after a Gmail connection sends a message to each employee, you want to add a list of the employees who were notified to a spreadsheet. In this scenario, after the Gmail connection, add an aggregate step to create a collection of employee names. Then add a data mapper step that maps fields in the source collection to fields in the target Google Sheets connection. When Syndesis executes the flow, it executes the new data mapper step and the Google Sheets connection once for the collection.</p></div><div class="paragraph"><p>These are the most common scenarios for processing a collection in a flow. However, much more complex processing is also possible. For example, when the elements in a collection are themselves collections, you can nest split and aggregate steps inside other split and aggregate steps.</p></div></div><div class="sect3"><h4 id="using-data-mapper-to-process-collections_collection">Using the data mapper to process collections</h4><div class="paragraph"><p>In a flow, when a step outputs a collection and when a subsequent connection that is in the flow expects a collection as the input, you can use the data mapper to specify how you want the flow to process the collection.</p></div><div class="paragraph"><p>When a step outputs a collection, the flow visualization displays <strong>Collection</strong> in the details about the step. For example:</p></div><div class="paragraph"><p><span class="image"><img src="images/integrating-applications/data-type-collection.png" alt="Data Type: SQL Result (Collection)"></span></p></div><div class="paragraph"><p>Add a data mapper step after the step that provides the collection and before the step that needs the mappings. Exactly where in the flow this data mapper step needs to be depends on the other steps in the flow. The following image shows mappings from source collection fields to target collection fields:</p></div><div class="paragraph"><p><span class="image"><img src="images/integrating-applications/map-collections.png" alt="mapping collection"></span></p></div><div class="paragraph"><p>In the source and target panels, the data mapper displays <span class="image"><img src="images/integrating-applications/collection-icon.png" alt="the Collection icon"></span>to indicate a collection.</p></div><div class="paragraph"><p>When a collection is a complex type, the data mapper displays the collections child fields. You can map from/to each field.</p></div><div class="paragraph"><p>When a source field is nested in a number of collections you can map it to a target field that meets one of these conditions:</p></div><div class="ulist"><ul><li><p>The target field is nested in the same number of collections as the source field. For example, these mappings are allowed:</p><div class="ulist"><ul><li><p>/A&lt;&gt;/B&lt;&gt;/C &#8594; /D&lt;&gt;/E&lt;&gt;/F</p></li><li><p>/A&lt;&gt;/B&lt;&gt;/C &#8594; /G&lt;&gt;/H/I&lt;&gt;/J</p></li></ul></div></li><li><p>The target field is nested in only one collection. For example, this mapping is allowed:</p><div class="paragraph"><p>/A&lt;&gt;/B&lt;&gt;/C &#8594; /K&lt;&gt;/L</p></div><div class="paragraph"><p>In this case, the data mapper uses a depth-first algorithm to iterate over all values in the source. In order of occurrence, the data mapper puts the source values into a single target collection.</p></div></li></ul></div><div class="paragraph"><p>The following mapping is not allowed:</p></div><div class="paragraph"><p>/A&lt;&gt;/B&lt;&gt;/C cannot-map-to /M&lt;&gt;/N/O&lt;&gt;/P&lt;&gt;/Q</p></div><div class="paragraph"><p>When Syndesis executes the flow, it iterates over the source collection elements to populate the target collection elements. If you map one or more source collection fields to a target collection or to target collection fields, the target collection elements contain values for only the mapped fields.</p></div><div class="paragraph"><p>If you map a source collection or a field in a source collection to a target field that is not in a collection, then when Syndesis executes the flow, it assigns the value from only the last element in the source collection. Any other elements in the collection are ignored in that mapping step. However, any subsequent mapping steps can access all elements in the source collection.</p></div><div class="paragraph"><p>When a connection returns a collection that is defined in a JSON or Java document, the data mapper can usually process the source document as a collection.</p></div></div><div class="sect3"><h4 id="add-split-step_collection">Adding a split step</h4><div class="paragraph"><p>During execution of a flow, when a connection returns a collection of objects, Syndesis executes subsequent steps once for the collection. If you want to execute subsequent steps once for each object that is in the collection, add a split step. For example, a Google Sheets connection returns a collection of row objects. To execute subsequent steps once for each row, add a split step after the Google Sheets connection.</p></div><div class="paragraph"><p>Ensure that the input to a split step is always a collection. If a split step gets a source document that is not a collection type, the step splits the input at each space. For example, Syndesis splits Hello world! input into two elements: Hello and world!, and passes those two elements to the next step in the flow. In particular, XML data is not a collection type.</p></div><div class="ulist"><div class="title">Prerequisites</div><ul><li><p>You are creating or editing a flow.</p></li><li><p>The flow already has all the connections that it requires.</p></li><li><p>In the flow visualization, the connection that obtains the source data indicates that the data is a <strong>(Collection)</strong>.</p></li></ul></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the flow visualization, click the <span class="image"><img src="images/integrating-applications/PlusSignToAddStepOrConnection.png" alt="PlusSignToAddStepOrConnection" title="plus sign"></span>at the location where you want to add the split step.</p></li><li><p>Click <strong>Split</strong>. This step does not require any configuration.</p></li><li><p>Click <strong>Next</strong>.</p></li></ol></div><div class="paragraph"><div class="title">Additional information</div><p>Typically, you want to add any split steps and aggregate steps before you add data mapper steps. This is because whether the data is a collection or individual objects affects the mappings. If you add a data mapper step and then add a split step, you usually need to redo the mappings. Likewise, if you remove a split or aggregate step, then you would need to redo any mappings.</p></div></div><div class="sect3"><h4 id="add-aggregate-step_collection">Adding an aggregate step</h4><div class="paragraph"><p>In a flow, add an aggregate step where you want Syndesis to create a collection from individual objects. During execution, after an aggregate step, instead of executing subsequent steps once for each object, Syndesis executes subsequent steps once for the collection.</p></div><div class="paragraph"><p>When deciding whether to add an aggregate step to a flow, consider the connections in the flow. After a split step, for each subsequent connection, Syndesis connects to that application once for each element in the flows data. For some connections, it might be preferable to connect once rather than multiple times.</p></div><div class="ulist"><div class="title">Prerequisites</div><ul><li><p>You are creating or editing a flow.</p></li><li><p>The flow already has all the connections that it requires.</p></li><li><p>A previous step split a collection into individual objects.</p></li></ul></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the flow visualization, where you want to add an aggregate step to the flow, click the <span class="image"><img src="images/integrating-applications/PlusSignToAddStepOrConnection.png" alt="PlusSignToAddStepOrConnection" title="plus sign"></span>.</p></li><li><p>Click <strong>Aggregate</strong>. This step does not require any configuration.</p></li><li><p>Click <strong>Next</strong>.</p></li></ol></div><div class="paragraph"><div class="title">Additional information</div><p>Typically, you want to add any split and aggregate steps before you add data mapper steps. This is because whether the data is a collection or individual objects affects the mappings. If you add a data mapper step and then add an aggregate step, you usually need to redo the mappings. Likewise, if you remove an aggregate step, then you would need to redo any mappings.</p></div></div><div class="sect3"><h4 id="example-processing-collection_collection">Example of processing a collection in a flow</h4><div class="paragraph"><p>This simple integration obtains a collection of tasks from the sample database provided with Syndesis. The flow splits the collection into individual task objects and then filters these objects to find the tasks that have been done. The flow then aggregates the completed tasks in a collection, maps the fields in that collection to fields in a spreadsheet, and finishes by adding a list of completed tasks to a spreadsheet.</p></div><div class="paragraph"><p>The procedure below provides instructions for creating this simple integration.</p></div><div class="ulist"><div class="title">Prerequisites</div><ul><li><p>You created a Google Sheets connection.</p></li><li><p>In the account that the Google Sheets connection accesses, there is a spreadsheet for receiving the database records.</p></li></ul></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>Click <strong>Create Integration</strong>.</p></li><li><p>Add the start connection:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>On the <strong>Choose a connection</strong> page, click <strong>PostgresDB</strong>.</p></li><li><p>On the <strong>Choose an action</strong> page, select <strong>Periodic SQL Invocation</strong>.</p></li><li><p>In the <strong>SQL Statement</strong> field, enter <code><strong>select * from todo</strong></code> and click <strong>Next</strong>.</p></li></ol></div><div class="paragraph"><p>This connection returns a collection of task objects.</p></div></li><li><p>Add the finish connection:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>On the <strong>Choose a connection</strong> page, click your Google Sheets connection.</p></li><li><p>On the <strong>Choose an action</strong> page, select <strong>Append values to a sheet</strong>.</p></li><li><p>In the <strong>SpreadsheetId</strong> field, enter the ID of the spreadsheet to add the list of tasks to.</p></li><li><p>In the <strong>Range</strong> field, enter <code><strong>A:B</strong></code> as the target columns that you want to append values to. The first column, <strong>A</strong>, is for the task IDs. The second column, <strong>B</strong>, is for the task names.</p></li><li><p>Accept the defaults for <strong>Major Dimension</strong> and for <strong>Value Input Option</strong>, and click <strong>Next</strong>.</p></li></ol></div><div class="paragraph"><p>The Google Sheets connection finishes the flow by adding each element in a collection to a spreadsheet.</p></div></li><li><p>Add a split step to the flow:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>In the flow visualization, click the plus sign.</p></li><li><p>Click <strong>Split</strong>.</p></li></ol></div><div class="paragraph"><p>After the flow executes the split step, the result is a set of individual task objects. Syndesis executes the subsequent steps in the flow once for each individual task object.</p></div></li><li><p>Add a filter step to the flow:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>In the flow visualization, after the split step, click the plus sign.</p></li><li><p>Click <strong>Basic Filter</strong> and configure the filter as follows:</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>Click in the first field and select <code><strong>completed</strong></code>, which is the name of the field that contains the data that you want to evaluate.</p></li><li><p>In the second field, select <strong>equals</strong> as the condition that the <strong>completed</strong> field value must satisfy.</p></li><li><p>In the third field, specify <code><strong>1</strong></code> as the value that must be in the <strong>completed</strong> field. <code>1</code> indicates that the task has been completed.</p></li></ol></div></li><li><p>Click <strong>Next</strong>.</p></li></ol></div><div class="paragraph"><p>During execution, the flow executes the filter step once for each task object. The result is a set of individual, completed task objects.</p></div></li><li><p>Add an aggregate step to the flow:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>In the flow visualization, after the filter step, click the plus sign.</p></li><li><p>Click <strong>Aggregate</strong>.</p></li></ol></div><div class="paragraph"><p>Now the result set contains one collection, which contains an element for each completed task.</p></div></li><li><p>Add a data mapper step to the flow:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>In the flow visualization, after the aggregate step, click the plus sign.</p></li><li><p>Click <strong>Data Mapper</strong> and map the following fields from the SQL result source collection to the Google Sheets target collection:</p><div class="ulist"><ul><li><p><strong>id</strong> to <strong>A</strong></p></li><li><p><strong>task</strong> to <strong>B</strong></p></li></ul></div></li><li><p>Click <strong>Done</strong>.</p></li></ol></div></li><li><p>Click <strong>Publish</strong>.</p></li></ol></div><div class="paragraph"><div class="title">Results</div><p>When the integration is running, it obtains tasks from the sample database every minute and then adds the completed tasks to the first sheet in the spreadsheet. The integration maps the task ID to the first column, <strong>A</strong>, and it maps the task name to the second column, <strong>B</strong>.</p></div></div></div><div class="sect2"><h3 id="about-adding-steps_create">About adding steps between connections</h3><div class="paragraph"><p>Although it is not a requirement, the recommendation is to add all needed connections to a primary flow and then, according to the processing that you want the flow to execute, add additional steps between connections. In a flow, each step operates on data obtained from the previous connection(s) and any previous steps. The resulting data is available to the next step in the flow.</p></div><div class="paragraph"><p>Often, you must map data fields that are received from a connection to data fields that the next connection in the flow can operate on. After you add all connections to a flow, check the flow visualization. For each connection that requires data mapping before it can operate on the input data, Syndesis displays <span class="image"><img src="images/integrating-applications/DataTypeMismatchWarning.png" alt="DataTypeMismatchWarning" title="a warning"></span>. Click this icon to see <strong>Data Type Mismatch: Add a data mapper step before this connection to resolve the difference.</strong></p></div><div class="paragraph"><p>You can click the link in the message to display the <strong>Configure Mapper</strong> page in which you add and specify a data mapper step. However, the recommendation is to add other needed steps, and then add data mapper steps last.</p></div></div><div class="sect2"><h3 id="evaluating-integration-data-to-determine-execution-flow_create">Evaluating integration data to determine the execution flow</h3><div class="paragraph"><p>In a flow, a <strong>Conditional Flows</strong> step evaluates integration data against conditions that you specify. For each specified condition, you add connections and other steps to the flow associated with that condition. During execution, a <strong>Conditional Flows</strong> step evaluates incoming data to determine which flow to execute.</p></div><div class="paragraph"><p>The following topics provide details:</p></div><div class="ulist"><ul><li><p><a href="#behavior-of-conditional-flows-step_condition">Behavior of a <strong>Conditional Flows</strong> step</a></p></li><li><p><a href="#example-of-a-conditional-flows-step_condition">Example of a <strong>Conditional Flows</strong> step</a></p></li><li><p><a href="#general-procedure-for-configuring-conditional-flows-step_condition">General procedure for configuring a <strong>Conditional Flows</strong> step</a></p></li><li><p><a href="#using-basic-expression-builder_condition">Using the basic expression builder to specify conditions</a></p></li><li><p><a href="#using-advanced-expression-builder_condition">Using the advanced expression builder to specify conditions</a></p></li><li><p><a href="#adding-steps-to-conditional-flows_condition">Adding steps to conditional flows</a></p></li></ul></div><div class="sect3"><h4 id="behavior-of-conditional-flows-step_condition">Behavior of a <strong>Conditional Flows</strong> step</h4><div class="paragraph"><p>During integration development, you can add a <strong>Conditional Flows</strong> step to a flow and define one or more conditions. For each condition, you add steps to a conditional flow that is associated with only that condition. During integration execution, for each message that the previous integration step passes to a <strong>Conditional Flows</strong> step, the <strong>Conditional Flows</strong> step evaluates the message content against the specified conditions in the order in which you define them in the Syndesis page for specifying conditions.</p></div><div class="paragraph"><p>In a <strong>Conditional Flows</strong> step, the behavior is one of the following:</p></div><div class="ulist"><ul><li><p>For the first condition that evaluates to true, the integration executes the conditional flow that is associated with that condition.</p></li><li><p>If no conditions evaluate to true, and there is a default conditional flow, the integration executes that flow.</p></li><li><p>If no conditions evaluate to true and there is no default conditional flow, the integration does not execute a conditional flow.</p></li></ul></div><div class="paragraph"><p>After executing a conditional flow, or after no conditions evaluate to true and there is no default conditional flow, the integration executes the next step in the primary flow.</p></div></div><div class="sect3"><h4 id="example-of-a-conditional-flows-step_condition">Example of a <strong>Conditional Flows</strong> step</h4><div class="paragraph"><p>Suppose that an integration connects to a SQL database to obtain information about how much paid-time-off (PTO) each employee has. The returned data indicates:</p></div><div class="ulist"><ul><li><p>Some employees might lose PTO if they do not use it by a certain date.</p></li><li><p>Other employees already used more PTO than they earned.</p></li><li><p>The rest of the employees have PTO that they can use without time restrictions.</p></li></ul></div><div class="paragraph"><p>In a <strong>Conditional Flows</strong> step, this example integration can define two conditions, an execution flow for each condition, and a default execution flow:</p></div><div class="ulist"><ul><li><p>When PTO is greater than some number, it indicates that some PTO might be lost if not used by a certain date. When this condition evaluates to true, the integration executes a flow that sends email to affected employees. The email contains the amount of PTO that must be used and the date by which it must be used.</p></li><li><p>When PTO is a negative number, it indicates that some PTO has been used but not earned. When this condition evaluates to true, the integration executes a flow that sends an email to affected employees. The email contains the amount of PTO that the employee has overdrawn and specifies the date on which the employee begins to accrue PTO again.</p></li><li><p>When neither of the two conditions evaluates to true, the integration executes the default flow. This example integration executes the default conditional flow for employees whose PTO is neither a negative number nor above some specified number. The default flow sends an email to those employees with a statement of the amount of PTO that the employee has.</p></li></ul></div></div><div class="sect3"><h4 id="general-procedure-for-configuring-conditional-flows-step_condition">General procedure for configuring a <strong>Conditional Flows</strong> step</h4><div class="paragraph"><p>After you add a <strong>Conditional Flows</strong> step to a flow, the workflow for configuring the step is as shown in the following image:</p></div><div class="paragraph"><p><span class="image"><img src="images/integrating-applications/WorkflowForConfiguringConditionalFlowsStep.png" alt="Workflow for configuring Conditional Flows step"></span></p></div><div class="ulist"><div class="title">More about the workflow</div><ul><li><p>The basic expression builder prompts you for the property that contains the content that you want to evaluate, and the condition and value that you want to test for. The basic expression builder is suitable for most <strong>Conditional Flows</strong> steps.</p></li><li><p>The advanced expression builder lets you specify a conditional expression in Camel Simple Language.</p></li><li><p>You must use the same expression builder for all conditions. In other words, to configure a <strong>Conditional Flows</strong> step, you must use the basic expression builder or the advanced expression builder. You cannot use both.</p></li><li><p>In a conditional flow, you cannot add a <strong>Conditional Flows</strong> step.</p></li></ul></div></div><div class="sect3"><h4 id="using-basic-expression-builder_condition">Using the basic expression builder to specify conditions</h4><div class="paragraph"><p>In a flow, add a <strong>Conditional Flows</strong> step when you want to evaluate incoming data to determine the integration&#8217;s execution path. The procedure described here shows how to use the basic expression builder to specify conditions.</p></div><div class="ulist"><div class="title">Prerequisites</div><ul><li><p>You are creating or editing a primary flow. If this is a simple integration, the start and finish connections have been added.</p></li><li><p>Input to a <strong>Conditional Flows</strong> step must be an individual message. In the integration visualization, if the previous step&#8217;s <strong>Data Type</strong> shows <strong>(Collection)</strong>, add a <strong>Split</strong> step after the previous step and before this <strong>Conditional Flows</strong> step.</p></li><li><p>You are familiar with the fields that will be in the messages that the integration passes to the <strong>Conditional Flows</strong> step you are about to add.</p></li></ul></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the integration visualization, where you want to add a <strong>Conditional Flows</strong> step, click <span class="image"><img src="images/integrating-applications/PlusSignToAddStepOrConnection.png" alt="PlusSignToAddStepOrConnection" title="plus sign"></span>.</p></li><li><p>Click <strong>Conditional Flows</strong>.</p></li><li><p>Click <strong>Select</strong> in the <strong>Basic expression builder</strong> entry.</p></li><li><p>In the <strong>Configure Conditional Flows</strong> page, define one or more conditions:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Click in the initial <strong>When</strong> field.</p></li><li><p>In the list of properties, click the property that contains the content that you want the <strong>Conditional Flows</strong> step to evaluate.</p></li><li><p>In the next field, accept <strong>Contains</strong> as the condition for which the step evaluates the data or select another condition. The condition that you select in this field must evaluate to true for the value that you enter in the next field.</p></li><li><p>In the third field, specify the value that the condition tests for.</p></li><li><p>Optional. Click <strong>Add another condition</strong> to specify another condition.</p></li><li><p>Repeat this set of steps for each additional condition that you want to define.</p></li><li><p>Optional. Change the order in which the integration evaluates the defined conditions by clicking the up or down arrow to the right of a condition.</p></li><li><p>Optional. Click <strong>Execute default flow</strong> if you want there to be a default conditional flow.</p><div class="paragraph"><p>If you select <strong>Execute default flow</strong>, during execution, if none of the conditions that you specified evaluates to true, the integration executes the default conditional flow. If you do not select <strong>Execute default flow</strong>, during execution, if none of the conditions that you specified evaluates to true, the integration continues execution with the step that follows this <strong>Conditional Flows</strong> step.</p></div></li></ol></div></li><li><p>Click <strong>Next</strong>.</p></li><li><p>Optional. Specify the output data type if Syndesis prompts for it. All conditional flows that are part of this <strong>Conditional Flows</strong> step must have the same output type.</p></li><li><p>Click <strong>Next</strong>.</p><div class="paragraph"><p>Syndesis displays the flow visualization. Below the <strong>Conditional Flows</strong> step that you are adding, there is an entry for each condition that you specified, as well as an entry for an <strong>Otherwise</strong> default flow if you indicated that the <strong>Conditional Flows</strong> step has a default flow.</p></div></li></ol></div><div class="paragraph"><div class="title">Next step</div><p>For each condition, add steps to its associated flow. If there is a default flow, add steps to the default flow.</p></div><div class="ulist"><div class="title">Additional resources</div><ul><li><p>For details about the conditions that you can select in the middle field for each condition, see <a href="https://camel.apache.org/manual/latest/simple-language.html#_operator_support">Camel Simple Language operators</a>. Note that the <strong>matches</strong> condition corresponds to the Simple Language <strong>regex</strong> operator.</p></li><li><p>If you cannot define the conditions that you need by using the basic expression builder, see <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#using-advanced-expression-builder_condition">Using the advanced expression builder to specify conditions</a>.</p></li></ul></div></div><div class="sect3"><h4 id="using-advanced-expression-builder_condition">Using the advanced expression builder to specify conditions</h4><div class="paragraph"><p>In a flow, add a <strong>Conditional Flows</strong> step when you want to evaluate incoming data to determine the integration&#8217;s execution path. The procedure described here shows how to use the advanced expression builder to specify conditional expressions in Camel Simple Language.</p></div><div class="ulist"><div class="title">Prerequisites</div><ul><li><p>You are creating or editing a primary flow. If this is a simple integration, the start and finish connections have been added.</p></li><li><p>Input to a <strong>Conditional Flows</strong> step must be an individual message. In the integration visualization, if the previous step&#8217;s <strong>Data Type</strong> shows <strong>(Collection)</strong>, add a <strong>Split</strong> step.</p></li><li><p>You are familiar with the fields that will be in the messages that the integration passes to the <strong>Conditional Flows</strong> step you are about to add.</p></li><li><p>You are familiar with the <a href="http://camel.apache.org/simple.html">Camel Simple Expression</a> language or you have expressions for the conditions that you want to evaluate.</p></li></ul></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the integration visualization, where you want to add a <strong>Conditional Flows</strong> step, click <span class="image"><img src="images/integrating-applications/PlusSignToAddStepOrConnection.png" alt="PlusSignToAddStepOrConnection" title="plus sign"></span>.</p></li><li><p>Click <strong>Conditional Flows</strong>.</p></li><li><p>Click <strong>Select</strong> in the <strong>Advanced expression builder</strong> entry.</p></li><li><p>In the <strong>Configure Conditional Flows</strong> page, define one or more conditions:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>In the initial <strong>When</strong> field, enter a Camel Simple Language conditional expression. For example, the following expression evaluates to true when the body of the message contains a <code>pto</code> field that is greater than <code>160</code>:</p><div class="listingblock"><div class="content"><pre>${body.pto} &gt; 160</pre></div></div><div class="paragraph"><p>When this expression evaluates to true, the integration executes the conditional flow that you create and associate with this condition.</p></div><div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content"><div class="paragraph"><p>In an expression, an additional property specification is required when the <strong>Conditional Flows</strong> step is in one of the following kinds of flows:</p></div><div class="ulist"><ul><li><p>An API provider integration operation flow</p></li><li><p>A simple integration that starts with a webhook connection</p></li><li><p>A simple integration that starts with a custom REST API connection</p></li></ul></div><div class="paragraph"><p>In these flows, Syndesis wraps the actual message content inside a <code>body</code> property. This means that the input to a <strong>Conditional Flows</strong> step contains a <code>body</code> property that contains another <code>body</code> property that contains the actual message content. Consequently, in an expression that is in a <strong>Conditional Flows</strong> step that is in one of these kinds of flows, you must specify two instances of <code>body</code>. For example, suppose you want to evaluate content that is in the <code>pto</code> field of the input message. Specify the expression like this:</p></div><div class="listingblock"><div class="content"><pre>${body.body.pto} &gt; 160</pre></div></div></td></tr></table></div></li><li><p>Optional. Click <strong>Add another condition</strong>, and repeat the previous step. Do this for each additional condition that you want to define.</p></li><li><p>Optional. Change the order in which the <strong>Conditional Flows</strong> step evaluates the defined conditions by clicking the up or down arrow to the right of a condition field.</p></li><li><p>Optional. Click <strong>Execute default flow</strong> if you want there to be a default conditional flow.</p><div class="paragraph"><p>If you select <strong>Execute default flow</strong>, during execution, if none of the conditions that you specified evaluates to true, the integration executes the default conditional flow. If you do not select <strong>Execute default flow</strong>, during execution, if none of the conditions that you specified evaluates to true, the integration continues execution with the step that follows this <strong>Conditional Flows</strong> step.</p></div></li></ol></div></li><li><p>Click <strong>Next</strong>.</p></li><li><p>Optional. Specify the output data type if Syndesis prompts for it. All conditional flows that are part of this <strong>Conditional Flows</strong> step must have the same output type.</p></li><li><p>Click <strong>Next</strong>.</p><div class="paragraph"><p>Syndesis displays the flow visualization. Below the <strong>Conditional Flows</strong> step that you are adding, there is an entry for each condition that you specified, as well as an entry for an <strong>Otherwise</strong> default flow if you indicated that the <strong>Conditional Flows</strong> step has a default flow.</p></div></li></ol></div><div class="paragraph"><div class="title">Next step</div><p>For each condition, add steps to its associated flow. If there is a default flow, add steps to the default flow.</p></div><div class="paragraph"><div class="title">Additional resources</div><p><a href="https://camel.apache.org/manual/latest/simple-language.html#_operator_support">Camel Simple Language operators</a>.</p></div></div><div class="sect3"><h4 id="adding-steps-to-conditional-flows_condition">Adding steps to conditional flows</h4><div class="paragraph"><p>In a <strong>Conditional Flows</strong> step, after you define conditions, for each condition, add steps to the flow that is associated with that condition. During execution, when the <strong>Conditional Flows</strong> step evaluates a condition as true, it executes the flow that is associated with that condition.</p></div><div class="ulist"><div class="title">Prerequisites</div><ul><li><p>You defined the conditions for this <strong>Conditional Flows</strong> step.</p></li><li><p>You are familiar with the fields that will be in the messages that the integration passes to this <strong>Conditional Flows</strong> step.</p></li><li><p>You created each connection that you want to add to a conditional flow.</p></li></ul></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the integration visualization, for the condition whose flow you want to add to, click <strong>Open Flow</strong>.</p><div class="paragraph"><p>Syndesis displays that condition near the top of the page. The conditional flow visualization shows the <strong>Flow Start</strong> and <strong>Flow End</strong> steps that all conditional flows have.</p></div></li><li><p>In the flow visualization, click <span class="image"><img src="images/integrating-applications/PlusSignToAddStepOrConnection.png" alt="PlusSignToAddStepOrConnection" title="plus sign"></span>where you want to add a step to this conditional flow.</p></li><li><p>Click the step that you want to add. You can add any connection or step that you can add to a primary flow.</p><div class="paragraph"><p>The output from the <strong>Flow Start</strong> step is always the same as the output from the primary flow step that is before this <strong>Conditional Flows</strong> step. For example, if you add a filter step or a data mapper step to this conditional flow, the available fields are the same fields that would be available in the primary flow.</p></div></li><li><p>Configure the step as needed.</p></li><li><p>Repeat the previous three instructions for each step that you want to add to this conditional flow.</p></li><li><p>At the top of the page, in the <strong>Flow</strong> field, click the down carat and click <strong>Back to primary flow</strong>, which saves this conditional flow and displays the primary flow.</p></li><li><p>For each conditional flow that you want to add to, repeat this procedure.</p></li></ol></div><div class="paragraph"><div class="title">Results</div><p>The primary flow has a conditional flow for each condition that you defined in the <strong>Conditional Flows</strong> step. If you selected the <strong>Execute default flow</strong> option, the primary flow also has a default conditional flow.</p></div><div class="paragraph"><p>During execution, the <strong>Conditional Flows</strong> step executes the conditional flow that is associated with the first condition that evaluates to true. The integration then executes the step that follows the <strong>Conditional Flows</strong> step.</p></div><div class="paragraph"><p>If no condition evaluates to true then the <strong>Conditional Flows</strong> step executes the default conditional flow. The integration then executes the step that follows the <strong>Conditional Flows</strong> step.</p></div><div class="paragraph"><p>If both of the following are true:</p></div><div class="ulist"><ul><li><p>No condition evaluates to true.</p></li><li><p>There is no default conditional flow.</p></li></ul></div><div class="paragraph"><p>Then the integration executes the step that follows the <strong>Conditional Flows</strong> step.</p></div></div></div><div class="sect2"><h3 id="add-data-mapping-step_create">Adding a data mapper step</h3><div class="paragraph"><p>Almost all integrations require data mapping. A data mapper step maps data fields from the previous connection(s) and any other steps to data fields that the next connection in the flow can operate on. For example, suppose the integration data contains a <code>Name</code> field and the next connection in the flow has a <code>CustomerName</code> field. You need to map the source <code>Name</code> field to the target <code>CustomerName</code> field.</p></div><div class="admonitionblock important"><table><tr><td class="icon"><div class="title">Important</div></td><td class="content">The data mapper displays the largest possible set of source fields that can be provided by the previous integration step. However, not all connections provide data in each displayed source field. For example, a change to a third-party application might discontinue providing data in a particular field. As you create an integration, if you notice that data mapping is not behaving as you expect, ensure that the source field that you want to map contains the data that you expect.</td></tr></table></div><div class="paragraph"><div class="title">Prerequisite</div><p>You are creating or editing a flow.</p></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the flow visualization, where you want to add a data mapper step, click the <span class="image"><img src="images/integrating-applications/PlusSignToAddStepOrConnection.png" alt="PlusSignToAddStepOrConnection" title="plus sign"></span>.</p></li><li><p>Click <strong>Data Mapper</strong> to display source and target fields in the data mapper canvas.</p></li></ol></div><div class="paragraph"><div class="title">Next step</div><p>See <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#mapping-data_ug">Mapping integration data to fields for the next connection</a>.</p></div></div><div class="sect2"><h3 id="add-basic-filter-step_create">Adding a basic filter step</h3><div class="paragraph"><p>You can add a step to a flow to filter the data that the flow operates on. In a filter step, Syndesis inspects the data and continues only if the content meets criteria that you define. For example, in a flow that obtains data from Twitter, you can specify that you want to continue execution by operating only on tweets that contain "Red Hat".</p></div><div class="ulist"><div class="title">Prerequisites</div><ul><li><p>The flow contains all connections that it needs to.</p></li><li><p>You are creating or editing a flow.</p></li></ul></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the flow visualization, where you want to add a filter step, click the <span class="image"><img src="images/integrating-applications/PlusSignToAddStepOrConnection.png" alt="PlusSignToAddStepOrConnection" title="plus sign"></span>.</p></li><li><p>Click <strong>Basic Filter</strong>.</p></li><li><p>On the <strong>Configure Basic Filter Step</strong> page, in the <strong>Continue only if incoming data match</strong> field:</p><div class="ulist"><ul><li><p>Accept the default that all defined rules must be satisfied.</p></li><li><p>Or, select <strong>ANY of the following</strong> to indicate that only one rule must be satisfied.</p></li></ul></div></li><li><p>Define the filter rule:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>In the <strong>Property Name</strong> field, enter or select the name of the field that contains the content you want the filter to evaluate. For example, suppose the data coming in to the step consists of tweets that mention your Twitter handle. You want to continue execution only when the tweet contains certain content. The tweet is in a field named <code>text</code> so you enter or select <code>text</code> as the value in the property name field.</p><div class="paragraph"><p>You can define the property name in the following ways:</p></div><div class="ulist"><ul><li><p>Start typing. The field has a typeahead feature that provides a list of possible completions for you in a pop-up box. Select the correct one from the box.</p></li><li><p>Click in the field. A dropdown box appears with a list of available properties. Select the property of interest from the list.</p></li></ul></div></li><li><p>In the <strong>Operator</strong> field, select an operator from the dropdown box. The setting defaults to <strong>Contains</strong>. For execution to continue, the condition that you select in this field must evaluate to true for the value that you enter in the <strong>Keywords</strong> field.</p></li><li><p>In the <strong>Keywords</strong> field, enter a value to filter on. For example, suppose that you accept the default <strong>Contains</strong> operator and you want to continue integration execution only when the incoming text mentions a certain product. You would enter the product name here.</p></li></ol></div></li><li><p>Optionally, click <strong>+ Add another rule</strong> and define another rule.</p><div class="paragraph"><p>You can delete a rule by clicking the trash can icon in the top right of the rule entry.</p></div></li><li><p>When the filter step is complete, click <strong>Done</strong> to add it to the flow.</p></li></ol></div><div class="ulist"><div class="title">Additional resources</div><ul><li><p>For details about the operators and for examples of specifying text to evaluate, see <a href="https://camel.apache.org/manual/latest/simple-language.html#_operator_support">Camel Simple Language operators</a>. Note that the basic filter step <strong>matches</strong> operator corresponds to the Simple Language <strong>regex</strong> operator.</p></li><li><p>If you cannot define the filter you need in a basic filter step, see <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#add-advanced-filter-step_create">Adding an advanced filter step</a>.</p></li></ul></div></div><div class="sect2"><h3 id="add-advanced-filter-step_create">Adding an advanced filter step</h3><div class="paragraph"><p>In a filter step, Syndesis inspects the data and continues executing the flow only if the content meets criteria that you define. If the basic filter step does not let you define the exact filter that you need, then add an advanced filter step.</p></div><div class="ulist"><div class="title">Prerequisites</div><ul><li><p>The flow contains all connections that it needs to.</p></li><li><p>You are creating or editing a flow.</p></li><li><p>You are familiar with the Camel Simple Language, or you have been provided with a filter expression.</p></li></ul></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the flow visualization, where you want to add an advanced filter step to the flow, click the <span class="image"><img src="images/integrating-applications/PlusSignToAddStepOrConnection.png" alt="PlusSignToAddStepOrConnection" title="plus sign"></span>.</p></li><li><p>Click <strong>Advanced Filter</strong>.</p></li><li><p>In the edit box, use the <a href="http://camel.apache.org/simple.html">Camel Simple Language</a> to specify a filter expression. For example, the following expression evaluates to true when the message header&#8217;s <code>type</code> field is set to <code>widget</code>:</p><div class="listingblock"><div class="content"><pre>${in.header.type} == 'widget'</pre></div></div><div class="paragraph"><p>In the following example, the expression evaluates to true when the body of the message contains a <code>title</code> field:</p></div><div class="listingblock"><div class="content"><pre>${in.body.title}</pre></div></div></li><li><p>Click <strong>Next</strong> to add the advanced filter step to the flow.</p></li></ol></div><div class="paragraph"><div class="title">Additional property specification in some kinds of flows</div><p>In an expression, an additional property specification is required when the advanced filter step is in one of the following kinds of flows:</p></div><div class="ulist"><ul><li><p>An API provider integration operation flow</p></li><li><p>A simple integration that starts with a webhook connection</p></li><li><p>A simple integration that starts with a custom REST API connection</p></li></ul></div><div class="paragraph"><p>In these flows, Syndesis wraps the actual message content inside a <code>body</code> property. This means that the input to the advanced filter contains a <code>body</code> property that contains another <code>body</code> property that contains the actual message content. Consequently, in an advanced filter expression that is in one of these kinds of flows, you must specify two instances of <code>body</code>. For example, suppose you want to evaluate content that is in the <code>completed</code> field of the input message. Specify the expression like this:</p></div><div class="listingblock"><div class="content"><pre>${body.body.completed} = 1</pre></div></div></div><div class="sect2"><h3 id="add-template-step_create">Adding a template step</h3><div class="paragraph"><p>In a flow, a template step takes data from a source and inserts it into the format that is defined in a template that you upload to Syndesis. The benefit of a template step is that it provides data output in a consistent format that you specify.</p></div><div class="paragraph"><p>In the template, you define placeholders and specify static text. When you create the flow, you add a template step, map source fields to the template placeholders, and then map template content to the next step in the flow. When Syndesis executes the flow, it inserts the values that are in the mapped source fields into an instance of the template and makes the result available to the next step in the flow.</p></div><div class="paragraph"><p>If a flow includes a template step then it is most likely the only template step in that flow. However, more than one template step in a flow is allowed.</p></div><div class="paragraph"><p>Syndesis supports the following kinds of templates: <a href="https://freemarker.apache.org">Freemarker</a>, <a href="https://mustache.github.io">Mustache</a>, <a href="https://velocity.apache.org">Velocity</a>.</p></div><div class="ulist"><div class="title">Prerequisites</div><ul><li><p>You must be creating or editing a flow.</p></li><li><p>If you are creating a simple integration then it must already have its start and finish connections.</p></li></ul></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the flow visualization, click the <span class="image"><img src="images/integrating-applications/PlusSignToAddStepOrConnection.png" alt="Plus Sign"></span>where you want to add a template step.</p></li><li><p>Click <strong>Template</strong>. The <strong>Upload Template</strong> page opens.</p></li><li><p>Specify the template type, which is Freemarker, Mustache, or Velocity.</p></li><li><p>To define the template, do one of the following:</p><div class="ulist"><ul><li><p>Drag and drop a template file or a file that contains text that you want to modify to create a template, into the template editor.</p></li><li><p>Click <strong>browse to upload</strong>, navigate to a file, and upload it.</p></li><li><p>In the template editor, start typing to define a template.</p></li></ul></div></li><li><p>In the template editor, ensure that the template is valid for use with Syndesis. Examples of valid templates are after this procedure. Syndesis displays <span class="image"><img src="images/integrating-applications/RedCircleXError.png" alt="a red error indicator"></span>to the left of a line that contains a syntax error. Hovering over a syntax error indicator displays hints about how to resolve the error.</p></li><li><p>Click <strong>Done</strong> to add the template step to the flow.</p><div class="paragraph"><p>If the <strong>Done</strong> button is not enabled then there is at least one syntax error that you must correct.</p></div><div class="paragraph"><p>Input to a template step must be in the form of a JSON object. Consequently, you must add a data mapping step before a template step.</p></div></li><li><p>To add a data mapper step before the template step:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>In the flow visualization, click the <span class="image"><img src="images/integrating-applications/PlusSignToAddStepOrConnection.png" alt="Plus Sign"></span>that is immediately before the template step that you just added.</p></li><li><p>Click <strong>Data Mapper</strong>.</p></li><li><p>In the data mapper, map a source field to each template placeholder field.</p><div class="paragraph"><p>For example, using the example templates that are after this procedure, map a source field to each of these template fields:</p></div><div class="ulist"><ul><li><p><code>time</code></p></li><li><p><code>name</code></p></li><li><p><code>text</code></p></li></ul></div></li><li><p>In the upper right, click <strong>Done</strong> to add the data mapper step to the flow.</p></li></ol></div><div class="paragraph"><p>Output from a template step is always a JSON object. Consequently, you must add a data mapper step after a template step.</p></div></li><li><p>To add a data mapper step after the template step:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>In the flow visualization, click the <span class="image"><img src="images/integrating-applications/PlusSignToAddStepOrConnection.png" alt="Plus Sign"></span>that is immediately after the template step that you just added.</p></li><li><p>Click <strong>Data Mapper</strong>.</p></li><li><p>In the data mapper, map the template&#8217;s <strong>message</strong> field, which always contains the result of inserting source fields into the template, to a target field. For example, suppose that a Gmail connection is next in the flow and you want to send the result of the template step as the content of a Gmail message. To do this, you would map the <strong>message</strong> source field to the <strong>text</strong> target field.</p></li><li><p>In the upper right, click <strong>Done</strong>.</p></li></ol></div></li></ol></div><div class="paragraph"><div class="title">Examples of templates</div><p>Example of a Mustache template:</p></div><div class="listingblock"><div class="content"><pre>At {{time}}, {{name}} tweeted:
{{text}}</pre></div></div><div class="paragraph"><p>Freemarker and Velocity support this example template:</p></div><div class="listingblock"><div class="content"><pre>At ${time}, ${name} tweeted:
${text}</pre></div></div><div class="paragraph"><p>Velocity also supports syntax without braces, as shown in this example:</p></div><div class="listingblock"><div class="content"><pre>At $time, $name tweeted:
$text</pre></div></div><div class="paragraph"><p>A placeholder cannot contain a <code>.</code> (period).</p></div><div class="paragraph"><div class="title">Additional resources</div><p>For details about mapping fields, see <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#mapping-data_ug">Mapping integration data to fields for the next connection</a>.</p></div></div><div class="sect2"><h3 id="add-custom-step_create">Adding a custom step</h3><div class="paragraph"><p>If Syndesis does not provide a step that you need in a flow, a developer can define one or more custom steps in an extension. A custom step operates on data between connections in a flow.</p></div><div class="paragraph"><p>You add a custom step to a flow in the same way that you add a built-in step. For a simple integration, choose the start and finish connections, add other connections as needed and then add additional steps. For an API provider integration, select the operation whose flow executes the custom step, add connections as needed to the flow, and then add other steps. When you add a step, Syndesis operates on the data it receives from the previous step(s) in the flow.</p></div><div class="ulist"><div class="title">Prerequisites</div><ul><li><p>You uploaded the custom step extension to Syndesis. See <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#making-extensions-available_add-extension">Making custom features available</a>.</p></li><li><p>You are creating or editing a flow.</p></li><li><p>The flow already has all the connections that it requires.</p></li></ul></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the flow visualization, where you want to add a custom step, click the <span class="image"><img src="images/integrating-applications/PlusSignToAddStepOrConnection.png" alt="PlusSignToAddStepOrConnection" title="plus sign"></span>.</p></li><li><p>Click the custom step that you want to add.</p><div class="paragraph"><p>The available steps includes any custom steps that are defined in extensions that were uploaded to your Syndesis environment.</p></div></li><li><p>Respond to prompts for any information that is required to perform the step. This information varies for each custom step.</p></li></ol></div></div></div></div><div class="sect1"><h2 id="trigger-integrations-with-api-calls_ug">Creating an integration that is triggered by a REST API call</h2><div class="sectionbody"><div class="paragraph"><p>To trigger execution of an integration on demand, start the integration with a REST API description document that you provide. Integrations that start this way are referred to as <em>API provider integrations</em>. An API provider integration allows REST API clients to invoke commands that trigger execution of the integration.</p></div><div class="paragraph"><p>When Syndesis publishes an API provider integration, any client with network access to the integration endpoints can trigger execution of the integration.</p></div><div class="paragraph"><p>The following topics provide information and instructions for creating API provider integrations:</p></div><div class="ulist"><ul><li><p><a href="#overview-benefit-api-provider-integrations_api-provider">Benefit, overview, and workflow for creating API provider integrations</a></p></li><li><p><a href="#requirements-for-api-provider-integrations_api-provider">How OpenAPI operations relate to API provider integration flows</a></p></li><li><p><a href="#create-api-provider-integration_api-provider">Creating an API provider integration</a></p></li><li><p><a href="#define-integration-operation-flows_api-provider">Defining the operation flows for an API provider integration</a></p></li><li><p><a href="#configure-publish-api-provider-quickstart_api-provider">Importing and publishing the example API provider quickstart integration</a></p></li><li><p><a href="#try-api-provider-quickstart_api-provider">Testing the example API provider quickstart integration</a></p></li></ul></div><div class="paragraph"><p>For a video that shows how to create, publish and test an API provider integration, see <a href="https://youtu.be/sox8SSqJ0zQ" class="bare">https://youtu.be/sox8SSqJ0zQ</a>.</p></div><div class="sect2"><h3 id="overview-benefit-api-provider-integrations_api-provider">Benefit, overview, and workflow for creating API provider integrations</h3><div class="paragraph"><p>An API provider integration starts with a REST API service. This REST API service is defined by an OpenAPI 3 (or 2) document that you provide when you create an API provider integration. After you publish an API provider integration, Syndesis deploys the REST API service on OpenShift. The benefit of an API provider integration is that REST API clients can invoke calls that trigger execution of the integration.</p></div><div class="paragraph"><div class="title">Multiple execution flows</div><p>An API provider integration has multiple execution paths, referred to as flows. Each operation that the OpenAPI document defines has its own flow. In Syndesis, for each operation that the OpenAPI document defines, you add connections and other steps to the execution flow for that operation. These steps process the data as required for the particular operation.</p></div><div class="paragraph"><div class="title">Example execution flow</div><p>For example, consider a human resources application that calls a REST API service that Syndesis has made available. Suppose the call invokes the operation that adds a new employee. The operation flow that handles this call could:</p></div><div class="ulist"><ul><li><p>Connect to an application that creates an expense report for new employee equipment.</p></li><li><p>Connect to a SQL database to add an internal ticket for setting up new equipment.</p></li><li><p>Connect to Google mail to send a message to the new employee that provides orientation information.</p></li></ul></div><div class="paragraph"><div class="title">Ways to trigger execution</div><p>There are many ways to call the REST APIs that trigger integration execution, including:</p></div><div class="ulist"><ul><li><p>A web browser page that takes data input and generates the call.</p></li><li><p>An application that explicitly calls the REST APIs, such as the <code>curl</code> utility.</p></li><li><p>Other APIs that call the REST API, for example, a webhook.</p></li></ul></div><div class="paragraph"><div class="title">Ways to edit a flow</div><p>For each operation, you can edit its flow by:</p></div><div class="ulist"><ul><li><p>Adding connections to the applications that need to process the data.</p></li><li><p>Adding steps between connections, including split, aggregate, and data mapping steps.</p></li><li><p>Mapping connection error messages to return codes in the HTTP response that finishes the flow. The response goes to the application that invoked the call that triggered execution of the integration.</p></li></ul></div><div class="paragraph"><div class="title">Workflow for creating an API provider integration</div><p>The <strong>general</strong> workflow for creating an API provider integration is shown in the following diagram:</p></div><div class="paragraph"><p><span class="image"><img src="images/integrating-applications/ApiProviderCreateIntegrationWorkflow.png" alt="General workflow for creating an API provider integration"></span></p></div><div class="paragraph"><div class="title">Publishing an API provider integration</div><p>After you publish an API provider integration, in the integration&#8217;s summary page, Syndesis displays the external URL for your REST API service. This external URL is the base URL that clients use to call your REST API services.</p></div><div class="paragraph"><p>For Syndesis environments on OCP, Red Hat 3scale discovery of API provider integrations might be enabled. In this case, 3scale publishes the URL for invoking services.</p></div><div class="paragraph"><div class="title">Testing an API provider integration</div><p>To test an API provider integration&#8217;s flows, you can use the <code>curl</code> utility. For example, the following <code>curl</code> command triggers execution of the flow for the <strong>Get Task by ID</strong> operation for the REST API service URL: <a href="https://i-task-api-proj319352.6a63.fuse-ignite.openshiftapps.com/api/" class="bare">https://i-task-api-proj319352.6a63.fuse-ignite.openshiftapps.com/api/</a>.</p></div><div class="paragraph"><p>The HTTP <code>GET</code> command is the default request so there is no requirement to specify <code>GET</code>. The last part of the URL specifies the ID of the task to get:</p></div><div class="listingblock"><div class="content"><pre>curl -k https://i-task-api-proj319352.6a63.fuse-ignite.openshiftapps.com/api/todo/1</pre></div></div></div><div class="sect2"><h3 id="requirements-for-api-provider-integrations_api-provider">How OpenAPI operations relate to API provider integration flows</h3><div class="paragraph"><p>An API provider integration&#8217;s OpenAPI document defines the operations that REST API clients can call. Each OpenAPI operation has its own API provider integration flow. Consequently, each operation can also have its own REST API service URL. Each URL is defined by the API service&#8217;s base URL and optionally by a subpath. REST API calls specify an operation&#8217;s URL to trigger execution of the flow for that operation.</p></div><div class="paragraph"><p>Your OpenAPI document determines which HTTP verbs (such as <code>GET</code>, <code>POST</code>, <code>DELETE</code> and so on) you can specify in calls to your REST API service URLs. Examples of calls to API provider URLs are in the <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#try-api-provider-quickstart_api-provider">instructions for trying out the API provider quickstart example</a>.</p></div><div class="paragraph"><p>Your OpenAPI document also determines the possible HTTP status codes that an operation can return. An operations return path can handle only the responses that the OpenAPI document defines. For example, an operation that deletes an object based on its ID might define these possible responses:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">"responses": {
  "204": {
           "description": "Task deleted"
         },
  "404": {
           "description": "No Record found with this ID"
         },
  "500": {
            "description": "Server Error"
        }
}</code></pre></div></div><div class="paragraph"><div class="title">Illustration of an API provider integration example</div><p>The following diagram shows an API provider integration that processes data about people. An external REST API client invokes the REST API URLs that are deployed by the API provider integration. Invocation of a URL triggers execution of the flow for one REST operation. This API provider integration has 3 flows. Each flow can use any connection or step that is available in Syndesis. The REST API along with its flows is one Syndesis API provider integration, which is deployed in one OpenShift pod.</p></div><div class="paragraph"><p><span class="image"><img src="images/integrating-applications/api-provider.png" alt="API provider integration with 3 flows"></span></p></div><div class="paragraph"><div class="title">Editing the OpenAPI document while creating an API provider integration</div><p>After you specify an OpenAPI document for your API provider integration, you can update the document as needed while you define the execution flows for the API operations. To do this, click <strong>View/Edit API Definition</strong> in the upper right of a page in which you are editing the API provider integration. This displays your OpenAPI document in the API Designer editor. Edit and save the document to make changes that are reflected in Syndesis.</p></div><div class="paragraph"><p>Considerations while editing the OpenAPI document:</p></div><div class="ulist"><ul><li><p><strong><code>operationId</code> properties for synchronization</strong></p><div class="paragraph"><p>Synchronization between the versions of the OpenAPI document in the API Designer editor and in the Syndesis integration editor depend on a unique <code>operationId</code> property that is assigned to each operation that is defined in the document. You can assign a specific <code>operationId</code> property value to each operation, or use the one that Syndesis generates automatically.</p></div></li><li><p><strong>Request and response definitions</strong></p><div class="paragraph"><p>In each operation&#8217;s definition, you can supply a JSON schema that defines the operation&#8217;s request and response. Syndesis uses the JSON schema:</p></div><div class="ulist"><ul><li><p>As the basis for the operation&#8217;s input and output data shapes</p></li><li><p>To display operation fields in the data mapper</p></li></ul></div></li><li><p><strong>No cyclic schema references</strong></p><div class="paragraph"><p>A JSON schema for an API provider integration operation cannot have cyclic schema references. For example, a JSON schema that specifies a request or response body cannot reference itself as a whole nor reference any part of itself through intermediate JSON schemas.</p></div></li></ul></div></div><div class="sect2"><h3 id="create-api-provider-integration_api-provider">Creating an API provider integration</h3><div class="paragraph"><p>To create an API provider integration, provide an OpenAPI document (<code>.json</code>, <code>.yaml</code>, or <code>.yml</code> file) that defines the operations that the integration can perform. Syndesis creates an execution flow for each operation. Edit the flow for each operation to add connections and steps that process integration data according to the requirements for that operation.</p></div><div class="ulist"><div class="title">Prerequisites</div><ul><li><p>You are able to provide or define an OpenAPI document for the REST API operations that you want the integration to perform.</p><div class="paragraph"><p>To experiment, <a href="https://github.com/syndesisio/syndesis-quickstarts/tree/1.10/api-provider/task-api.json">download the raw version of the <code>task-api.json</code> file</a>, which is an OpenAPI document for an API provider quickstart. You can upload this file when Syndesis prompts you to provide an OpenAPI document. Alternatively, you can specify the URL for the raw <code>task-api.json</code> file, which is <a href="https://raw.githubusercontent.com/syndesisio/syndesis-quickstarts/1.10/api-provider/task-api.json" class="bare">https://raw.githubusercontent.com/syndesisio/syndesis-quickstarts/1.10/api-provider/task-api.json</a>.</p></div></li><li><p>You have a plan for the flow for each OpenAPI operation.</p></li><li><p>You created a connection for each application or service that you want to add to an operation&#8217;s flow.</p></li></ul></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In Syndesis, in the left navigation panel, click <strong>Integrations</strong>.</p></li><li><p>Click <strong>Create Integration</strong>.</p></li><li><p>On the <strong>Choose a connection</strong> page, click <strong>API Provider</strong>.</p></li><li><p>On the <strong>Start integration with an API call</strong> page:</p><div class="ulist"><ul><li><p>If you have an OpenAPI document that defines the REST API operations, upload the OpenAPI document.</p></li><li><p>If you need to define the OpenAPI document, select <strong>Create a new OpenAPI 3.x document</strong> or <strong>Create a new OpenAPI 2.x document</strong>.</p></li></ul></div></li><li><p>Click <strong>Next</strong>.</p><div class="ulist"><ul><li><p>If you uploaded a document, review or edit it:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Click <strong>Review/Edit</strong> to open the API Designer editor.</p></li><li><p>Review and edit as needed.</p><div class="paragraph"><p>Optionally, if your document uses the OpenAPI 2 specification, you can click <strong>Convert to OpenAPI 3</strong> if you want the API Designer to convert your document to conform with the OpenAPI 3 specification.</p></div></li><li><p>In the upper right, click <strong>Save</strong> or <strong>Cancel</strong> to close the editor.</p></li><li><p>Click <strong>Next</strong>.</p></li></ol></div></li><li><p>If you are creating a document, then in the API Designer editor that Syndesis opens:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Define the OpenAPI document as described in <a href="https://access.redhat.com/documentation/en-us/red_hat_fuse/7.7/html-single/designing_apis/index#create-api-definition">Design and develop an API definition with API Designer</a>.</p></li><li><p>In the upper right, click <strong>Save</strong>, which closes the editor.</p></li><li><p>Click <strong>Next</strong>.</p></li></ol></div></li></ul></div></li></ol></div><div class="paragraph"><div class="title">Result</div><p>Syndesis displays a list of the operations that the OpenAPI document defines.</p></div><div class="paragraph"><div class="title">Next step</div><p>For each operation, <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#define-integration-operation-flows_api-provider">define a flow that executes that operation</a>.</p></div></div><div class="sect2"><h3 id="define-integration-operation-flows_api-provider">Defining the operation flows for an API provider integration</h3><div class="paragraph"><p>The OpenAPI document that defines your REST API service defines the operations that the service can perform. After you create an API provider integration, you can edit the flow for each operation.</p></div><div class="paragraph"><p>Each operation has exactly one flow. In an operation flow, you can add connections to other applications and services, as well as steps that operate on data between connections.</p></div><div class="paragraph"><p>As you add to operation flows, you might find that you need to update the OpenAPI document that the API provider integration is based on. To do this, click <strong>View/Edit API Definition</strong> in the upper right of a page in which you are editing your API provider integration. This displays your document in the API Designer editor. In your OpenAPI definition, as long as each operation has a unique <code>operationId</code> property, you can save your updates in API Designer and Syndesis can synchronize the API provider integration&#8217;s flow definitions to have your updates.</p></div><div class="ulist"><div class="title">Prerequisites</div><ul><li><p>You created an API provider integration, gave it a name, and saved it.</p></li><li><p>You created a connection to each application or service that you want an operation flow to connect to. For details, see the <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#about-creating-connections_connections">information about creating connections</a>.</p></li><li><p>Syndesis is displaying the list of operations that the API defines.</p></li></ul></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the <strong>Operations</strong> list page, for the operation whose flow you want to define, click <strong>Create flow</strong>.</p></li><li><p>For each connection that you want to add to this flow:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>In the flow visualization, click the plus sign to add a connection at that location.</p></li><li><p>Click the connection that you want to add.</p></li><li><p>Select the action that you want this connection to perform.</p></li><li><p>Configure the action by entering data in the labeled fields.</p></li><li><p>Click <strong>Next</strong>.</p></li></ol></div><div class="paragraph"><p>Add all desired connections to the flow before you continue.</p></div></li><li><p>In this operation flow, to process data between connections:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>In the flow visualization, click the plus sign where you want to add a step.</p></li><li><p>Click the step that you want to add.</p></li><li><p>Configure the step by entering data in the labeled fields.</p></li><li><p>Click <strong>Next</strong>.</p><div class="paragraph"><p>For help, see <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#about-adding-steps_create">Adding steps between connections</a>.</p></div></li></ol></div><div class="paragraph"><p>If you want to add another step that processes data between connections, repeat this subset of instructions.</p></div></li><li><p>Map data to fields in the next connection:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>In the flow visualization, check for data type mismatch <span class="image"><img src="images/integrating-applications/DataTypeMismatchWarning.png" alt="data mismatch"></span>icons, which indicate that the connection cannot process the incoming data. You need to add a data mapper step here.</p></li><li><p>For each data mismatch icon in the flow visualization:</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>Click the plus sign that is just before that step.</p></li><li><p>Click <strong>Data Mapper</strong>.</p></li><li><p>Define the needed mappings. For help, see <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#mapping-data_ug">Mapping integration data to fields in the next connection</a>.</p></li><li><p>Click <strong>Done</strong> to add the data mapper step to the flow.</p></li></ol></div></li></ol></div></li><li><p>In the flow visualization, on the <strong>Provided API Return Path</strong> step, click <strong>Configure</strong>.</p><div class="paragraph"><p>Every API provider integration finishes each operation flow by sending a response to the REST API caller that triggered execution of the operation flow. The response contains one of the return codes that you configure for the <strong>Provided API Return Path</strong> step that finishes the operations flow. Configure the return path step as follows:</p></div><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Under <strong>Default Response</strong>, in the <strong>Return Code</strong> field, accept the default response that Syndesis displays, or click the down caret and scroll to select the default response that you want. The flow sends this response when execution of the operation flow does not return any of the configured error responses. Typically, the default response return code indicates a successful operation.</p></li><li><p>Under <strong>Error Handling</strong>, indicate whether you want to include the error message in the body of the returned message.</p><div class="paragraph"><p>During development, you typically want to return the error message. In production, however, you might want to hide the error message if it contains sensitive or proprietary information. The error message is a JSON formatted string that contains <code>responseCode</code>, <code>category</code>, <code>message</code>, and <code>error</code> elements, for example:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">   {
      responseCode: 404,
      category:  "ENTITY_NOT_FOUND_ERROR",
      message: "SQL SELECT did not SELECT any records"
      error: SYNDESIS_CONNECTION_ERROR
    }</code></pre></div></div><div class="paragraph"><p>Note that during development, the most reliable way to know that an error happened is to check the <code>HTTP_RESPONSE STATUS</code> header in the response to the caller. You can also check the integration pods log for <code>INFO</code> messages. The integrations <strong>Activity</strong> log shows a successful exchange and errors are not always visible in the <strong>Activity</strong> log.</p></div></li><li><p>Under <strong>Error Response Codes</strong>, Syndesis displays an entry for each error that a connection in the flow might return. For each error, accept the <strong>200 All is good</strong> default return code or click to select another HTTP status return code.</p><div class="paragraph"><p>The return codes that you can select from, are the return codes that the OpenAPI document defines for the operation that this flow executes. If Syndesis does not display a return code that you need, you can edit the OpenAPI document to add it.</p></div><div class="paragraph"><p>To do this, in the upper right, click <strong>View/Edit API Definition</strong>. Edit the OpenAPI document as needed. When you are done, save the OpenAPI document. Syndesis returns to editing the <strong>Provided API Return Path</strong> and reflects any changes that you saved.</p></div></li><li><p>Click Next to complete configuration of the return path.</p></li></ol></div></li><li><p>When this flow has all needed connections and steps and there are no data mismatch icons, or when you no longer want to edit the flow for now, do one of the following:</p><div class="ulist"><ul><li><p><strong>Publish</strong>&#8201;&#8212;&#8201;To start running the integration, in the upper right, click <strong>Publish</strong>. This builds the integration, deploys the REST API service to OpenShift, and makes the integration available to be executed. You can publish the integration each time that you complete the creation of an operation&#8217;s flow or each time that you edit an operation&#8217;s flow.</p></li><li><p><strong>Save</strong>&#8201;&#8212;&#8201;To display the list of operations, in the upper right, click <strong>Save</strong>.</p></li></ul></div></li></ol></div><div class="paragraph"><p>Repeat this procedure to edit another operation&#8217;s flow.</p></div><div class="ulist"><div class="title">Testing API provider integrations</div><ul><li><p>Testing API provider integrations running on one of these platforms:</p><div class="ulist"><ul><li><p>OpenShift Online</p></li><li><p>OpenShift Dedicated</p></li><li><p>OpenShift Container Platform when <strong>API discovery is disabled</strong></p></li></ul></div><div class="paragraph"><p>You can use the <code>curl</code> utility to confirm that the integration is working as expected. In the <code>curl</code> command, specify the external URL that Syndesis displays after it publishes the API provider integration. For examples of doing this, see <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#try-api-provider-quickstart_api-provider">Testing the example API provider quickstart integration</a>.</p></div></li><li><p>Testing API provider integrations running on OpenShift Container Platform when <strong>API discovery is enabled</strong></p><div class="paragraph"><p>Red Hat 3scale publishes your API provider integration. To test the integration, open the 3scale dashboard to obtain the integrations URL.</p></div><div class="paragraph"><p>You can disable discovery for an API provider integration if, for example, you do not want Red Hat 3scale to control access to the integrations API or you want to test the API provider integration in Syndesis. If you disable discovery, Syndesis republishes the integration and provides an external URL for invoking and testing integration execution. To do this, in Syndesis go to the integrations summary page. On this page, click <strong>Disable discovery</strong>. Syndesis republishes the integration and provides the integrations URL. For examples of how to test an integration, see <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#try-api-provider-quickstart_api-provider">Testing the example API provider quickstart integration</a>. After testing, you can re-enable discovery for the API provider integration so that 3scale publishes it.</p></div><div class="paragraph"><p>You can enable or disable discovery for each API provider integration.</p></div></li></ul></div></div><div class="sect2"><h3 id="configure-publish-api-provider-quickstart_api-provider">Importing and publishing the example API provider quickstart integration</h3><div class="paragraph"><p>Syndesis provides an API provider quickstart integration that you can import into your Syndesis environment. This quickstart includes an OpenAPI document for a task management API. After importing the quickstart integration, you can examine the flows and then publish the integration. After you complete the procedure described below, the <strong>TaskAPI</strong> integration is running and ready to be executed.</p></div><div class="paragraph"><p>The API provider quickstart helps you quickly learn how to configure, publish, and test an API provider integration. But it is not a real-world example of how useful an API provider integration can be. For a real-world example, suppose that you already used Syndesis to publish several simple integrations. You could define an OpenAPI document for triggering execution of those integrations. To do this, you would edit the flow for each OpenAPI operation to be almost the same as the simple integrations that you already published.</p></div><div class="ulist"><div class="title">Prerequisites</div><ul><li><p>Syndesis is open in a browser.</p></li></ul></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>Import the <strong>TaskAPI</strong> quickstart integration:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Go to <a href="https://github.com/syndesisio/syndesis-quickstarts/tree/1.10/api-provider" class="bare">https://github.com/syndesisio/syndesis-quickstarts/tree/1.10/api-provider</a> and download <code>TaskAPI-export.zip</code>.</p></li><li><p>In Syndesis, in the left navigation panel, click <strong>Integrations</strong>.</p></li><li><p>In the upper right, click <strong>Import</strong>.</p></li><li><p>Drag the <code>TaskAPI-export.zip</code> file that you downloaded to the <strong>Import</strong> page. Syndesis indicates that it has successfully imported the file.</p></li><li><p>In the left navigation panel, click <strong>Integrations</strong> to see an entry for the <strong>TaskAPI</strong> integration that you just imported. Although the entry indicates that configuration is required, this integration is ready to publish.</p></li></ol></div></li><li><p>In the <strong>TaskAPI</strong> entry, click <span class="image"><img src="images/integrating-applications/ThreeVerticalDotsKebab.png" alt="Three Vertical Dots"></span>and then click <strong>Edit</strong> to display a list of the operations that this API provides.</p></li><li><p>To examine the flows for each operation:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Click its <strong>Edit flow</strong> button to display the visualization for that flow.</p><div class="paragraph"><p>Each flow already has a database connection, one or more data mapper steps, and a <strong>Provided API Return Path</strong> step that finishes the flow.</p></div></li><li><p>For the <strong>Invoke SQL</strong> step, click <strong>Configure</strong> to see the SQL statement that the connection executes. Then click <strong>Cancel</strong> to return to that operation&#8217;s visualization flow.</p></li><li><p>For a data mapper step, click <strong>Configure</strong> to see the mappings. Then click <strong>Cancel</strong> to return to the visualization.</p></li><li><p>For the <strong>Provided API Return Path</strong> step, which is the last step in every operation&#8217;s flow, click <strong>Configure</strong> to see the HTTP return codes that the operation might send to the caller. Click <strong>Cancel</strong> to return to the visualization.</p></li><li><p>After examining one operation&#8217;s flow, click the <strong>Integrations</strong>&gt; <strong>TaskAPI</strong>&gt; <strong>Operation</strong> drop down menu and then select another operation.</p></li><li><p>Repeat this subset of steps to examine each flow.</p></li></ol></div></li><li><p>After examining the flows, click <strong>Publish</strong>, edit the integration name if you want to, and then click <strong>Save and publish</strong>.</p><div class="paragraph"><p>Syndesis displays the summary page for this integration and shows publication progress as it assembles, builds, deploys, and starts the integration.</p></div></li><li><p>When the <strong>TaskAPI</strong> integration summary page displays <strong>Running</strong>, Syndesis displays the external URL for the Task API service. It looks something like this:</p><div class="paragraph"><p><code>https://i-task-api-proj319352.6a63.fuse-ignite.openshiftapps.com/api/</code></p></div><div class="paragraph"><p>This is where Syndesis makes the Task API service available. REST API calls specify URLs that start with this base URL.</p></div><div class="paragraph"><p>If you are using Syndesis on OpenShift Container Platform, if the external URL is not on the integrations summary page, then an administrator has enabled Red Hat 3scale discovery. This means that Red Hat 3scale controls access to the integration&#8217;s API and also publishes your API provider integration. To test the integration, open the 3scale dashboard to obtain the integrations URL.</p></div><div class="paragraph"><p>If you do not want Red Hat 3scale to control access to the integrations API, you can disable discovery. You do this in Syndesis by viewing the integrations summary page. On this page, click <strong>Disable discovery</strong>. Syndesis republishes the integration and provides an external URL for invoking integration execution.</p></div><div class="paragraph"><p>You can enable or disable discovery for each API provider integration.</p></div></li></ol></div></div><div class="sect2"><h3 id="try-api-provider-quickstart_api-provider">Testing the example API provider quickstart integration</h3><div class="paragraph"><p>When the Syndesis <strong>TaskAPI</strong> quickstart integration is running, you can invoke <code>curl</code> utility commands that send HTTP requests to the Task API service. How you specify the HTTP request determines the flow that the call triggers.</p></div><div class="ulist"><div class="title">Prerequisites</div><ul><li><p>Syndesis indicates that the <strong>TaskAPI</strong> integration is <strong>Running</strong>.</p></li><li><p>If your Syndesis environment is running on OCP, Syndesis is not configured to expose APIs to 3scale or you disabled discovery for the <strong>TaskAPI</strong> integration.</p></li></ul></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In Syndesis, in the left navigation panel, click <strong>Integrations</strong>.</p></li><li><p>In the <strong>TaskAPI</strong> integration entry, click <strong>View</strong> to display the integration&#8217;s summary.</p></li><li><p>Copy the integration&#8217;s external URL.</p></li><li><p>In a terminal, invoke a command such as the following to assign the integration&#8217;s external URL to the <code>externalURL</code> environment variable. Be sure to replace the URL in this sample command with the URL that you copied.</p><div class="listingblock"><div class="content"><pre>export externalURL="https://i-task-api-proj319352.6a63.fuse-ignite.openshiftapps.com/api"</pre></div></div></li><li><p>Invoke a <code>curl</code> command that triggers execution of the flow for the <strong>Create new task</strong> operation:</p><div class="listingblock"><div class="content"><pre>curl -k --header "Content-Type: application/json" --request POST --data '{ "task":"my new task!"}' $externalURL/todo</pre></div></div><div class="ulist"><ul><li><p><code>-k</code> allows <code>curl</code> to proceed and operate even for server connections that are otherwise considered insecure.</p></li><li><p><code>--header</code> indicates that the command is sending JSON format data.</p></li><li><p><code>--request</code> specifies the HTTP <code>POST</code> command, which stores data.</p></li><li><p><code>--data</code> specifies the JSON format content to be stored. In this example the content is <code>{ "task":"my new task!"}</code>.</p></li><li><p><code>$externalURL/todo</code> is the URL to invoke.</p><div class="paragraph"><p>This command sends an HTTP <code>POST</code> request to the Task API service, which triggers execution of the <strong>Create new task</strong> operation&#8217;s flow. Flow execution adds a new task to the sample database and returns a message such as the following to indicate what it did:</p></div></li></ul></div><div class="listingblock"><div class="content"><pre>{"completed":false,"id":1,"task":"my new task!"}</pre></div></div></li><li><p>Invoke a <code>curl</code> command that triggers execution of the flow for the <strong>Fetch task</strong> by ID operation:</p><div class="listingblock"><div class="content"><pre>curl -k $externalURL/todo/1</pre></div></div><div class="paragraph"><p>To obtain a task, the <code>curl</code> command needs to specify only the URL. The HTTP <code>GET</code> command is the default request. The last part of the URL specifies the ID of the task to get.</p></div></li><li><p>Invoke a <code>curl</code> command that triggers execution of the flow for the <strong>Delete task</strong> for ID operation:</p><div class="listingblock"><div class="content"><pre>curl -k -X DELETE $externalURL/todo/1</pre></div></div><div class="paragraph"><p>This command invokes the HTTP <code>DELETE</code> command with the same URL as the command that obtained a task by its ID.</p></div></li></ol></div></div></div></div><div class="sect1"><h2 id="triggering-integrations-with-http-requests_ug">Creating an integration that is triggered by an HTTP request (Webhook)</h2><div class="sectionbody"><div class="paragraph"><p>You can trigger execution of a simple integration by sending an HTTP <code>GET</code> or <code>POST</code> request to an HTTP endpoint that Syndesis exposes. The following topics provide details:</p></div><div class="ulist"><ul><li><p><a href="#how-to-use-webhook_webhook">General procedure for using the Syndesis webhook</a></p></li><li><p><a href="#start-with-webhook-connection_webhook">Creating an integration that an HTTP request can trigger</a></p></li><li><p><a href="#how-requests-are-handled_webhook">How Syndesis handles HTTP requests</a></p></li><li><p><a href="#guidelines-for-service-sending-requests_webhook">Guidelines for an HTTP client that invokes a Syndesis Webhook</a></p></li><li><p><a href="#about-json-schema-for-http-requests_webhook">About the JSON schema for specifying request parameters</a></p></li><li><p><a href="#how-to-specify-request_webhook">How to specify HTTP requests</a></p></li></ul></div><div class="sect2"><h3 id="how-to-use-webhook_webhook">General procedure for using the Syndesis webhook</h3><div class="paragraph"><p>To trigger execution of an integration with an HTTP <code>GET</code> or <code>POST</code> request, you must do the following:</p></div><div class="olist arabic"><ol class="arabic"><li><p>Decide whether you want to send a <code>GET</code> or <code>POST</code> request to Syndesis.</p></li><li><p>Plan your integration to handle this request.</p></li><li><p>Create the connection that finishes the integration.</p><div class="paragraph"><p>Syndesis provides a Webhook connection that you use as the start connection.</p></div></li><li><p>Create any other connections that you want to add to the integration.</p></li><li><p>Create the integration:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Add the Webhook connection as the start connection.</p></li><li><p>Add the finish connection and then any other connections that are required in the integration. The finish connection and any middle connections handle the HTTP request that triggers execution of the integration. It is up to you to choose and specify the most appropriate HTTP request for accomplishing your goals. Keep the following in mind:</p><div class="ulist"><ul><li><p>Add a connection to the application that contains the data that you want to obtain or that contains the data that you want to update.</p></li><li><p>A <code>GET</code> request is limited to specification of key/value parameters.</p></li><li><p>A <code>POST</code> request can provide an arbitrary body, such as an XML or JSON instance.</p></li><li><p>Syndesis returns only an HTTP status header and does not return any data. Consequently, you can define an integration that is triggered by a <code>GET</code> request and that updates data rather than obtaining data. Likewise, you can define an integration that is triggered by a <code>POST</code> request and that obtains data rather than updating data.</p></li></ul></div></li><li><p>Add a data mapper step after the Webhook connection.</p><div class="paragraph"><p>For a <code>GET</code> request, map the parameter fields in the HTTP request to the data fields in the next connection.</p></div><div class="paragraph"><p>For a <code>POST</code> request, you might have specified the output data shape in the request by passing a JSON instance, JSON schema, XML instance, or XML schema. If you did not, then when you add a Webhook connection as the start connection of an integration, Syndesis prompts you to specify the output data type. If you do not, then the default Webhook connection output data type is in JSON format.</p></div></li><li><p>Add any other steps that the integration needs.</p></li></ol></div></li><li><p>Publish the integration and wait for it to be <strong>Running</strong>.</p></li><li><p>Go to the integration summary page and copy the external URL that Syndesis provides.</p></li><li><p>Modify this external URL to construct your <code>GET</code> or <code>POST</code> request.</p></li><li><p>Implement the application that sends the HTTP <code>GET</code> or <code>POST</code> request to Syndesis.</p></li></ol></div></div><div class="sect2"><h3 id="start-with-webhook-connection_webhook">Creating an integration that an HTTP request can trigger</h3><div class="paragraph"><p>To trigger execution of an integration with an HTTP <code>GET</code> or <code>POST</code> request, add a Webhook connection as the integration&#8217;s start connection.</p></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the Syndesis panel on the left, click <strong>Integrations</strong>.</p></li><li><p>Click <strong>Create Integration</strong>.</p></li><li><p>On the <strong>Choose a connection</strong> page, click the Webhook connection.</p></li><li><p>On the <strong>Choose an action</strong> page, select the <strong>Incoming Webhook</strong> action.</p><div class="paragraph"><p>In the <strong>Webhook Configuration</strong> page, Syndesis displays the webhook token that Syndesis generates for this integration.</p></div><div class="paragraph"><p>When you construct the HTTP request, this token is the last part of the URL. After you publish this integration and it is running, Syndesis displays the Syndesis external URL, which has this token at the end.</p></div><div class="paragraph"><p>The <strong>Webhook Configuration</strong> page also includes <strong>Default Response</strong> and <strong>Error Handling</strong> sections. The webhook step sends a response to the HTTP client that invoked it. The response contains one of the return codes and, by default, the error message in the body of the returned message.</p></div></li><li><p>Under <strong>Default Response</strong>, in the <strong>Return Code</strong> field, accept the default response that Syndesis displays, or use the drop-down list to select the default response that you want. The flow sends this response when execution of the operation flow does not return any of the configured error responses. Typically, the default response return code indicates a successful operation.</p></li><li><p>Under <strong>Error Handling</strong>, indicate whether you want to include the error message in the body of the returned message.</p><div class="paragraph"><p>During development, you typically want to return the error message. In production, however, you might want to hide the error message if it contains sensitive or proprietary information. The error message is a JSON-formatted string that contains <code>responseCode</code>, <code>category</code>, <code>message</code>, and <code>error</code> elements, for example:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">   {
      responseCode: 404,
      category:  "ENTITY_NOT_FOUND_ERROR",
      message: "SQL SELECT did not SELECT any records"
      error: SYNDESIS_CONNECTION_ERROR
    }</code></pre></div></div><div class="paragraph"><p>Note that during development, the most reliable way to know that an error happened is to check the <code>HTTP_RESPONSE STATUS</code> header in the response to the caller. You can also check the integration pods log for <code>INFO</code> messages. The integrations <strong>Activity</strong> log shows a successful exchange and errors are not always visible in the <strong>Activity</strong> log.</p></div></li><li><p>For each error that the webhook step might return, accept the default return code or use the drop-down list to select another HTTP status return code.</p></li><li><p>Click <strong>Next</strong>.</p></li><li><p>In the <strong>Specify Output Data Type</strong> page:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Click in the <strong>Select Type</strong> field, and select <strong>JSON schema</strong>.</p></li><li><p>In the <strong>Definition</strong> field, paste the JSON schema that defines the data types of the parameters in the HTTP request. See <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#about-json-schema-for-http-requests_webhook">About the JSON schema for specifying request parameters</a>.</p></li><li><p>In the <strong>Data Type Name</strong> field, specify a name for this data type. Although this is optional, if you specify a name, it appears in the data mapper <strong>Sources</strong> list, which can make it easier to correctly map fields.</p></li><li><p>Optionally, in the <strong>Data Type Description</strong> field, provide some information that helps you distinguish this data type.</p></li><li><p>Click <strong>Next</strong>.</p></li></ol></div></li><li><p>Add the finish connection to the integration.</p></li><li><p>Add any other needed connections.</p></li><li><p>Add any other needed steps.</p></li><li><p>Immediately after the start connection, add a data mapper step.</p></li><li><p>Click <strong>Publish</strong>, give the integration a name and optionally, a description, and click <strong>Save and publish</strong>.</p></li></ol></div></div><div class="sect2"><h3 id="how-requests-are-handled_webhook">How Syndesis handles HTTP requests</h3><div class="paragraph"><p>You can specify an HTTP <code>GET</code> or <code>POST</code> request to trigger execution of a simple integration. Although a <code>GET</code> request usually obtains data and a <code>POST</code> request usually updates data, you can use either request to trigger an integration that does either operation. Any parameters in the request are available for mapping to data fields in the next connection that is in the integration. For details, see <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#about-json-schema-for-http-requests_webhook">About the JSON schema for specifying request parameters</a>.</p></div><div class="paragraph"><p>A Webhook connection only passes the data it receives to the next connection in the integration. When Syndesis receives an HTTP request, it:</p></div><div class="ulist"><ul><li><p>Returns an HTTP status header to the requester. When a request successfully triggers execution of an integration, the Syndesis return code is <code>201</code>. When a request fails to trigger execution of an integration, the Syndesis return code is <code>5xx</code>.</p></li><li><p>Does not return any other data to the requester. In other words, there is no data in the HTTP body of the response that contains the status header.</p></li><li><p>Passes the data in the request to the next connection in the integration.</p></li></ul></div><div class="paragraph"><p>This means that you can define a simple integration that is triggered by a <code>GET</code> request and that updates data rather than obtaining data. Likewise, you can define a simple integration that is triggered by a <code>POST</code> request and that obtains data rather than updating data.</p></div><div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content"><div class="paragraph"><p>In the integration&#8217;s <strong>Activity</strong> tab, the status of a webhook step is <code>Success</code> every time. This <code>Success</code> status indicates the status of the communication between the Syndesis} Webhook and the HTTP client that invokes it. This <code>Success</code> status is not an indication that the integration passed successfully nor that any steps are without error. Errors generated by HTTP requests are not visible in the integrations <strong>Activity</strong> log.</p></div><div class="paragraph"><p>When you configure a webhook, the <strong>Include error message in the return body</strong> option is checked by default. When this option is checked, to verify whether the errors generated by HTTP requests are included in the webhook response, send a test request that will generate an error and then check the response header. You can also check the integration pods log for <code>INFO</code> messages. Use the following command to view the integrations pod log, where <code>example-integration-pod</code> is the name of the pod.</p></div><div class="listingblock"><div class="content"><pre>oc logs -f pod/example-integration-pod</pre></div></div></td></tr></table></div></div><div class="sect2"><h3 id="guidelines-for-service-sending-requests_webhook">Guidelines for an HTTP client that invokes a Syndesis Webhook</h3><div class="paragraph"><p>When you implement a client that sends an HTTP request to Syndesis, your implementation should:</p></div><div class="ulist"><ul><li><p>Add to the Syndesis-provided external URL to construct a URL that makes a <code>GET</code> or <code>POST</code> request.</p></li><li><p>In the URL request, specify HTTP header and query parameter values whose data types adhere to the <code>io:syndesis:webhook</code> JSON schema. See <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#about-json-schema-for-http-requests_webhook">About the JSON schema for specifying request parameters</a>. When header and query parameters adhere to this data type specification, then you can map parameter fields to fields that the next connection in the integration can process.</p></li><li><p>If the request succeeds, handle a returned success code of <code>201</code>.</p></li><li><p>If the request fails, handle an HTTP <code>5xx</code> error code.</p></li><li><p>Not expect any other response from Syndesis. In other words, sending the request does not directly return data to the requesting client other than the return code.</p></li></ul></div></div><div class="sect2"><h3 id="about-json-schema-for-http-requests_webhook">About the JSON schema for specifying request parameters</h3><div class="paragraph"><p>In an integration, you typically map header and query parameters in the HTTP request to data fields that the next connection in the integration can process. To make this possible, when you add the Webhook connection to the integration, specify the output data type in a JSON schema that has the following structure:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">{
  "$schema": "http://json-schema.org/schema#",
   "id": "io:syndesis:webhook",
   "type": "object",
   "properties": {
      "parameters": {
         "type": "object",
         "properties": { <b class="conum">(1)</b>
         }
      },
      "body": {
         "type": "object",
         "properties": { <b class="conum">(2)</b>
         }
      }
   }
}</code></pre></div></div><div class="paragraph"><p>To add the data structures that you need, in the JSON instance for your HTTP request:</p></div><div class="colist arabic"><ol><li><p>Specify query parameters in the <code>properties</code> section under the <code>parameters</code> object.</p></li><li><p>Specify the HTTP body schema in the <code>properties</code> section under the <code>body</code> object.</p></li></ol></div><div class="paragraph"><p>While all data that an HTTP client sends is available in the integration, when a Webhook connection&#8217;s data shape conforms to this JSON schema, then query parameters and body content are available for mapping.</p></div><div class="paragraph"><p>For examples, see <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#how-to-specify-request_webhook">How to specify HTTP requests</a>.</p></div></div><div class="sect2"><h3 id="how-to-specify-request_webhook">How to specify HTTP requests</h3><div class="paragraph"><p>The following examples show how to specify HTTP requests for the Syndesis Webhook.</p></div><div class="paragraph"><div class="title">Webhook example of POST request with only HTTP body</div><p>Consider an integration that starts with a Webhook connection and then creates a row in the <strong>Todo</strong> table of the Syndesis-provided database:</p></div><div class="paragraph"><p><span class="image"><img src="images/integrating-applications/WebhookToDB.png" alt="Webhook-Data Mapper-DB integration"></span></p></div><div class="paragraph"><p>During creation of this integration, when you add the Webhook start connection, you specify its output data type with a JSON instance that has this content: <code>{"todo":"text"}</code>:</p></div><div class="paragraph"><p><span class="image"><img src="images/integrating-applications/SpecifyDataShape.png" alt="Specify Data Shape Image"></span></p></div><div class="paragraph"><p>When you add the <strong>PostgresDB</strong> connection as the finish connection, you select the <strong>Invoke SQL</strong> action and specify this SQL statement:</p></div><div class="paragraph"><p><code>INSERT INTO TODO (TASK) VALUES (:#TASK)</code></p></div><div class="paragraph"><p>After you add the database connection, you add a mapping step:</p></div><div class="paragraph"><p><span class="image"><img src="images/integrating-applications/TODOtoTASK.png" alt="Map Todo to Task"></span></p></div><div class="paragraph"><p>You save and publish the integration. When it is running, you can copy the external URL that Syndesis provides:</p></div><div class="paragraph"><p><span class="image"><img src="images/integrating-applications/ExternalURL.png" alt="External URL"></span></p></div><div class="paragraph"><p>To understand the parts of the external URL, consider this sample URL:</p></div><div class="paragraph"><p><code>https://i-webhook-to-db-myproject.192.168.64.4.nip.io/webhook/bvGvQdpq308BcHIQQYeysFOK4plFISmghNHkRyOOk3YppitvOd</code></p></div><table class="tableblock frame-all grid-all stretch"><colgroup><col style="width:25%"><col style="width:75%"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Value</th><th class="tableblock halign-left valign-top">Description</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>i-</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Syndesis always inserts this value at the beginning of the URL.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>webhook-to-db</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">The name of the integration.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>myproject</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">The OpenShift namespace that contains the pod that is running the integration.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>192.168.64.4.nip.io</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">The DNS domain that is configured for OpenShift. This indicates the Syndesis environment that is providing the webhook.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>webhook</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Appears in each Webhook connection URL.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>bvGvQdpq308BcHIQQYeysFOK4plFISmghNHkRyOOk3YppitvOd</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Webhook connection token that Syndesis provides when you add a Webhook connection to an integration. The token is a random string that provides security in that it makes the URL hard to discern, which prevents anyone else from sending a request.</p><p class="tableblock">In a request, you can specify the token that Syndesis provides or you can define your own. If you define your own, ensure that it is hard to guess.</p></td></tr></tbody></table><div class="paragraph"><p>As you can see in the external URL, Syndesis constructs the host name from the name of the integration, the name of the OpenShift namespace, and the OpenShift DNS domain. Syndesis removes illegal characters and converts spaces to hyphens. In the sample external URL, this is the host name:</p></div><div class="paragraph"><p><code>https://i-webhook-to-db-myproject.192.168.64.4.nip.io</code></p></div><div class="paragraph"><p>To use <code>curl</code> to invoke the webhook, you would specify the command as follows:</p></div><div class="paragraph"><p><code>curl -H 'Content-Type: application/json' -d '{"todo":"from webhook"}' https://i-webhook-to-db-myproject.192.168.64.4.nip.io/webhook/bvGvQdpq308BcHIQQYeysFOK4plFISmghNHkRyOOk3YppitvOd</code></p></div><div class="ulist"><ul><li><p>The <code>-H</code> option specifies the HTTP <code>Content-Type</code> header.</p></li><li><p>The <code>-d</code> option sets the HTTP method to <code>POST</code> by default.</p></li></ul></div><div class="paragraph"><p>Execution of this command triggers the integration. The database finish connection inserts a new task into the tasks table. To see this, display the <strong>Todo</strong> app at, for example, <code>https://todo-myproject.192.168.64.4.nip.io</code>, Click <strong>Update</strong> and you should see <code>from webhook</code> as a new task.</p></div><div class="paragraph"><div class="title">Webhook example of POST request with query parameters</div><p>For this example, consider the same integration as in the previous example:</p></div><div class="paragraph"><p><span class="image"><img src="images/integrating-applications/WebhookToDB.png" alt="Webhook-Data Mapper-DB integration"></span></p></div><div class="paragraph"><p>But in this example, you define the Webhook connection output data type by specifying a JSON schema with this content:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">{
  "type": "object",
  "definitions": {},
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "io:syndesis:webhook",
  "properties": {
    "parameters": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "status": {
          "type": "string"
        }
      }
    },
    "body": {
      "type": "object",
      "properties": {
        "company": {
          "type": "string"
        },
        "email": {
          "type": "string"
        },
        "phone": {
          "type": "string"
        }
      }
    }
  }
}</code></pre></div></div><div class="paragraph"><p>In this JSON schema:</p></div><div class="ulist"><ul><li><p>The <code>id</code> must be set to <code>io.syndesis.webhook</code>.</p></li><li><p>The <code>parameters</code> section must specify the HTTP query parameters.</p></li><li><p>The <code>body</code> section must specify the body content and it can be as complex as you need it to be. For example, it can define nested properties as well as arrays.</p></li></ul></div><div class="paragraph"><p>This provides the information that the Webhook connector needs to prepare the content for the next step in the integration.</p></div><div class="paragraph"><p>To use <code>curl</code> to send an HTTP request, invoke a command such as the following:</p></div><div class="paragraph"><p><code>curl -H 'Content-Type: application/json' -d '{"company":"Gadgets","email":"<a href="mailto:sales@gadgets.com">sales@gadgets.com</a>","phone":"+1-202-555-0152"}'https://i-webhook-params-to-db-myproject.192.168.42.235.nip.io/webhook/ZYWrhaW7dVk097vNsLX3YJ1GyxUFMFRteLpw0z4O69MW7d2Kjg?source=web&amp;status=new</code></p></div><div class="paragraph"><p>When the Webhook connection receives this request it creates a JSON instance that looks like this:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">{
  "parameters": {
    "source": "web",
    "status": "new"
  },
  "body": {
    "company": "Gadgets",
    "email": "sales@gadgets.com",
    "phone": "+1-202-555-0152"
  }
}</code></pre></div></div><div class="paragraph"><p>It is this internal JSON instance that enables the following mapping:</p></div><div class="paragraph"><p><span class="image"><img src="images/integrating-applications/TODOtoAddLead.png" alt="Map to Add Lead"></span></p></div><div class="paragraph"><div class="title">Webhook examples with GET</div><p>To trigger an integration with a <code>GET</code> request that does not provide input data, specify the Webhook connection output data shape as a JSON instance with the definition <code>'{}'</code>. You can then invoke the following <code>curl</code> command, which does not specify query parameters:</p></div><div class="paragraph"><p><code>curl 'https://i-webhook-params-to-db-myproject.192.168.42.235.nip.io/webhook/ZYWrhaW7dVk097vNsLX3YJ1GyxUFMFRteLpw0z4O69MW7d2Kjg'</code></p></div><div class="paragraph"><p>You can change the previous <code>POST</code> example to send a <code>GET</code> request with query parameters but no body. You would specify the Webhook connection output data shape as a JSON schema with the definition as shown below.</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">{
  "type": "object",
  "definitions": {},
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "io:syndesis:webhook",
  "properties": {
    "parameters": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "status": {
          "type": "string"
        }
      }
    }
  }
}</code></pre></div></div><div class="paragraph"><p>Here is the <code>curl</code> command that sends the <code>GET</code> request:</p></div><div class="paragraph"><p><code>curl 'https://i-webhook-params-to-db-myproject.192.168.42.235.nip.io/webhook/ZYWrhaW7dVk097vNsLX3YJ1GyxUFMFRteLpw0z4O69MW7d2Kjg?source=web&amp;status=new'`</code></p></div></div></div></div><div class="sect1"><h2 id="mapping-data_ug">Mapping integration data to fields for the next connection</h2><div class="sectionbody"><div class="paragraph"><p>In most flows, you need to map data fields that have already been obtained or processed to data fields that the next connection in the flow can process. Syndesis provides a data mapper to help you do this. In a flow, at each point where you need to map data fields, add a data mapper step.</p></div><div class="admonitionblock important"><table><tr><td class="icon"><div class="title">Important</div></td><td class="content">The data mapper displays the largest possible set of source fields that can be provided by the previous integration step. However, not all connections provide data in each displayed source field. For example, a change to a third-party application might discontinue providing data in a particular field. As you create an integration, if you notice that data mapping is not behaving as you expect, ensure that the source field that you want to map contains the data that you expect.</td></tr></table></div><div class="paragraph"><p>Details for mapping data fields are in the following topics:</p></div><div class="ulist"><ul><li><p><a href="#view-mappings-in-a-step_map">Viewing the mappings in a step</a></p></li><li><p><a href="#identify-where-data-mapping-is-needed_map">Identifying where data mapping is needed</a></p></li><li><p><a href="#find-the-field-you-want-to-map_map">Finding the data field that you want to map</a></p></li><li><p><a href="#map-one-source-field-to-one-target-field_map">Mapping one source field to one target field</a></p></li><li><p><a href="#example-missing-unwanted-data_map">Example of missing or unwanted data when combining or separating fields</a></p></li><li><p><a href="#combine-multiple-source-fields-into-one-target-field_map">Combining multiple source fields into one target field</a></p></li><li><p><a href="#separate-one-source-field-into-multiple-target-fields_map">Separating one source field into multiple target fields</a></p></li><li><p><a href="#about-data-types-and-collections_map">About data types and collections in the data mapper</a></p></li><li><p><a href="#using-data-mapper-to-process-collections_map">Using the data mapper to process collections</a></p></li><li><p><a href="#mapping-between-collections-and-non-collections_map">About mapping between collections and non-collections</a></p></li><li><p><a href="#transform-target-data_map">Transforming source or target data</a></p></li><li><p><a href="#about-transformations-on-multiple-source-values_map">About transformations on multiple source values before mapping to one target field</a></p></li><li><p><a href="#applying-conditions-to-mappings_map">Applying conditions to mappings</a></p></li><li><p><a href="#available-transformations_map">Descriptions of available transformations</a></p></li><li><p><a href="#troubleshooting-data-mapping_map">Troubleshooting data mapping</a></p></li></ul></div><div class="sect2"><h3 id="view-mappings-in-a-step_map">Viewing the mappings in a step</h3><div class="paragraph"><p>While you are adding or editing a data mapper step, you can view the mappings already defined in this step. This option lets you check whether the correct mappings are in place.</p></div><div class="ulist"><div class="title">Prerequisites</div><ul><li><p>You are creating or editing an integration.</p></li><li><p>You are adding a data mapper step. That is, the data mapper is visible.</p></li></ul></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>To see a table view of the mappings, click <span class="image"><img src="images/tutorials/grid.png" alt="the Mapping Table icon"></span>.</p></li><li><p>To dismiss the table view of mappings and redisplay the source and target fields, click <span class="image"><img src="images/integrating-applications/column-mapper-icon.png" alt="the Column Mapper icon"></span>.</p></li></ol></div></div><div class="sect2"><h3 id="identify-where-data-mapping-is-needed_map">Identifying where data mapping is needed</h3><div class="paragraph"><p>Syndesis displays warning icons to indicate where a flow requires data mapping.</p></div><div class="ulist"><div class="title">Prerequisites</div><ul><li><p>You are creating or editing a flow.</p></li><li><p>The flow contains all connections that it requires.</p></li></ul></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the flow visualization, look for any <span class="image"><img src="images/tutorials/WarningIcon.png" alt="Warning"></span>icons.</p></li><li><p>Click the icon to see the <strong>Data Type Mismatch</strong> notification.</p></li><li><p>In the message, click <strong>Add a data mapping step</strong>, which displays the data mapper.</p></li></ol></div></div><div class="sect2"><h3 id="find-the-field-you-want-to-map_map">Finding the data field that you want to map</h3><div class="paragraph"><p>In a flow with relatively few steps, mapping data fields is easy and intuitive. In more complex flows or in flows that handle large sets of data fields, mapping from source to target is easier when you have some background about how to use the data mapper.</p></div><div class="paragraph"><p>The data mapper displays two columns of data fields:</p></div><div class="ulist"><ul><li><p><strong>Source</strong> is a list of the data fields that are obtained or processed in all previous steps in the flow.</p></li><li><p><strong>Target</strong> is a list of the data fields that the next connection in the flow expects and can process.</p></li></ul></div><div class="paragraph"><p>To quickly find the data field that you want to map, you can do any of the following:</p></div><div class="ulist"><ul><li><p>Search for it.</p><div class="paragraph"><p>The <strong>Sources</strong> panel and the <strong>Target</strong> panel each have a search field at the top. If the search field is not visible, click <span class="image"><img src="images/tutorials/magnifying-glass.png" alt="Magnifying Glass"></span>at the top right of the <strong>Sources</strong> or <strong>Target</strong> panel.</p></div><div class="paragraph"><p>Type the names of the fields that you want to map. In the <strong>Sources</strong> search field, type the name of the source field. In the <strong>Target</strong> search field, type the name of the field that you want to map to.</p></div></li><li><p>Use the <span class="image"><img src="images/integrating-applications/mapped-fields-icon.png" alt="Show/hide mapped fields icon"></span>and <span class="image"><img src="images/integrating-applications/unmapped-fields-icon.png" alt="Show/hide unmapped fields icon"></span>options to filter the visible fields.</p></li><li><p>Expand and collapse folders to limit the visible fields.</p><div class="paragraph"><p>To view the data fields available in a particular step, expand the folder for that step.</p></div><div class="paragraph"><p>As you add steps to a flow, Syndesis numbers and renumbers them to indicate the order in which Syndesis processes the steps. When you are adding a data mapper step, the step numbers appear in the folder labels in the <strong>Sources</strong> panel and in the <strong>Target</strong> panel.</p></div></li><li><p>If you want to view the data type for each field, click <span class="image"><img src="images/integrating-applications/show-types-icon.png" alt="Show/hide types icon"></span>to display (or hide) the data types in each fields label. The folder label also displays the name of the data type that is output by that step. The folder label also displays the name of the data type that is output by that step. Connections to applications such as Twitter, Salesforce, and SQL define their own data types. For connecting to applications such as Amazon S3, AMQ, AMQP, Dropbox, and FTP/SFTP, you define the connection&#8217;s input and/or output type when you add the connection to a flow and select the action that the connection performs. When you specify the data type, you also give the type a name. The type name you specify appears as the name of a folder in the data mapper. If you specified a description when you declared the data type, then the type description appears when you hover over the step folder in the mapper.</p></li></ul></div></div><div class="sect2"><h3 id="map-one-source-field-to-one-target-field_map">Mapping one source field to one target field</h3><div class="paragraph"><p>The default mapping behavior maps one source field to one target field. For example, map the <code>Name</code> field to the <code>CustomerName</code> field.</p></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the <strong>Sources</strong> panel:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>If necessary, expand a step to see the data fields that it provides.</p><div class="paragraph"><p>When there are many source fields, you can search for the field of interest by clicking the <span class="image"><img src="images/tutorials/magnifying-glass.png" alt="Magnifying Glass"></span>and then typing the name of the data field in the search field.</p></div></li></ol></div></li></ol></div><div class="olist arabic"><div class="title">.Click the data field that you want to map from and then click <span class="image"><img src="images/integrating-applications/create-mapping-icon.png" alt="the Create New Mapping icon"></span>. The <strong>Mapping Details</strong> panel opens.</div><ol class="arabic"><li><p>In the <strong>Target</strong> panel, find the data field that you want to map to and then click <span class="image"><img src="images/integrating-applications/connect-mapping-icon.png" alt="the Connect Mapping icon"></span>.</p><div class="paragraph"><p>The data mapper displays a line that connects the two fields that you just selected.</p></div></li><li><p>Optionally, preview the data mapping result. This option is useful when you add a transformation to the mapping or when the mapping requires a type conversion.</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>In the upper right of the data mapper, click <span class="image"><img src="images/integrating-applications/preview-mapping-icon.png" alt="the Show/Hide Preview Mapping icon"></span>to display a text input field on the source field and a read-only result field on the target field.</p></li><li><p>In the source field&#8217;s data input field, type an example input value. The mapping result appears in the read-only field on the target field.</p></li><li><p>Optionally, to see the result of a transformation, add a transformation in the <strong>Mapping Details</strong> panel.</p></li><li><p>To hide the preview fields click <span class="image"><img src="images/integrating-applications/preview-mapping-icon.png" alt="the Show/Hide Preview Mapping icon"></span>again.</p></li></ol></div></li><li><p>Optionally, to confirm that the mapping is defined, click <span class="image"><img src="images/tutorials/grid.png" alt="the Mapping Table icon"></span>to display the defined mappings.</p><div class="paragraph"><p>You can also preview data mapping results in this view. .. If preview fields are not visible, click <span class="image"><img src="images/integrating-applications/preview-mapping-icon.png" alt="the Show/Hide Preview Mapping icon"></span>. .. Enter data as described in the previous step.</p></div><div class="paragraph"><p>+ In the table of defined mappings, preview fields appear for only the selected mapping.</p></div><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>To see preview fields for another mapping, select it.</p></li><li><p>Click <span class="image"><img src="images/integrating-applications/column-mapper-icon.png" alt="the Column Mapper icon"></span>again to display the data field panels.</p></li></ol></div></li><li><p>In the upper right, click <strong>Done</strong> to add the data mapper step to the integration.</p></li></ol></div><div class="paragraph"><div class="title">Troubleshooting tip</div><p>The data mapper displays the largest possible set of source fields that can be provided by the previous integration step. However, not all connections provide data in each displayed source field. For example, a change to a third-party application might discontinue providing data in a particular field. As you create an integration, if you notice that data mapping is not behaving as you expect, ensure that the source field that you want to map contains the data that you expect.</p></div></div><div class="sect2"><h3 id="example-missing-unwanted-data_map">Example of missing or unwanted data when combining or separating fields</h3><div class="paragraph"><p>In a data mapping, you might need to identify missing or unwanted data when a source or target field contains compound data. For example, consider a <code>long_address</code> field that has this format:</p></div><div class="paragraph"><p><em>number street apartment city state zip zip+4 country</em></p></div><div class="paragraph"><p>Suppose that you want to separate the <code>long_address</code> field into discrete fields for <code>number</code>, <code>street</code>, <code>city</code>, <code>state</code>, and <code>zip</code>. To do this, you select <code>long_address</code> as the source field and then select the target fields. You then add padding fields at the locations for the parts of the source field that you do not want. In this example, the unwanted parts are <em>apartment</em>, <em>zip+4</em>, and <em>country</em>.</p></div><div class="paragraph"><p>To identify the unwanted parts, you need to know the order of the parts. The order indicates an index for each part of the content in the compound field. For example, the <code>long_address</code> field has 8 ordered parts. Starting at 1, the index of each part is:</p></div><table class="tableblock frame-all grid-all stretch"><colgroup><col style="width:16.6666%"><col style="width:83.3334%"></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><em>number</em></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><em>street</em></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><em>apartment</em></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><em>city</em></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><em>state</em></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><em>zip</em></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><em>zip+4</em></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><em>country</em></p></td></tr></tbody></table><div class="paragraph"><p>In the data mapper, to identify <em>apartment</em>, <em>zip+4</em>, and <em>country</em> as missing, you add padding fields at indexes 3, 7, and 8. See <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#combine-multiple-source-fields-into-one-target-field_map">Combining multiple source fields into one target field</a>.</p></div><div class="paragraph"><p>Now suppose that you want to combine source fields for <code>number</code>, <code>street</code>, <code>city</code>, <code>state</code>, and <code>zip</code> into a <code>long_address</code> target field. Further suppose that there are no source fields to provide content for <em>apartment</em>, <em>zip+4</em>, and <em>country</em>. In the data mapper, you need to identify these fields as missing. Again, you add padding fields at indexes 3, 7, and 8. See <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#separate-one-source-field-into-multiple-target-fields_map">Separating one source field into multiple target fields</a>.</p></div></div><div class="sect2"><h3 id="combine-multiple-source-fields-into-one-target-field_map">Combining multiple source fields into one target field</h3><div class="paragraph"><p>In a data mapper step, you can combine multiple source fields into one compound target field. For example, you can map the <code>FirstName</code> and <code>LastName</code> fields to the <code>CustomerName</code> field.</p></div><div class="paragraph"><div class="title">Prerequisite</div><p>For the target field, you must know what type of content is in each part of this compound field, the order and index of each part of the content, and the separator between parts, such as a space or comma. See <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#example-missing-unwanted-data_map">Example of missing or unwanted data</a>.</p></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the <strong>Target</strong> panel, click the field into which you want to map more than one source field and then click <span class="image"><img src="images/integrating-applications/create-mapping-icon.png" alt="the Create new mapping icon"></span>. The <strong>Mapping Details</strong> panel opens.</p></li><li><p>In the <strong>Mapping Details</strong> panel,from the Source drop-down list, select one or more data fields that you want to map to.</p><div class="paragraph"><p>When you are done you should see a line from each of the source fields to the target field.</p></div><div class="paragraph"><p>In the <strong>Mapping Details</strong> panel, above <strong>Sources</strong>, the data mapper displays the default multiplicity transformation, which is <strong>Concatenate</strong>. This indicates that execution of the mapping applies the <strong>Concatenate</strong> transformation to the values in the selected source fields and maps the concatenated value to the selected target field.</p></div><div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">For information about other transformations that you can apply to multiple source values see <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#about-transformations-on-multiple-source-values_map">About transformations on multiple source values</a></td></tr></table></div></li><li><p>In the <strong>Mapping Details</strong> panel, configure the mapping as follows:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Under <strong>Sources</strong>, in the <strong>Delimiter</strong> field, accept or select the character that the data mapper inserts in the target field between the content from different source fields. The default is a space.</p></li><li><p>Optionally, in each source field entry, you can click <span class="image"><img src="images/integrating-applications/transformation-icon.png" alt="the Transformation icon"></span>to apply a transformation to the source field value before it gets mapped to the target field.</p></li><li><p>Under <strong>Sources</strong>, check the order of the entries for the source fields that you selected. The entries must be in the same order as the corresponding content in the compound target field.</p><div class="paragraph"><p>If the entries are not in the correct order, change the index number for the field entries to achieve the same order.</p></div><div class="paragraph"><p>If you mapped a source field to each part of the compound target field, skip the next step.</p></div></li><li><p>For each source field entry that does not already have the same index as the corresponding data in the target field, edit the index to be the same. Each source field entry must have the same index as the corresponding data in the target field. The data mapper automatically adds padding fields as needed to indicate missing data.</p><div class="paragraph"><p>If you accidentally create too many padding fields, click <span class="image"><img src="images/integrating-applications/TrashIcon.png" alt="the Trash icon"></span>for each extra padding field to delete it.</p></div></li><li><p>Optionally, under <strong>Targets</strong>, click <span class="image"><img src="images/integrating-applications/transformation-icon.png" alt="the Transformation icon"></span>to map the content into the target field and then apply a transformation as described in <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#transform-target-data_map">Transforming source or target data</a>.</p></li></ol></div></li><li><p>Optionally, preview the data mapping result:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Click <span class="image"><img src="images/integrating-applications/preview-mapping-icon.png" alt="the Show/Hide Preview Mapping icon"></span>to display a text input field on each source field for the currently selected mapping and a read-only result field on the target field of the currently selected mapping.</p></li><li><p>In the source data input fields, type sample values.</p><div class="paragraph"><p>If you reorder the source fields or add a transformation to the mapping then the result field on the target field reflects this. If the data mapper detects any errors, it displays informative messages at the top of the <strong>Mapping Details</strong> panel.</p></div></li><li><p>Hide the preview fields by clicking <span class="image"><img src="images/integrating-applications/preview-mapping-icon.png" alt="the Show/Hide Preview Mapping icon"></span>again.</p><div class="paragraph"><p>If you redisplay the preview fields, any data that you entered in them is still there and it remains there until you exit the data mapper.</p></div></li></ol></div></li><li><p>To confirm that the mapping is correctly defined, click <span class="image"><img src="images/tutorials/grid.png" alt="the Mapping Table icon"></span>to display (in table format) the mappings defined in this step. A mapping that combines the values of more than one source field into one target field looks like this: <span class="image"><img src="images/integrating-applications/CombineMapping.png" alt="the Combine Fields Mapping icon"></span>.</p><div class="paragraph"><p>You can also preview mapping results in this view. Click <span class="image"><img src="images/integrating-applications/preview-mapping-icon.png" alt="the Show/Hide Preview Mapping icon"></span>and then type text as described in the previous step. Preview fields appear for only the selected mapping. Click another mapping in the table to view preview fields for it.</p></div></li></ol></div><div class="paragraph"><div class="title">Additional resource</div><p>Example of adding padding fields: <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#separate-one-source-field-into-multiple-target-fields_map">Separating one source field into multiple target field</a>.</p></div><div class="paragraph"><p>Although that example is for a one-to-many mapping, the principles are the same.</p></div></div><div class="sect2"><h3 id="separate-one-source-field-into-multiple-target-fields_map">Separating one source field into multiple target fields</h3><div class="paragraph"><p>In a data mapper step, you can separate a compound source field into multiple target fields. For example, map the <code>Name</code> field to the <code>FirstName</code> and <code>LastName</code> fields.</p></div><div class="paragraph"><div class="title">Prerequisite</div><p>For the source field, you must know what type of content is in each part of this compound field, the order and index of each part of the content, and the separator between parts, such as a space or comma. See <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#example-missing-unwanted-data_map">Example of missing or unwanted data</a>.</p></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the <strong>Sources</strong> panel, click the field whose content you want to separate and then click <span class="image"><img src="images/integrating-applications/create-mapping-icon.png" alt="the Create new mapping icon"></span>.</p></li><li><p>In the <strong>Mapping Details</strong> panel, from the <strong>Target</strong> drop-down list, select the data fields that you want to map to.</p><div class="paragraph"><p>When you are done selecting target fields, you should see lines from the source field to each of the target fields that you selected.</p></div><div class="paragraph"><p>At the top of the <strong>Mapping Details</strong> panel, the data mapper displays <strong>Split</strong> to indicate that execution of the mapping splits the source field value and maps it to multiple target fields. * Under <strong>Targets</strong>, there is an entry for each target field that you selected.</p></div></li><li><p>In the <strong>Mapping Details</strong> panel, configure the mapping as follows:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Under <strong>Sources</strong>, in the <strong>Delimiter</strong> field, accept or select the character in the source field that indicates where to separate the source field values. The default is a space.</p></li><li><p>Optionally, click <span class="image"><img src="images/integrating-applications/transformation-icon.png" alt="the Transformation icon"></span>to apply a transformation to the source field value before it gets mapped to the target field.</p></li><li><p>Under <strong>Targets</strong>, check the order of the entries for the target fields that you selected. The entries must be in the same order as the corresponding content in the compound source field. It does not matter whether you did not specify a target field for one or more parts of the content in the source field.</p><div class="paragraph"><p>If the entries are not in the correct order, change the index number for the field entries to achieve the same order.</p></div><div class="paragraph"><p>If you mapped each part of the compound source field to a target field, then skip to the next step.</p></div></li><li><p>If the source field contains data that you do not need, then in the <strong>Mapping Details</strong> panel, edit the index of each target field that does not already have the same index as the corresponding data in the source field. Each target field entry must have the same index that the corresponding data has in the source field. The data mapper automatically adds padding fields as needed to indicate unwanted data.</p><div class="paragraph"><p>See the example at the end of this procedure.</p></div></li><li><p>Optionally, click <span class="image"><img src="images/integrating-applications/transformation-icon.png" alt="the Transformation icon"></span>to map the content into the target field and then apply a transformation as described in <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#transform-target-data_map">Transforming source or target data</a>.</p></li></ol></div></li><li><p>Optionally, preview the data mapping result:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Click <span class="image"><img src="images/integrating-applications/preview-mapping-icon.png" alt="the Show/Hide Preview Mapping icon"></span>to display a text input field on the source field and read-only result fields on each target field.</p></li><li><p>In the source field&#8217;s data input field, type a smaple value. Be sure to enter the separator character between the parts of the field. The mapping result appears in the read-only fields for the target fields.</p><div class="paragraph"><p>If you reorder the target fields or add a transformation to a target field then the result fields on the target fields reflect this. If the data mapper detects any errors, it displays informative messages at the top of the <strong>Mapping Details</strong> panel.</p></div></li><li><p>Hide the preview fields by clicking <span class="image"><img src="images/integrating-applications/preview-mapping-icon.png" alt="the Show/Hide Preview Mapping icon"></span>again.</p><div class="paragraph"><p>If you redisplay the preview fields, any data that you entered in them is still there and it remains there until you exit the data mapper.</p></div></li></ol></div></li><li><p>To confirm that the mapping is correctly defined, click <span class="image"><img src="images/tutorials/grid.png" alt="the Mapping Table icon"></span>to display the mappings defined in this step. A mapping that separates the value of a source field into multiple target fields looks like this: <span class="image"><img src="images/integrating-applications/SeparateMapping.png" alt="Separate Fields Mapping"></span>.</p><div class="paragraph"><p>You can also preview mapping results in this view. Click <span class="image"><img src="images/integrating-applications/preview-mapping-icon.png" alt="the Show/Hide Preview Mapping icon"></span>, and then type text as described in the previous step. Preview fields appear for only the selected mapping. Click another mapping in the table to view preview fields for it.</p></div></li></ol></div><div class="paragraph"><div class="title">Example of separating one field into multiple fields</div><p>Suppose that the source data contains one address field and it uses commas to separate the content parts, for example:</p></div><div class="listingblock"><div class="content"><pre>77 Hill Street, Brooklyn, New York, United States, 12345, 6789</pre></div></div><div class="paragraph"><p>In an address field, the parts of the content have these indexes:</p></div><table class="tableblock frame-all grid-all stretch"><colgroup><col style="width:66.6666%"><col style="width:33.3334%"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Content</th><th class="tableblock halign-left valign-top">Index</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Number and street</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">City</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">State</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Country</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Zip code</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Zip+4</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td></tr></tbody></table><div class="paragraph"><p>Now suppose that the target data has four fields for an address:</p></div><div class="listingblock"><div class="content"><pre>number-and-street
city
state
zip</pre></div></div><div class="paragraph"><p>To define the mapping, you do the following:</p></div><div class="ulist"><ul><li><p>Select the source field and then click <span class="image"><img src="images/integrating-applications/create-mapping-icon.png" alt="the Create new mapping icon"></span>.</p></li><li><p>In the <strong>Mapping Details</strong> panel, in the <strong>Sources</strong> section, select the delimiter, which is a comma in this example.</p></li><li><p>Select the four target fields.</p></li></ul></div><div class="paragraph"><p>After you do this, in the <strong>Mapping Details</strong> panel under <strong>Targets</strong>, there is an entry for each target field that you selected, for example:</p></div><div class="paragraph"><p><span class="image"><img src="images/integrating-applications/Example-Adding-Padding-Mapping.png" alt="Example of initial entries"></span>.</p></div><div class="paragraph"><p>The data mapper displays the target entries in the order in which they appear in the data mapper, which is alphabetical. You need to change this order so that it mirrors the order in the source field. In this example, the source field contains the <code>number-and-street</code> content before the <code>city</code> content. To correct the order of the target entries, edit the <code>city</code> index field to be <code>2</code>. The result looks like this:</p></div><div class="paragraph"><p><span class="image"><img src="images/integrating-applications/Example-Adding-Padding-Mapping-2.png" alt="Example or reordered entries"></span>.</p></div><div class="paragraph"><p>In the target field entries, the index numbers indicate the part of the source field that will be mapped to this target field. One of the index values needs to change to achieve the correct target field value. Consider each target field:</p></div><div class="ulist"><ul><li><p><code>number-and-street</code>  In the source field, the number and street content has an index of 1. It is correct to map the index 1 source to the <code>number-and-street</code> target field. No changes are needed in this target entry.</p></li><li><p><code>city</code>  In the source field, the city content has an index of 2. This target entry is also correct as it is.</p></li><li><p><code>state</code>  In the source field, the state content has an index of 3. This target entry is also correct as it is.</p></li><li><p><code>zip</code>  In the source field, the zip code content has an index of 5. The target field entry index of 4 is wrong. If you do not change it, during execution, the country part of the source field gets mapped to the <code>zip</code> target field. You need to change the index to 5. This instructs the data mapper to map the index 5 source content to the <code>zip</code> target field. After you change the index, the data mapper adds a padding field with an index of 4. The result looks like this:</p></li></ul></div><div class="paragraph"><p><span class="image"><img src="images/integrating-applications/Example-Adding-Padding-Mapping-3.png" alt="Example entries with padding"></span>.</p></div><div class="paragraph"><p>This mapping is now complete. Although the source field has additional content at index 6, (zip+4), the target does not need the data and nothing needs to be done.</p></div></div><div class="sect2"><h3 id="about-data-types-and-collections_map">About data types and collections in the data mapper</h3><div class="paragraph"><p>In the data mapper, a field can be:</p></div><div class="ulist"><ul><li><p>A <strong>primitive</strong> type that stores a single value. Examples of primitive types include <code>boolean</code>, <code>char</code>, <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, and <code>double</code>. A primitive type is not expandable because it is a single field.</p></li><li><p>A <strong>complex</strong> type that consists of multiple fields of different types. You define the child fields of a complex type at design time. In the data mapper, a complex type is expandable so that you can view its child fields.</p></li></ul></div><div class="paragraph"><p>Each type of field (primitive and complex) can also be a collection. A collection is a single field that can have multiple values. The number of items in a collection is determined at runtime. At design time, in the data mapper, a collection is indicated by <span class="image"><img src="images/integrating-applications/collection-icon.png" alt="the Collection icon"></span>. Whether a collection is expandable in the data mapper interface is determined by its type. When a collection is a primitive type, it is not expandable. When a collection is a complex type, then the data mapper is expandable to display the collections child fields. You can map from/to each field.</p></div><div class="paragraph"><p>Here are some examples:</p></div><div class="ulist"><ul><li><p><code>ID</code> is a primitive type field (<code>int</code>). At runtime, an employee can have only one <code>ID</code>. For example, <code>ID=823</code>. Therefore, <code>ID</code> is a primitive type that is not also a collection. In the data mapper, <code>ID</code> is not expandable.</p></li><li><p><code>email</code> is a primitive type field (string). At runtime, an employee can have multiple <code>email</code> values. For example, <code>email&lt;0&gt;=<a href="mailto:aslan@home.com">aslan@home.com</a></code> and <code>email&lt;1&gt;=<a href="mailto:aslan@business.com">aslan@business.com</a></code>. Therefore, <code>email</code> is a primitive type that also is a collection. The data mapper uses <span class="image"><img src="images/integrating-applications/collection-icon.png" alt="the Collection icon"></span>to indicate that the <code>email</code> field is a collection but <code>email</code> is not expandable because it is a primitive type (it does not have child fields).</p></li><li><p><code>employee</code> is a complex object field that has several child fields, including <code>ID</code> and <code>email</code>. At runtime, <code>employee</code> is also a collection, because the company has many employees.<br>At design time, the data mapper uses <span class="image"><img src="images/integrating-applications/collection-icon.png" alt="the Collection icon"></span>to indicate that <code>employee</code> is a collection. The <code>employee</code> field is expandable because it is a complex type that has child fields.</p></li></ul></div></div><div class="sect2"><h3 id="using-data-mapper-to-process-collections_map">Using the data mapper to process collections</h3><div class="paragraph"><p>In a flow, when a step outputs a collection and when a subsequent connection that is in the flow expects a collection as the input, you can use the data mapper to specify how you want the flow to process the collection.</p></div><div class="paragraph"><p>When a step outputs a collection, the flow visualization displays <strong>Collection</strong> in the details about the step. For example:</p></div><div class="paragraph"><p><span class="image"><img src="images/integrating-applications/data-type-collection.png" alt="Data Type: SQL Result (Collection)"></span></p></div><div class="paragraph"><p>Add a data mapper step after the step that provides the collection and before the step that needs the mappings. Exactly where in the flow this data mapper step needs to be depends on the other steps in the flow. The following image shows mappings from source collection fields to target collection fields:</p></div><div class="paragraph"><p><span class="image"><img src="images/integrating-applications/map-collections.png" alt="mapping collection"></span></p></div><div class="paragraph"><p>In the source and target panels, the data mapper displays <span class="image"><img src="images/integrating-applications/collection-icon.png" alt="the Collection icon"></span>to indicate a collection.</p></div><div class="paragraph"><p>When a collection is a complex type, the data mapper displays the collections child fields. You can map from/to each field.</p></div><div class="paragraph"><p>When a source field is nested in a number of collections you can map it to a target field that meets one of these conditions:</p></div><div class="ulist"><ul><li><p>The target field is nested in the same number of collections as the source field. For example, these mappings are allowed:</p><div class="ulist"><ul><li><p>/A&lt;&gt;/B&lt;&gt;/C &#8594; /D&lt;&gt;/E&lt;&gt;/F</p></li><li><p>/A&lt;&gt;/B&lt;&gt;/C &#8594; /G&lt;&gt;/H/I&lt;&gt;/J</p></li></ul></div></li><li><p>The target field is nested in only one collection. For example, this mapping is allowed:</p><div class="paragraph"><p>/A&lt;&gt;/B&lt;&gt;/C &#8594; /K&lt;&gt;/L</p></div><div class="paragraph"><p>In this case, the data mapper uses a depth-first algorithm to iterate over all values in the source. In order of occurrence, the data mapper puts the source values into a single target collection.</p></div></li></ul></div><div class="paragraph"><p>The following mapping is not allowed:</p></div><div class="paragraph"><p>/A&lt;&gt;/B&lt;&gt;/C cannot-map-to /M&lt;&gt;/N/O&lt;&gt;/P&lt;&gt;/Q</p></div><div class="paragraph"><p>When Syndesis executes the flow, it iterates over the source collection elements to populate the target collection elements. If you map one or more source collection fields to a target collection or to target collection fields, the target collection elements contain values for only the mapped fields.</p></div><div class="paragraph"><p>If you map a source collection or a field in a source collection to a target field that is not in a collection, then when Syndesis executes the flow, it assigns the value from only the last element in the source collection. Any other elements in the collection are ignored in that mapping step. However, any subsequent mapping steps can access all elements in the source collection.</p></div><div class="paragraph"><p>When a connection returns a collection that is defined in a JSON or Java document, the data mapper can usually process the source document as a collection.</p></div></div><div class="sect2"><h3 id="mapping-between-collections-and-non-collections_map">About mapping between collections and non-collections</h3><div class="paragraph"><p>In the data mapper <strong>Source</strong> and <strong>Target</strong> panels:</p></div><div class="ulist"><ul><li><p><span class="image"><img src="images/integrating-applications/collection-icon.png" alt="Collection icon"></span>indicates a collection. If the collection contains one primitive type, you can map directly from or to that collection. If the collection contains two or more different types, the data mapper displays the collections child fields and you can map to or from the collections fields.</p></li><li><p><span class="image"><img src="images/integrating-applications/folder.png" alt="Folder icon"></span>indicates an expandable container that is a complex type. A complex type contains multiple fields of different types. A field in a complex type can be a type that is a collection, such as an array. You cannot map a complex type container itself. You can map only the fields that are in the complex type.</p></li></ul></div><div class="paragraph"><p>To toggle the display of data types, such as <code><strong>(COMPLEX)</strong></code>, <code><strong>STRING</strong></code>, <code><strong>INTEGER</strong></code>, click <span class="image"><img src="images/integrating-applications/show-types-icon.png" alt="Show/hide types icon"></span>.</p></div><div class="paragraph"><div class="title">Collection to non-collection (many-to-one) mapping</div><p>When you map from a collection field to a non-collection field, the data mapper recognizes a many-to-one mapping. The default behavior is that the data mapper applies the <strong>Concatenate</strong> transformation to the source collection or source collection field. The default delimiter is a space. For example, consider this source collection:</p></div><div class="ulist"><ul><li><p>In the first element, the value in the <strong>city</strong> field is <strong>Boston</strong>.</p></li><li><p>In the second element, the value in the <strong>city</strong> field is <strong>Paris</strong>.</p></li><li><p>In the third element, the value in the <strong>city</strong> field is <strong>Tokyo</strong>.</p></li></ul></div><div class="paragraph"><p>During execution, the data mapper populates the target field with</p></div><div class="paragraph"><p><code>Boston Paris Tokyo</code></p></div><div class="paragraph"><p>You can change this default behavior by applying a different transformation. For example, to map only from the element that you choose, apply the <strong>Item At</strong> transformation to the source and specify an index. To map the value that is in the first element in the source collection, specify <code>0</code> for the index.</p></div><div class="paragraph"><p>If a source collection contains fields that you do not map, those fields are still available to subsequent steps that are in the flow.</p></div><div class="paragraph"><div class="title">Non-collection to collection (one-to-many) mapping</div><p>When you map from a non-collection source field to a target collection or to a target field that is in a collection element, the data mapper recognizes a one-to-many mapping. The default behavior is that the data mapper applies the <strong>Split</strong> transformation by using whitespace as the delimiter and splitting the source value into multiple values. During execution, the data mapper inserts each split value into its own element in the target collection. For example, if the source field is split into 4 values then the target collection has 4 elements.</p></div><div class="paragraph"><p>In this release, the <strong>Split</strong> transformation is the only transformation that you can apply to a one-to-many mapping.</p></div><div class="paragraph"><p>For example, consider a non-collection, <code>cities</code> source field that contains:</p></div><div class="paragraph"><p><code>Boston Paris Tokyo</code></p></div><div class="paragraph"><p>You can map this source field to a target collection or to a target field that is in a collection. During execution, the data mapper splits the value of the <strong>cities</strong> field at the space delimiter. The result is a collection that contains three elements. In the first element, the value of the <strong>city</strong> field is <code>Boston</code>. In the second element, the value of the <strong>city</strong> field is <code>Paris</code>. In the third element, the value of the <strong>city</strong> field is <code>Tokyo</code>.</p></div><div class="ulist"><div class="title">Additional resources</div><ul><li><p><a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#about-transformations-on-multiple-source-values_map">About transformations on multiple source values before mapping to one target field</a></p></li><li><p><a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#combine-multiple-source-fields-into-one-target-field_map">Combining multiple source fields into one target field</a></p></li><li><p><a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#separate-one-source-field-into-multiple-target-fields_map">Separating one source field into multiple target fields</a></p></li></ul></div></div><div class="sect2"><h3 id="transform-target-data_map">Transforming source or target data</h3><div class="paragraph"><p>In the data mapper, after you define a mapping, you can transform any field in the mapping. Transforming a data field defines how you want to store the data. For example, you could specify the <strong>Capitalize</strong> transformation to ensure that the first letter of a data value is uppercase.</p></div><div class="paragraph"><p><strong>Note:</strong> If you want to add a condition to a mapping, you need to place any transformations within the conditional expression as described in <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#applying-conditions-to-mappings_map">Applying conditions to mappings</a>.</p></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>Map the fields. This can be a one-to-one mapping, a combination mapping, or a separation mapping.</p></li><li><p>In the <strong>Mapping Details</strong> panel, under <strong>Sources</strong> or under <strong>Targets</strong>, in the box for the field that you want to transform, click <span class="image"><img src="images/integrating-applications/transformation-icon.png" alt="the Transformation icon"></span>. This option displays a drop-down list of available transformations.</p></li><li><p>Select the transformation that you want the data mapper to perform.</p></li><li><p>If the transformation requires any input parameters, specify them in the appropriate input fields.</p></li><li><p>To add another transformation, click <span class="image"><img src="images/integrating-applications/transformation-icon.png" alt="the Transformation icon"></span>again.</p></li></ol></div><div class="ulist"><div class="title">Additional resource</div><ul><li><p><a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#available-transformations_map">Available transformations</a></p></li><li><p><a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#about-transformations-on-multiple-source-values_map">About transformations on multiple source values before mapping to one target field</a></p></li></ul></div></div><div class="sect2"><h3 id="about-transformations-on-multiple-source-values_map">About transformations on multiple source values before mapping to one target field</h3><div class="paragraph"><p>There are some transformations that you can apply to multiple source fields or to the values in a source field that contains multiple values, such as a collection. The data mapper inserts the result of the transformation into the target field. The following table describes these multiplicity transformations.</p></div><table class="tableblock frame-all grid-all stretch"><colgroup><col style="width:25%"><col style="width:75%"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Multiplicity transformation</th><th class="tableblock halign-left valign-top">Description</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Add</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Adds the numeric source values and inserts the sum into the target field. The values in the selected source fields or in the selected collection must be numeric.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Average</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Calculates the average of the numeric source values and inserts the result into the target field. The values in the selected source fields or in the selected collection must be numeric.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Concatenate</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Joins the source values and inserts the result into the target field. You can accept a space as the delimiter or specify another character. The data mapper inserts this character in the target field between the source values. A common use of this transformation is to combine multiple source field values, for example, <strong>FirstName</strong>, <strong>MiddleName</strong>, and <strong>LastName</strong>, in one target field, for example, <strong>CustomerName</strong>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Contains</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Evaluates the source values to determine whether any value contains a parameter value that you specify. If any source value contains the specified parameter value, the data mapper inserts <strong>true</strong> into the target field. If no source value contains the parameter value then the data mapper inserts <strong>false</strong> into the target field.</p><p class="tableblock">For example, suppose you want to track activity related to a particular customer. You can select a source collection field where each collection member contains customer information. For the <strong>Value</strong> parameter, you specify a particular email address. When the data mapper finds the specified email address in the collection, it inserts <strong>true</strong> in the target field.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Count</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Inserts the number of source values in the target field. This is useful when the source field is a collection. The data mapper inserts the size of the collection in the target field.</p><p class="tableblock">For example, suppose you select an <strong>Order</strong> source field that is a collection of item objects. Applying the <strong>Count</strong> transformation inserts the number of items that are in the order into the target field.</p><p class="tableblock">As another example, if you select 4 individual source fields, the data mapper inserts <strong>4</strong> in the target field.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Divide</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Divides the first source value by the second source value and inserts the result in the target field. If there are more that two source values then execution continues to divide the result by the next number. For example, consider a <code>numbers[]</code> collection that contains <code>{1000, 100, 10}</code>. Execution divides <code>1000</code> by <code>100</code> to get <code>10</code>, and then divides <code>10</code> by <code>10</code> to get <code>1</code>. The mapper inserts <code>1</code> in the target field.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Format</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Replaces placeholders in a template that you specify with values from the source fields that you select. The data mapper inserts the resulting string in the target field. For example, suppose you select three source fields:</p><p class="tableblock"><strong>time</strong><br><strong>name</strong><br><strong>text</strong><br></p><p class="tableblock">You select the <strong>Format</strong> transformation and in the <strong>Template</strong> parameter you could specify:</p><p class="tableblock"><code><strong>At $time, $name tweeted: $text</strong></code></p><p class="tableblock">In the target field, the result would be something like:</p><p class="tableblock"><strong>At 8:00 AM, Aslan tweeted: ROAR!</strong></p><p class="tableblock">This is similar to mechanisms that are available in programming languages such as Java and C.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Item At</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">For the source field that you select, the data mapper finds the value at the index that you specify and inserts that value in the target field. The source field must be a collection or a field that contains multiple values with delimiters.</p><p class="tableblock">For example, suppose the selected source field is a collection of customer email addresses. After you select the <strong>Item At</strong> transformation, in the <strong>Index</strong> parameter field, you specify <strong>0.</strong> The data mapper inserts the first email address, which is at index 0, in the target field.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Maximum</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Evaluates the source values and inserts the highest value in the target field. The source values must be numeric.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Minimum</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Evaluates the source values and inserts the lowest value in the target field. The source values must be numeric.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Multiply</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Multiplies the first source value by the second source value and inserts the result in the target field. If there are more that two source values then execution continues to multiply the result by the next number. For example, consider a <code>numbers[]</code> collection that contains <code>{10, 100, 1000}</code>. Execution multiplies <code>10</code> by <code>100</code> to get <code>1000</code>, and then multiplies <code>1000</code> by <code>1000</code> to get <code>1000000</code>. The mapper inserts <code>1000000</code> in the target field.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Subtract</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Subtracts the second source value from the first source value and inserts the result in the target field. If there are more that two source values then execution continues to subtract the next number from the previous result. For example, consider a <code>numbers[]</code> collection that contains <code>{100, 90, 9}</code>. Execution subtracts <code>90</code> from <code>100</code> to get <code>10</code>, and then subtracts <code>9</code> from <code>10</code> to get <code>1</code>. The mapper inserts <code>1</code> in the target field.</p></td></tr></tbody></table><div class="ulist"><div class="title">Additional resources</div><ul><li><p><a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#combine-multiple-source-fields-into-one-target-field_map">Combining multiple source fields into one target field</a></p></li><li><p><a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#example-missing-unwanted-data_map">Separating one source field into multiple target fields</a></p></li></ul></div></div><div class="sect2"><h3 id="applying-conditions-to-mappings_map">Applying conditions to mappings</h3><div class="paragraph"><p>In some integrations, it is helpful to add conditional processing to a mapping. For example, suppose that you are mapping a source zip code field to a target zip code field. If the source zip code field is empty, you might want to fill the target field with <code>99999</code>. To do this, you would specify an expression that tests the zip code source field to determine if it is empty, and if it is empty, inserts <code>99999</code> into the zip code target field.</p></div><div class="paragraph"><p>The data mapper supports expressions that are similar to a Microsoft Excel expressions, but does not support all Microsoft Excel expression syntax. A conditional expression can refer to an individual field or to a field that is in a collection.</p></div><div class="paragraph"><p>You can define zero or one condition for each mapping.</p></div><div class="paragraph"><p>The following procedure gets you started with applying conditions to mappings.</p></div><div class="paragraph"><p><strong>Note:</strong> After you add a condition to a mapping, the Source and Target transformation options are disabled. You must place any transformations within the conditional expression.</p></div><div class="ulist"><div class="title">Prerequisites</div><ul><li><p>You are mapping fields in a <strong>Data Mapper</strong> step.</p></li><li><p>You are familiar with Microsoft Excel expressions or you have the conditional expression that you want to apply to a mapping.</p></li></ul></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>If data types are not already visible, display them by clicking <span class="image"><img src="images/integrating-applications/show-types-icon.png" alt="Show/hide types icon"></span>.</p><div class="paragraph"><p>While this is not a requirement for specifying a condition, it is helpful to see the data types.</p></div></li><li><p>Create the mapping that you want to apply a condition to, or ensure that the currently selected mapping is the mapping that you want to apply a condition to. For example, consider this mapping:</p><div class="paragraph"><p><span class="image"><img src="images/integrating-applications/first-conditional-mapping.png" alt="lastName and firstName map to customerName"></span></p></div></li><li><p>In the upper left, click <span class="image"><img src="images/integrating-applications/add-condition-to-mapping.png" alt="the Add expression icon"></span>to display the conditional expression input field.</p><div class="paragraph"><p>In the expression field, the data mapper automatically displays the names of the source fields in the current mapping. For example:</p></div><div class="paragraph"><p><span class="image"><img src="images/integrating-applications/first-conditional-mapping-expression.png" alt="lastName + firstName"></span></p></div><div class="paragraph"><p>In the expression input field, the order of the source fields is the order in which you selected them when you created the mapping. This is important because the default mapping behavior is that the data mapper concatenates the field values in this order to insert the result in the target field. In this example, to create this mapping, <code>lastName</code> was selected first and then <code>firstName</code> was selected.</p></div></li><li><p>Edit the expression input field to specify the conditional expression that you want the data mapper to apply to the mapping. Details about supported conditional expressions follow this procedure.</p><div class="paragraph"><p>If you want to include a transformation in a conditional mapping, you must add the transformation to the conditional expression.</p></div><div class="paragraph"><p>As you specify the expression, you can type <code>@</code> and start to type the name of a field. The data mapper displays a list of the fields that match what you entered. Select the field that you want to specify in the expression.</p></div><div class="paragraph"><p>When you add a field name to the expression, the data mapper adds that field to the mapping. For example, consider this conditional expression:</p></div><div class="paragraph"><p><span class="image"><img src="images/integrating-applications/second-conditional-mapping-expression.png" alt="if(ISEMPTY(lastName)" width="firstName" height="orderId + phone)"></span></p></div><div class="paragraph"><p>During execution, if the data mapper determines that the <code>lastName</code> field is empty, it maps only the <code>firstName</code> field to the target <code>customerName</code> field. If the <code>lastName</code> field contains a value, that is, it is not empty, the data mapper concatenates the values in the source <code>orderId</code> and <code>phone</code> fields, and inserts the result in the <code>customerName</code> field. (This example shows how the logic works, but it is probably not a useful example because when there is a value in the <code>lastName</code> field, you most likely want the data mapper to simply perform the mapping and not map some other value into the target.)</p></div><div class="paragraph"><p>For this example, after you complete entering the expression, the data mapping is:</p></div><div class="paragraph"><p><span class="image"><img src="images/integrating-applications/second-conditional-mapping.png" alt="lastName" width="firstName" height="orderId"></span></p></div><div class="paragraph"><p>In the conditional expression, if you remove a field name that is in the mapping that the expression applies to, the data mapper removes that field from the mapping. In other words, every field name in the mapping must be in the conditional expression.</p></div></li><li><p>If mapping preview fields are not already visible, display them by clicking <span class="image"><img src="images/integrating-applications/preview-mapping-icon.png" alt="the Show/Hide Preview Mapping icon"></span>.</p></li><li><p>Type sample data in the source preview input field(s) to ensure that the target field or target fields get(s) the correct value.</p></li><li><p>Edit the conditional expression as needed to obtain the desired result.</p></li></ol></div><div class="ulist"><div class="title">Supported functions in conditional expressions</div><ul><li><p><code>ISEMPTY(<em>source-field-name1</em> [+ <em>source-field-name2</em>])</code></p><div class="paragraph"><p>The result of the <code>ISEMPTY()</code> function is a Boolean value. Specify at least one argument, which is the name of a source field in the mapping that you want to apply the condition to. When the specified source field is empty, the <code>ISEMPTY()</code> function returns true.</p></div><div class="paragraph"><p>Optionally, add the + (concatenation) operator with an additional field, for example:</p></div><div class="paragraph"><p><code>ISEMPTY(lastName + firstName)</code></p></div><div class="paragraph"><p>This expression evaluates to true if both source fields, <code>lastName</code> and <code>firstName</code>, are empty.</p></div><div class="paragraph"><p>Often, the <code>ISEMPTY()</code> function is the first argument in an <code>IF()</code> function.</p></div></li><li><p><code>IF(<em>boolean-expression</em>, <em>then</em>, <em>else</em>)</code></p><div class="paragraph"><p>When <code><em>boolean-expression</em></code> evaluates to true, the data mapper returns <code><em>then</em></code>. When <code><em>boolean-expression</em></code> evaluates to false, the data mapper returns <code><em>else</em></code>. All three arguments are required. The last argument can be null, which means that nothing is mapped when <code><em>boolean-expression</em></code> evaluates to false.</p></div><div class="paragraph"><p>For example, consider the mapping that combines the <code>lastName</code> and <code>firstName</code> source fields in the target <code>customerName</code> field. You can specify this conditional expression:</p></div><div class="paragraph"><p><code>IF (ISEMPTY(lastName), firstName, lastName + , + firstName )</code></p></div><div class="paragraph"><p>During execution, the data mapper evaluates the <code>lastName</code> field.</p></div><div class="ulist"><ul><li><p>If the <code>lastName</code> field is empty, that is, <code>ISEMPTY(lastName)</code> returns true, the data mapper inserts only the <code>firstName</code> value into the target <code>customerName</code> field.</p></li><li><p>If the <code>lastName</code> field contains a value, that is, <code>ISEMPTY(lastName)</code> returns false, the data mapper maps the <code>lastName</code> value, followed by a comma, followed by the <code>firstName</code> value into the target <code>customerName</code> field.</p><div class="paragraph"><p>Now consider the behavior if the third argument in this expression is null:</p></div><div class="paragraph"><p><code>IF (ISEMPTY(lastName), firstName, null )</code></p></div><div class="paragraph"><p>During execution, the data mapper evaluates the <code>lastName</code> field.</p></div></li><li><p>As in the previous example, if the <code>lastName</code> field is empty, that is, <code>ISEMPTY(lastName)</code> returns true, the data mapper inserts only the <code>firstName</code> value into the target <code>customerName</code> field.</p></li><li><p>However, when the third argument is null, if the <code>lastName</code> field contains a value, that is, <code>ISEMPTY(lastName)</code> returns false, the data mapper does not map anything into the target <code>customerName</code> field.</p></li></ul></div></li><li><p><code>LT(x,y)</code> or <code>&lt;(x,y)</code></p><div class="paragraph"><p>The data mapper evaluates <code>x</code> and <code>y</code> and returns the lower value. Both <code>x</code> and <code>y</code> must be numbers.</p></div></li><li><p><code>TOLOWER(string)</code></p><div class="paragraph"><p>The data mapper converts the specified string to lowercase and returns it.</p></div></li></ul></div><table class="tableblock frame-all grid-all stretch"><caption class="title">Table 1. Supported operators in conditional expressions</caption><colgroup><col style="width:33.3333%"><col style="width:66.6667%"></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Operator</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Description</strong></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>+</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Add numeric values or concatenate string values.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>-</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Subtract a numeric value from another numeric value.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>*</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Multiply numeric values.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>\</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Divide numeric values.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;&amp;</code><br>And</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Return true if both the left and right operands are true. Each operand must return a Boolean value.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>||</code><br>Or</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Return true if the left operand is true, or if the right operand is true, or if both operands are true. Each operand must return a Boolean value.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>!</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Not</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>&gt;</code><br>Greater than</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Return true if the left numeric operand is greater than the right numeric operand.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">&lt;<br>Less than</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Return true if the left numeric operand is less than the right numeric operand.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>==</code><br>Equal</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Return true if the left operand and the right operand are the same.</p></td></tr></tbody></table></div><div class="sect2"><h3 id="available-transformations_map">Descriptions of available transformations</h3><div class="paragraph"><p>The following table describes the available transformations. The date and number types refer generically to any of the various forms of these concepts. That is, number includes, for example, <code>integer</code>, <code>long</code>, <code>double</code>. Date includes, for example, <code>date</code>, <code>Time</code>, <code>ZonedDateTime</code>.</p></div><table class="tableblock frame-all grid-all stretch"><colgroup><col style="width:20%"><col style="width:20%"><col style="width:20%"><col style="width:20%"><col style="width:20%"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Transformation</th><th class="tableblock halign-left valign-top">Input Type</th><th class="tableblock halign-left valign-top">Output Type</th><th class="tableblock halign-left valign-top">Parameter (* = required)</th><th class="tableblock halign-left valign-top">Description</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>AbsoluteValue</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Return the absolute value of a number.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>AddDays</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">date</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">date</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>days</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Add days to a date. The default is 0 days.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>AddSeconds</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">date</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">date</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>seconds</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Add seconds to a date. The default is 0 seconds.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Append</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Append a string to the end of a string. The default is to append nothing.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Camelize</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Convert a phrase to a camelized string by removing whitespace, making the first word lowercase, and capitalizing the first letter of each subsequent word.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Capitalize</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Capitalize the first character in a string.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Ceiling</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Return the whole number ceiling of a number.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Contains</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">any</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>value</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Return true if a field contains the specified value.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>ConvertAreaUnit</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>fromUnit</code>*</p><p class="tableblock"><code>toUnit</code> *</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Convert a number that represents an area to another unit. For the <code>fromUnit</code> and <code>toUnit</code> parameters, select the appropriate unit from the <strong>From Unit</strong> and <strong>To Unit</strong> menus. The choices are: <code>Square Foot</code>, <code>Square Meter</code>, or <code>Square Mile</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>ConvertDistanceUnit</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>fromUnit</code> *</p><p class="tableblock"><code>toUnit</code> *</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Convert a number that represents a distance to another unit. For the <code>fromUnit</code> and <code>toUnit</code> parameters, select the appropriate unit from the <strong>From Unit</strong> and <strong>To Unit</strong> menus. The choices are: <code>Foot</code>, <code>Inch</code>, <code>Meter</code>, <code>Mile</code>, or <code>Yard</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>ConvertMassUnit</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>fromUnit</code> *</p><p class="tableblock"><code>toUnit</code> *</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Convert a number that represents mass to another unit. For the <code>fromUnit</code> and <code>toUnit</code> parameters, select the appropriate unit from the <strong>From Unit</strong> and <strong>To Unit</strong> menus. The choices are: <code>Kilogram</code> or <code>Pound</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>ConvertVolumeUnit</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>fromUnit</code> *</p><p class="tableblock"><code>toUnit</code> *</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Convert a number that represents volume to another unit. For the <code>fromUnit</code> and <code>toUnit</code> parameters, select the appropriate unit from the <strong>From Unit</strong> and <strong>To Unit</strong> menus. The choices are: <code>Cubic Foot</code>, <code>Cubic Meter</code>, <code>Gallon US Fluid</code>, or <code>Liter</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>DayOfWeek</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">date</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Return the day of the week (1 through 7) that corresponds to the date.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>DayOfYear</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">date</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Return the day of the year (1 through 366) that corresponds to the date.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>EndsWith</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>string</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Return true if a string ends with the specified <code>string</code> and the case is the same in both strings.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Equals</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">any</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>value</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Return true if the input field is equal to the specified <code>value</code> and the case is the same in the field and in the value.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>FileExtension</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">From a string that represents a file name, return the file extension without the dot.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Floor</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Return the whole number floor of a number.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Format</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">any</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>template</code> *</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">In <code>template</code>, replace each placeholder (such as <code>%s</code>) with the value of the input field and return a string that contains the result. This is similar to mechanisms that are available in programming languages such as Java and C.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>IndexOf</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string<br>The first character is at index 0.</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>string</code><br>Search the input string for this string.</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Return the index of the character in the input string that is the parameter string&#8217;s first character. Return <code>-1</code> if the parameter string is not found.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>IsNull</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">any</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Return true if a field is null.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>LastIndexOf</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string<br>The first character is at index 0.</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>string</code><br>Search the input string for this string.</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Return the index of the character in the input string that is the parameter string&#8217;s last character. Return <code>-1</code> if the parameter string is not found.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Length</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">any</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Return the length of the field, or <code>-1</code> if the field is null.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Lowercase</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Convert a string to lowercase.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Normalize</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Replace consecutive whitespace characters with a single space and trim leading and trailing whitespace from a string.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>PadStringLeft</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>padCharacter</code> *</p><p class="tableblock"><code>padCount</code> *</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Insert the character supplied in <code>padCharacter</code> at the beginning of a string. Do this the number of times specified in <code>padCount</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>PadStringRight</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>padCharacter</code> *</p><p class="tableblock"><code>padCount</code> *</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Insert the character supplied in <code>padCharacter</code> at the end of a string. Do this the number of times specified in <code>padCount</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Prepend</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>string</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Prefix <code>string</code> to the beginning of a string. the default is to prepend nothing.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>ReplaceAll</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>match</code> *</p><p class="tableblock"><code>newString</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">In a string, replace all occurrences of the supplied matching string with the supplied <code>newString</code>. The default <code>newString</code> is an empty string.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>ReplaceFirst</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>match</code> *</p><p class="tableblock"><code>newString</code> *</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">In a string, replace the first occurrence of the specified <code>match</code> string with the specified <code>newString</code>. The default <code>newString</code> is an empty string.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Round</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Return the rounded whole number of a number.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>SeparateByDash</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Replace each occurrence of whitespace, colon (:), underscore (_), plus (+), and equals (=) with a hyphen (-).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>SeparateByUnderscore</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Replace each occurrence of whitespace, colon (:), hyphen (-), plus (+), and equals (=) with an underscore (_).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>StartsWith</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>string</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Return true if a string starts with the specified string (including case).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Substring</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>startIndex</code> *</p><p class="tableblock"><code>endIndex</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Retrieve a segment of a string from the specified inclusive <code>startIndex</code> to the specified exclusive <code>endIndex</code>. Both indexes start at zero. <code>startIndex</code> is inclusive. <code>endIndex</code> is exclusive. The default value of <code>endIndex</code> is the length of the string.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>SubstringAfter</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>startIndex</code> *</p><p class="tableblock"><code>endIndex</code></p><p class="tableblock"><code>match</code> *</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Retrieve the segment of a string after the specified <code>match</code> string from the specified inclusive <code>startIndex</code> to the specified exclusive <code>endIndex</code>. Both indexes start at zero. The default value of <code>endIndex</code> is the length of the string after the supplied <code>match</code> string.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>SubstringBefore</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>startIndex</code> *</p><p class="tableblock"><code>endIndex</code></p><p class="tableblock"><code>match</code> *</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Retrieve a segment of a string before the supplied <code>match</code> string from the supplied inclusive <code>startIndex</code> to the supplied exclusive <code>endIndex</code>. Both indexes start at zero. The default value of <code>endIndex</code> is the length of the string before the supplied <code>match</code> string.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Trim</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Trim leading and trailing whitespace from a string.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>TrimLeft</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Trim leading whitespace from a string.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>TrimRight</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Trim trailing whitespace from a string.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Uppercase</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Convert a string to uppercase.</p></td></tr></tbody></table></div><div class="sect2"><h3 id="troubleshooting-data-mapping_map">Troubleshooting data mapping</h3><div class="paragraph"><p>The data mapper displays the largest possible set of source fields that can be provided by the previous integration step. However, not all connections provide data in each displayed source field. For example, a change to a third-party application might discontinue providing data in a particular field. As you create an integration, if you notice that data mapping is not behaving as you expect, ensure that the source field that you want to map contains the data that you expect.</p></div><div class="paragraph"><p>A data shape change that affects a field that is already mapped might prevent the data mapper from loading a document. In this situation, when you try to edit a data mapper step that maps the affected field, the data mapper cannot display the source and target panels. Instead, it displays an error that indicates that it cannot load or cannot find the document. The error message looks like one of the following messages:</p></div><div class="ulist"><ul><li><p><code>Data Mapper UI Initialization Error: Could not load document '-La_rwMD_ggphAW6nE9o': undefined undefined</code></p></li><li><p><code>Could not find document for mapped field 'last_name' at URI atlas:json:-LaX4LMC1CfVJYp3JXM6</code></p></li></ul></div><div class="paragraph"><p>You must delete this data mapper step and replace it with a new data mapper step in which you map the updated fields.</p></div><div class="paragraph"><p>While a data shape change to a mapped field always requires you to redo the mapping, you do not always need to delete and remove the data mapper step. For example, if an XML instance specifies an input data shape and you change the name of an element, the data mapper removes the mapping that was to/from the old field name. You just need to map to/from the field with the updated name.</p></div><div class="paragraph"><p>It is possible to change the data shape for a mapped field in the following ways:</p></div><div class="ulist"><ul><li><p>In an API provider integration, while editing a flow, you edit the OpenAPI document that defines the operation.</p><div class="paragraph"><p>Changing the data shape of the operation response always prevents the data mapper from being able to load the document.</p></div></li><li><p>In a flow, you edit the input data type and/or the output data type for one of these kinds of connections:</p><div class="ulist"><ul><li><p>Amazon S3</p></li><li><p>AMQ</p></li><li><p>AMQP</p></li><li><p>Dropbox</p></li><li><p>FTP/SFTP</p></li><li><p>HTTP/HTTPS</p></li><li><p>Kafka</p></li><li><p>IRC</p></li><li><p>MQTT</p></li></ul></div></li></ul></div></div></div></div><div class="sect1"><h2 id="managing-integrations_ug">Managing integrations</h2><div class="sectionbody"><div class="paragraph"><p>A common set up is to have a Syndesis development environment, a Syndesis test environment, and a Syndesis deployment environment. To facilitate this, Syndesis provides the ability to export an integration from one Syndesis environment and then import that integration into another Syndesis environment. The information and procedures for managing integrations are the same in each kind of Syndesis environment, unless specifically noted.</p></div><div class="paragraph"><p>The following topics provide information to help you manage your integrations:</p></div><div class="ulist"><ul><li><p><a href="#about-integration-lifecycle-handling_manage">About integration lifecycle handling</a></p></li><li><p><a href="#putting-integrations-into-service_manage">Putting integrations into and out of service</a></p></li><li><p><a href="#add-log-step_manage">Logging information about integration execution</a></p></li><li><p><a href="#monitoring-integrations_manage">Monitoring integrations</a></p></li><li><p><a href="#testing-integrations_manage">Testing integrations</a></p></li><li><p><a href="#troubleshooting-integration-execution_manage">Tips for troubleshooting integration execution</a></p></li><li><p><a href="#updating-integrations_manage">Updating integrations</a></p></li><li><p><a href="#adjusting-integration-configuration_manage">Adjusting the memory and CPU configuration attributes for an integration</a></p></li><li><p><a href="#deleting-integrations_manage">Deleting integrations</a></p></li><li><p><a href="#copying-integrations-to-other-environments_manage">Copying an integration to another environment</a></p></li></ul></div><div class="sect2"><h3 id="about-integration-lifecycle-handling_manage">About integration lifecycle handling</h3><div class="paragraph"><p>After you create and publish an integration, you might want to update what the integration does. You can edit a draft of the published integration and then replace the running version with the updated version. To facilitate this, for each integration, Syndesis maintains multiple versions as well as each version&#8217;s state. An understanding of integration versions and states helps you to manage your integrations.</p></div><div class="paragraph"><div class="title">Description of integration versions</div><p>In each Syndesis environment, each integration can have multiple versions. Support for multiple integration versions has several benefits:</p></div><div class="ulist"><ul><li><p>If you publish a version that does not work correctly, then you can return to running a correct version of the integration. To do that, you stop the incorrect version and start a version that runs the way you want it to.</p></li><li><p>As requirements or tools change, you can incrementally update an integration. You do not need to create a new integration.</p></li></ul></div><div class="paragraph"><p>Syndesis assigns a new version number each time it starts running a new version of an integration. For example, suppose you publish the Twitter to Salesforce sample integration. After it has been running, you update the integration to use a different account to connect to Twitter. You then publish the updated integration. Syndesis stops the running version of the integration, and publishes the updated version of the integration with an incremented version number.</p></div><div class="paragraph"><p>The initial integration that was running is version 1. The updated integration that is now running is version 2. If you edit version 2, for example to use a different account to connect to Salesforce, and you publish that version then it becomes version 3 of the integration.</p></div><div class="paragraph"><p>There can be exactly one draft version of an integration. Syndesis has a definition for the draft version of an integration but it has never run this version of the integration. The draft version of an integration does not have a number. When you edit an integration, you are updating the draft version of the integration.</p></div><div class="paragraph"><p>In Syndesis, you can see a list of the versions of an integration in the integration&#8217;s summary page. To view this page, in the left navigation panel, click <strong>Integrations</strong>. In the entry for the integration that you are interested in, click <strong>View</strong>.</p></div><div class="paragraph"><div class="title">Description of integration states</div><p>In Syndesis, in the list of integration versions, each entry indicates the state of that version, which is one of the following:</p></div><table class="tableblock frame-all grid-all stretch"><colgroup><col style="width:50%"><col style="width:50%"></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>State</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Description</strong></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Running</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">A <strong>Running</strong> version is executing; it is in service. Only one version of an integration can be running. That is, only one version at a time can be in the <strong>Running</strong> state.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Stopped</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">A <strong>Stopped</strong> version is not running. The draft version of an integration is in the <strong>Stopped</strong> state. Each integration that was running at one time and then stopped is in the <strong>Stopped</strong> state.</p><p class="tableblock">If no version of this integration is in the <strong>Running</strong> state, then you can start a version that is stopped.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Pending</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">A <strong>pending</strong> version is in transition. Syndesis is in the process of either starting this version of the integration or stopping this version of the integration, but the integration is not yet running or stopped.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Error</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">An integration version that is in the <strong>Error</strong> state encountered an OpenShift error while being started or while running. The error suspended start-up or execution. If this happens, try starting an earlier integration version that ran correctly. Alternatively, contact technical support for help. To do that, in any Syndesis page, in the upper right, click the <span class="image"><img src="images/tutorials/InfoIcon.png" alt="InfoIcon" title="Help"></span>icon and select <strong>Support</strong>.</p></td></tr></tbody></table></div><div class="sect2"><h3 id="putting-integrations-into-service_manage">Putting integrations into and out of service</h3><div class="paragraph"><p>After you create an integration, you can save it as a draft or publish it to start running it. When you publish an integration, Syndesis assembles the needed resources, builds the integration runtime, deploys the OpenShift pod that will run the integration, and then starts running the integration.</p></div><div class="paragraph"><p>At any time, you can click a button to stop running the integration. When you want to start the integration again, Syndesis already has what it needs so starting it takes less time than when you published it to run it for the first time.</p></div><div class="paragraph"><p>The process of starting a version of an integration for the first time is referred to as publishing the integration. The following topics provide details:</p></div><div class="ulist"><ul><li><p><a href="#publishing-integrations_service">About publishing integrations</a></p></li><li><p><a href="#stopping-integrations_service">Stopping integrations</a></p></li><li><p><a href="#starting-integrations_service">Starting integrations</a></p></li><li><p><a href="#restarting-older-integration-versions_service">Restarting older integration versions</a></p></li></ul></div><div class="sect3"><h4 id="publishing-integrations_service">About publishing integrations</h4><div class="paragraph"><p>To run a version of an integration for the first time, you publish it. Publishing an integration builds and deploys the integration runtime. The integration starts running. After publishing an integration, you can stop it and restart it. Exactly one version of an integration can be running at one time.</p></div><div class="paragraph"><div class="title">Alternatives for publishing</div><p>To run an integration for the first time, publish it by doing one of the following:</p></div><div class="ulist"><ul><li><p>At the end of the procedure in which you create or edit the integration, in the upper right, click <strong>Publish</strong>.</p></li><li><p>Publish the draft version of an integration:</p><div class="olist arabic"><ol class="arabic"><li><p>In the left Syndesis panel, click <strong>Integrations</strong>.</p></li><li><p>In the list of integrations, to the right of the draft entry, click <span class="image"><img src="images/tutorials/ThreeVerticalDotsKebab.png" alt="Three Vertical Dots"></span>and select <strong>Publish</strong>.</p></li></ol></div></li></ul></div><div class="paragraph"><div class="title">About the publication progress</div><p>Syndesis displays the progress of the publication process, which has several stages:</p></div><div class="olist arabic"><ol class="arabic"><li><p><strong>Assembling</strong> creates pod resources needed to build the integration.</p></li><li><p><strong>Building</strong> gets the integration ready to deploy.</p></li><li><p><strong>Deploying</strong> waits for deployment of the pod that will run the integration.</p></li><li><p><strong>Starting</strong> waits for the pod to start running the integration.</p></li><li><p><strong>Deployed</strong> indicates that the integration is running.</p></li></ol></div><div class="paragraph"><p>During start-up, you can click <strong>View Logs</strong> to display OpenShift logs that provide start-up information.</p></div><div class="paragraph"><div class="title">Integration status after publication</div><p>When publishing the integration is complete, the <strong>Running</strong> status appears next to the integration name. The pod is running the integration.</p></div></div><div class="sect3"><h4 id="stopping-integrations_service">Stopping integrations</h4><div class="paragraph"><p>Each integration can have exactly one version that is running. A running version is in the <strong>Running</strong> state. At any time, you can stop running an integration.</p></div><div class="paragraph"><div class="title">Prerequisite</div><p>The integration that you want to stop is in the <strong>Running</strong> state.</p></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the left Syndesis panel, click <strong>Integrations</strong>.</p></li><li><p>In the list of integrations, identify the entry for the integration that you want to stop running. The entry shows that this integration is <strong>Running</strong>.</p></li><li><p>On the far right of this integration&#8217;s entry, click <span class="image"><img src="images/tutorials/ThreeVerticalDotsKebab.png" alt="Kebab"></span>and select <strong>Stop</strong>.</p></li></ol></div><div class="paragraph"><div class="title">Result</div><p>Syndesis stops running the integration. <strong>Stopping</strong> and then <strong>Stopped</strong> appears in the integration&#8217;s entry in the list of integrations.</p></div></div><div class="sect3"><h4 id="starting-integrations_service">Starting integrations</h4><div class="paragraph"><p>The first time that you start an integration, the process is referred to as publishing the integration because Syndesis has to build the integration runtime before it can run the integration. At any time, you can stop running an integration and then start it again.</p></div><div class="paragraph"><div class="title">Prerequisite</div><p>The integration that you want to start is in the <strong>Stopped</strong> state.</p></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the left navigation panel, click <strong>Integrations</strong>.</p></li><li><p>In the list of integrations, on the right of the entry for the integration that you want to start, click <span class="image"><img src="images/tutorials/ThreeVerticalDotsKebab.png" alt="Kebab"></span>.</p></li><li><p>Select <strong>Start</strong>.</p></li></ol></div><div class="paragraph"><div class="title">Result</div><p>Syndesis displays <strong>Starting</strong> as the status of that integration version, and then <strong>Running</strong> when the integration is running again.</p></div></div><div class="sect3"><h4 id="restarting-older-integration-versions_service">Restarting older integration versions</h4><div class="paragraph"><p>You might publish an integration that does not work the way you want it to. In this situation, you can stop the incorrect version and replace it with a version that you published previously and that runs correctly.</p></div><div class="ulist"><div class="title">Prerequisites</div><ul><li><p>A version of the integration is running but you want to stop it.</p></li><li><p>You have another version of the integration and you want to run that one.</p></li></ul></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the left panel, click <strong>Integrations</strong> to display a list of the the integrations in this environment.</p></li><li><p>Click the entry for the integration for which you want to publish an older version. Syndesis displays a list of the versions of the integration.</p></li><li><p>In the entry for the version that is running, at the far right, click <span class="image"><img src="images/tutorials/ThreeVerticalDotsKebab.png" alt="Kebab"></span>and select <strong>Stop</strong>.</p></li><li><p>Click <strong>OK</strong> to confirm that you want to stop running this version.</p></li><li><p>Wait for <strong>Stopped</strong> to appear to the right of the integration name near the top of the page.</p></li><li><p>To publish the older version as is, skip to the next step. Or, before you publish the older version, you can update it:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>In the entry for the integration version that you want to update, at the far right, click <span class="image"><img src="images/tutorials/ThreeVerticalDotsKebab.png" alt="Kebab"></span>and select <strong>Replace Draft</strong>.</p></li><li><p>Update the integration as needed.</p></li><li><p>When updates are complete, in the upper right, click <strong>Publish</strong>, and then click <strong>Publish</strong> to confirm. This takes the place of the next two steps.</p></li></ol></div></li><li><p>To publish the older version as is, in the entry for the integration version that you want to start running again, at the far right, click <span class="image"><img src="images/tutorials/ThreeVerticalDotsKebab.png" alt="Kebab"></span>and select <strong>Start</strong>.</p></li><li><p>Click <strong>Start</strong> to confirm that you want to start this version of the integration.</p></li></ol></div><div class="paragraph"><div class="title">Result</div><p>Syndesis starts the integration, which takes a few minutes. When the integration is running, then <strong>Running version <em>n</em></strong> appears to the right of the integration&#8217;s name.</p></div></div></div><div class="sect2"><h3 id="add-log-step_manage">Logging information about integration execution</h3><div class="paragraph"><p>For each execution of an integration, for each step in a flow, Syndesis provides the following activity information:</p></div><div class="ulist"><ul><li><p>The date and time that the step was executed</p></li><li><p>How long it took to execute the step</p></li><li><p>Whether execution was successful</p></li><li><p>The error message if execution was not successful</p></li></ul></div><div class="paragraph"><p>To view this information in Syndesis, display the integration&#8217;s summary and then click the <strong>Activity</strong> tab.</p></div><div class="paragraph"><p>To obtain further details about integration execution, you can log information about the messages that an integration processes by adding a log step to an integration flow. For each message that an integration receives, a log step can provide one or more of the following:</p></div><div class="ulist"><ul><li><p>The message&#8217;s context, which provides metadata about the message, including the message&#8217;s header.</p></li><li><p>The message&#8217;s body, which provides the content of the message.</p></li><li><p>Text that you specify either explicitly or through evaluation of an <a href="http://camel.apache.org/simple.html">Apache Camel Simple language</a> expression.</p></li></ul></div><div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content"><div class="paragraph"><p>The Log connection that was available in previous releases is no longer available to be added to integrations. Add a log step instead of a log connection.</p></div></td></tr></table></div><div class="ulist"><div class="title">Prerequisites</div><ul><li><p>You are creating or editing a flow and Syndesis is prompting you to add to the integration. Or, Syndesis is prompting you to choose a finish connection.</p></li></ul></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the flow visualization, click the plus sign where you want to add a log step. Skip this step if Syndesis is prompting you to choose a finish connection.</p></li><li><p>Click <strong>Log</strong>.</p></li><li><p>On the <strong>Configure Log Step</strong> page, select the content that you want to log. If you select <strong>Custom Text</strong>, then in the text input field, enter one of the following:</p><div class="ulist"><ul><li><p>The text that you want to log</p></li><li><p>A Camel Simple language expression</p></li></ul></div><div class="paragraph"><p>If you enter an expression, Syndesis resolves the expression and logs the resulting text.</p></div></li><li><p>When log step configuration is complete, click <strong>Next</strong> to add the step to the flow.</p></li></ol></div><div class="paragraph"><div class="title">Next step</div><p>When the flow is complete, publish the integration to start seeing output from the new log step.</p></div><div class="paragraph"><div class="title">Additional resources</div><p>After a flow that has a log step has been executed, output from the log step appears in the integration&#8217;s <strong>Activity</strong> tab. See <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#viewing-integration-activity-information_monitor">Viewing integration activity information</a>.</p></div></div><div class="sect2"><h3 id="monitoring-integrations_manage">Monitoring integrations</h3><div class="paragraph"><p>Syndesis provides various ways for you to monitor the execution of your integrations. See:</p></div><div class="ulist"><ul><li><p><a href="#viewing-integration-history_monitor">Viewing integration history</a></p></li><li><p><a href="#viewing-integration-activity-information_monitor">Viewing information about an integration&#8217;s activity</a></p></li><li><p><a href="#viewing-integration-metrics_monitor">Viewing metrics for a particular integration</a></p></li><li><p><a href="#viewing-system-metrics_monitor">Viewing metrics for a Syndesis environment</a></p></li></ul></div><div class="sect3"><h4 id="viewing-integration-history_monitor">Viewing integration history</h4><div class="paragraph"><p>Syndesis maintains each version of an integration. You can always view a list of the versions of each integration.</p></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the left panel, click <strong>Integrations</strong> to display a list of the integrations in your environment.</p></li><li><p>At the right of the entry for the integration whose versions you want to see, click <strong>View</strong>.</p></li></ol></div><div class="paragraph"><div class="title">Result</div><p>In the page that appears, the <strong>History</strong> section lists the versions of the integration. The <span class="image"><img src="images/tutorials/GreenCircleCheckmark.png" alt="Current Version"></span>icon identifies the current version, which is the most recently, successfully running version. For each version, you can also see the date on which it was last started.</p></div><div class="paragraph"><p>To edit, start, or stop a particular version, click the <span class="image"><img src="images/tutorials/ThreeVerticalDotsKebab.png" alt="Kebab"></span>to the right of the version&#8217;s entry. Select the operation that you want to perform.</p></div></div><div class="sect3"><h4 id="viewing-integration-activity-information_monitor">Viewing information about an integration&#8217;s activity</h4><div class="paragraph"><p>Syndesis provides activity information for each execution of an integration. This information is part of the integration&#8217;s log. For each step in a flow, Syndesis provides:</p></div><div class="ulist"><ul><li><p>The date and time that the step was executed</p></li><li><p>How long it took to execute the step</p></li><li><p>Whether execution was successful</p></li><li><p>The error message if execution was not successful</p></li></ul></div><div class="paragraph"><p>At any time, you can view this information.</p></div><div class="ulist"><div class="title">Prerequisites</div><ul><li><p>There is or was a running integration for which you want to view activity information.</p></li><li><p>This integration has been executed at least once.</p></li></ul></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the left panel, click <strong>Integrations</strong>.</p></li><li><p>At the right of the entry for the integration for which you want to view activity information, click <strong>View</strong>.</p></li><li><p>In the integration&#8217;s summary page, click the <strong>Activity</strong> tab.</p></li><li><p>Optionally, enter date and/or keyword filters to limit the executions listed.</p></li><li><p>Click the integration execution for which you want to view activity information.</p></li></ol></div><div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content"><div class="paragraph"><p>For an API Provider integration or a webhook step, the information in the integrations <strong>Activity</strong> tab reflects the communication between the Syndesis integration and the client that invokes it. Errors generated by HTTP or REST requests are not visible in the integrations <strong>Activity</strong> log. If you want to view or test the errors generated by HTTP or REST requests, when you configure the API Provider or the webhook step, check the <strong>Include error message in the return body</strong> option (checked by default). Then, you can verify whether the error message is included in the response by checking the HTTP or REST header in the response to the caller. You can also check the integration pods log file for <code>INFO</code> messages.</p></div></td></tr></table></div><div class="ulist"><div class="title">Additional resources</div><ul><li><p>To obtain additional information between any two steps, you can add a log step to the integration. A log step provides information about each message it receives and can provide custom text that you specify. If you add a log step, then it appears as one of the integration&#8217;s steps when you expand the integration execution that you want to view activity information for. You view Syndesis information for a log step in the same way that you view Syndesis information for any other step. See <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#add-log-step_manage">Logging information about integration execution</a>.</p></li></ul></div></div><div class="sect3"><h4 id="viewing-integration-metrics_monitor">Viewing metrics for a particular integration</h4><div class="paragraph"><p>Syndesis provides the following metrics for each integration:</p></div><div class="ulist"><ul><li><p><strong>Total Errors</strong> indicates the number of runtime errors that all executions of this integration encountered during the past 30 days.</p></li><li><p><strong>Last Processed</strong> displays the most recent date and time that this integration processed a message. The message might have been successfully processed or there might have been an error.</p></li><li><p><strong>Total Messages</strong> is the number of messages that all executions of this integration processed in the last 30 days. This includes message failures.</p></li><li><p><strong>Uptime</strong> indicates when this integration started running and how long it has been running without an error.</p></li></ul></div><div class="paragraph"><div class="title">Prerequisite</div><p>The integration that you want to view metrics for is running or has been running.</p></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the left panel, click <strong>Integrations</strong>.</p></li><li><p>At the right of the entry for the integration for which you want to view metrics, click <strong>View</strong>.</p></li><li><p>In the integration&#8217;s summary page, click <strong>Metrics</strong>.</p></li></ol></div></div><div class="sect3"><h4 id="viewing-system-metrics_monitor">Viewing metrics for a Syndesis environment</h4><div class="paragraph"><p>Metrics for your Syndesis environment appear on the Syndesis home page.</p></div><div class="paragraph"><div class="title">Procedure</div><p>In the left panel, click <strong>Home</strong>.</p></div><div class="paragraph"><div class="title">Results</div><p>Syndesis updates the following metrics every 5 seconds:</p></div><div class="ulist"><ul><li><p>The number of integrations that are defined in this environment as well as the number of integrations that are running, the number of integrations that are stopped, and the number of integrations that are pending. Syndesis is either stopping or starting pending integrations. A red cross indicates any integrations that were running but that encountered an error that suspended execution.</p></li><li><p>The number of connections that are defined in this environment.</p></li><li><p>Total number of messages that have been processed by integrations in this environment in the last 30 days. This includes messages that were processed by integrations that might no longer be running or that might have been deleted from this environment.</p></li><li><p>Uptime indicates how long there has been at least one integration that is running. The date and time when uptime started appears as well.</p></li></ul></div></div></div><div class="sect2"><h3 id="testing-integrations_manage">Testing integrations</h3><div class="paragraph"><p>After you create an integration and it is running correctly in a Syndesis development environment, you might want to run it in a different Syndesis environment to test it.</p></div><div class="ulist"><div class="title">Prerequisite</div><ul><li><p>You have a Syndesis development environment and a Syndesis test environment.</p></li><li><p>You have an integration that is running correctly in your Syndesis development environment.</p></li></ul></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>Learn about <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#about-copying-integrations_copy">copying an integration to another environment</a>.</p></li><li><p>Export the integration from the development environment. See <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#exporting-integrations_copy">Exporting an integration</a>.</p></li><li><p>Import the integration into the test environment. See <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#importing-integrations_copy">Importing an integration</a>.</p></li></ol></div></div><div class="sect2"><h3 id="troubleshooting-integration-execution_manage">Tips for troubleshooting integration execution</h3><div class="paragraph"><p>If an integration stops working, check its activity and history details. See <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#viewing-integration-activity-information_monitor">Viewing integration activity information</a> and <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#viewing-integration-history_monitor">Viewing integration history</a>.</p></div><div class="paragraph"><div class="title">Insufficient memory for integrations</div><p>If the Syndesis Operator logs shows that an integration&#8217;s status is <code>not ready</code> or if an integration&#8217;s pod events report insufficient memory, you might need to edit the integration&#8217;s deployment configuration as described in <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#adjusting-integration-configuration_monitor">Adjusting the memory and CPU configuration attributes for an integration</a>.</p></div><div class="paragraph"><div class="title">Connection to an application that uses OAuth</div><p>For a connection to an application that uses OAuth, you might see an error message that indicates that the access token for the application has expired. Sometimes, you might get a less explicit <code>403 - Access denied</code> message. The information in the message depends on the application that the integration is connecting to. In this situation, try reconnecting to the application and then republishing the integration:</p></div><div class="olist arabic"><ol class="arabic"><li><p>In the left panel, click <strong>Integrations</strong>.</p></li><li><p>In the list of integrations, at the right of the entry for the integration that stopped running, click <strong>View</strong>.</p></li><li><p>In the integration&#8217;s summary page, in the flow visualization, click the icon for the application that you want to reconnect to.</p><div class="paragraph"><p>If this is an API provider integration, then in the integration&#8217;s summary page, click its flow icon to display the operations list. Then click the operation whose path contains the connection that is failing and then click the failing connection in the operation&#8217;s path visualization.</p></div></li><li><p>In the connection&#8217;s details page, click <strong>Reconnect</strong>.</p></li><li><p>Respond to that application&#8217;s OAuth workflow prompts.</p><div class="paragraph"><p>Syndesis displays a message to indicate that its access to that application has been authorized. For some applications, this takes a few seconds but it can take longer for other applications.</p></div></li><li><p>After reconnecting to the application, start the integration.</p></li></ol></div><div class="paragraph"><p>If reconnection is not successful, try this:</p></div><div class="olist arabic"><ol class="arabic"><li><p>Re-register Syndesis as a client of the application. See <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#general-procedure-for-obtaining-authorization_connections">General procedure for obtaining authorization</a>.</p></li><li><p>Create a new connection.</p></li><li><p>Edit each integration that was using the old connection:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Remove the old connection.</p></li><li><p>Replace it with the new connection.</p></li></ol></div></li><li><p>Publish each updated integration.</p></li></ol></div></div><div class="sect2"><h3 id="updating-integrations_manage">Updating integrations</h3><div class="paragraph"><p>After you create an integration, you might need to update it to add, edit or remove a step.</p></div><div class="paragraph"><div class="title">Prerequisite</div><p>In your Syndesis environment, there is a version of the integration that you want to update.</p></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the left Syndesis panel, click <strong>Integrations</strong>.</p></li><li><p>In the list of integrations, click <strong>View</strong> for the integration that you want to update.</p></li><li><p>On the integration&#8217;s summary page, in the upper right corner, click <strong>Edit Integration</strong>.</p><div class="paragraph"><p>If this is a simple integration, Syndesis displays the integration&#8217;s flow. If this is an API provider integration, Syndesis displays the operations list. To update the flow for a particular operation, click <strong>Edit flow</strong> on the right of that operation to display its flow.</p></div></li><li><p>Update the flow as needed:</p><div class="ulist"><ul><li><p>To add a step, in the flow visualization, click the plus sign that is where you want to add the step. Then click the card that represents the step that you want to add.</p></li><li><p>To delete a step, in the flow visualization, click <span class="image"><img src="images/integrating-applications/TrashIcon.png" alt="TrashIcon" title="Delete"></span>on the step that you want to delete.</p></li><li><p>To change the configuration of a step, in the flow visualization, click <strong>Configure</strong> on the step that you want to update. In the configuration page, update the parameter settings as needed.</p></li></ul></div></li></ol></div></div><div class="sect2"><h3 id="adjusting-integration-configuration_manage">Adjusting the memory and CPU configuration attributes for an integration</h3><div class="paragraph"><p>You can specify custom values for a specific integration&#8217;s CPU and memory by editing the integration&#8217;s deployment configuration object. You might want to adjust the memory and CPU configuration attributes for an integration, for example, if the integration requires more memory than its default allocation.</p></div><div class="ulist"><div class="title">Prerequisite</div><ul><li><p>The Red Hat OpenShift <code>oc</code> client tool is installed and it is connected to the OCP cluster in which Syndesis is installed.</p></li><li><p>A user with cluster administration permissions gave you <code>admin</code> permission for the project that contains the integration that you want to configure.</p></li></ul></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>Log in to OpenShift with an account that has <code>admin</code> permission for the OpenShift project that contains the Syndesis integration. For example:</p><div class="paragraph"><p><code><strong>oc login -u admin -p admin</strong></code></p></div></li><li><p>Switch to the project that contains the Syndesis integration. For example:</p><div class="paragraph"><p><code><strong>oc project my-fuse-online-project</strong></code></p></div></li><li><p>Edit the integration&#8217;s deployment configuration object:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Enter the following command, which typically opens the resource in an editor:</p><div class="paragraph"><p><code><strong>oc edit deploymentconfig &lt;i-integration-name&gt;</strong></code></p></div><div class="paragraph"><p>For example, if the integration&#8217;s name is <code>my-integration</code>, type this command:</p></div><div class="paragraph"><p><code><strong>oc edit deploymentconfig i-my-integration</strong></code></p></div></li><li><p>Edit the configuration by setting <code>spec.containers.resources</code> to specify values for CPU and memory as shown in the following example:</p><div class="listingblock"><div class="content"><pre class="nowrap">spec:
  containers:
    resources:
      limits:
        cpu: 350m
    requests:
        memory: 350Mi</pre></div></div></li><li><p>Save the configuration.</p></li></ol></div></li></ol></div><div class="paragraph"><div class="title">Results</div><p>After you save your changes, the integration&#8217;s pod restarts and the new pod runs with the new values. For example, if you run the <code>oc describe &lt;intergration-pod-name&gt;</code> command (where you replace &lt;intergration-pod-name&gt; with the name of the integration pod, for example <code>i-my-integration</code>), the command returns the new values, such as:</p></div><div class="listingblock"><div class="content"><pre class="nowrap">    resources:
      limits:
        cpu: 350m
      requests:
        cpu: 350m
        memory: 350Mi</pre></div></div><div class="paragraph"><p>These values persist even after you publish a new version of the integration.</p></div></div><div class="sect2"><h3 id="deleting-integrations_manage">Deleting integrations</h3><div class="paragraph"><p>After you delete an integration, Syndesis still has the history of that integration. If you import a version of the deleted integration, then Syndesis associates the history of the deleted integration with the imported integration.</p></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the left Syndesis panel, click <strong>Integrations</strong>.</p></li><li><p>In the list of integrations, at the right of the entry for the integration that you want to delete, click <span class="image"><img src="images/tutorials/ThreeVerticalDotsKebab.png" alt="Three Vertical Dots"></span>and select <strong>Delete</strong>.</p></li><li><p>In the popup, click <strong>OK</strong> to confirm that you want to delete the integration.</p></li></ol></div></div><div class="sect2"><h3 id="copying-integrations-to-other-environments_manage">Copying an integration to another environment</h3><div class="paragraph"><p>To run integrations across development, staging and production environments, you can export and import integrations. The environments can all be on a single OpenShift cluster, or they can be spread out across multiple OpenShift clusters.</p></div><div class="paragraph"><p>The procedures described here instruct you to export and import integrations in the Syndesis console.</p></div><div class="paragraph"><p>See the following topics:</p></div><div class="ulist"><ul><li><p><a href="#about-copying-integrations_copy">About copying integrations</a></p></li><li><p><a href="#exporting-integrations_copy">Exporting integrations</a></p></li><li><p><a href="#importing-integrations_copy">Importing integrations</a></p></li></ul></div><div class="sect3"><h4 id="about-copying-integrations_copy">About copying integrations</h4><div class="paragraph"><p>Each Syndesis installation is an environment from which you can export an integration. Exporting an integration downloads a zip file that contains the information needed to recreate the integration in a different Syndesis environment.</p></div><div class="paragraph"><p>In an environment, each integration can have only one <strong>Draft</strong> version.</p></div><div class="paragraph"><p>The result of importing an integration depends on:</p></div><div class="ulist"><ul><li><p>Whether the integration was previously imported</p></li><li><p>Whether a connection that the integration uses was previously imported</p></li></ul></div><div class="paragraph"><p>Syndesis uses an internal identifier for each integration and each connection to determine whether it already exists in the environment that it is being imported into. If you change the name of an integration or connection, Syndesis recognizes it as the same integration or connection, which just has a different name.</p></div><div class="paragraph"><p>The following table describes the possible results of importing an integration:</p></div><table class="tableblock frame-all grid-all stretch"><colgroup><col style="width:50%"><col style="width:50%"></colgroup><thead><tr><th class="tableblock halign-left valign-top">In the importing environment:</th><th class="tableblock halign-left valign-top">What the import operation does:</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">The integration has not been previously imported.</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Creates the integration. The integration is in the <strong>Draft</strong> state.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">The integration has been previously imported.</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Syndesis updates the integration. The updated integration is in the <strong>Draft</strong> state. If there was a <strong>Draft</strong> version of this integration, it is lost.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">The imported integration uses a connection that did not exist in the environment before the import operation.</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Syndesis creates a connection that has the same settings except for secrets. You must review each new connection. If a connection is not completely configured for its new environment then you must add the missing settings. For example, you might need to obtain secret settings by registering this Syndesis environment as a client of the application that this connection accesses.</p></td></tr></tbody></table></div><div class="sect3"><h4 id="exporting-integrations_copy">Exporting integrations</h4><div class="paragraph"><p>When Syndesis exports an integration it downloads a zip file to your local <code>Downloads</code> folder. This zip file contains the information needed to recreate the integration in a different Syndesis environment.</p></div><div class="paragraph"><p>Exporting an integration is also a way to have a backup of the integration. However, Syndesis maintains the versions of an integration so exporting an integration is not required for having a backup copy.</p></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the left panel of Syndesis, click <strong>Integrations</strong>.</p></li><li><p>In the list of integrations, identify the entry for the integration that you want to export.</p></li><li><p>At the right of the entry, click <span class="image"><img src="images/tutorials/ThreeVerticalDotsKebab.png" alt="Three Vertical Dots"></span>and select <strong>Export</strong>.</p></li></ol></div><div class="paragraph"><div class="title">Next step</div><p>To import the integration into another Syndesis environment, open that environment and import the exported zip file.</p></div></div><div class="sect3"><h4 id="importing-integrations_copy">Importing integrations</h4><div class="paragraph"><p>In a Syndesis environment, you can import an integration that was exported from another Syndesis environment. Exporting an integration downloads the zip file that you upload to import the integration.</p></div><div class="ulist"><div class="title">Prerequisites</div><ul><li><p>You have a zip file that contains an integration that was exported from another Syndesis environment.</p></li></ul></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>Open the Syndesis environment that you want to import the integration into.</p></li><li><p>In the left panel, click <strong>Integrations</strong>.</p></li><li><p>In the upper right, click <strong>Import</strong>.</p></li><li><p>Drag and drop one or more exported integration zip files, or navigate to a zip file that contains an exported integration and select it.</p><div class="paragraph"><p>Syndesis imports the file(s) and display a message when importing is successful.</p></div></li><li><p>In the left panel, click <strong>Integrations</strong>.</p></li><li><p>In the list of integrations, on the entry for the integration that you just imported, click <strong>View</strong>.</p></li><li><p>In the integration summary, if there is a notification that configuration is required, in the upper right, click <strong>Edit integration</strong>.</p></li><li><p>For each connection that requires configuration:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Click its <strong>Configure</strong> button to display its details.</p></li><li><p>Enter or change connection details as needed. It is possible that every field on this page is correct and that only security configuration is required.</p></li><li><p>Click <strong>Next</strong>.</p></li></ol></div></li><li><p>In the left panel, click <strong>Settings</strong>.</p><div class="paragraph"><p>The <strong>Settings</strong> page displays entries for applications that use the OAuth protocol.</p></div></li><li><p>For each connection that requires configuration and that accesses an application that uses the OAuth protocol, register your Syndesis environment with the application. The steps vary for each application. See the appropriate topic:</p><div class="ulist"><ul><li><p><a href="https://zregvart.github.io/syndesis.io/manual/connecting/#register-with-dropbox_dropbox">Registering with Dropbox</a></p></li><li><p><a href="https://zregvart.github.io/syndesis.io/manual/connecting/#register-with-google_google">Registering with Google</a></p></li><li><p><a href="https://zregvart.github.io/syndesis.io/manual/connecting/#registering-with-jira_jira">Registering with Jira</a></p></li><li><p><a href="https://zregvart.github.io/syndesis.io/manual/connecting/#register-with-rest-api_rest">Registering with a REST API</a></p></li><li><p><a href="https://zregvart.github.io/syndesis.io/manual/connecting/#register-with-salesforce_salesforce">Registering with Salesforce</a></p></li><li><p><a href="https://zregvart.github.io/syndesis.io/manual/connecting/#connecting-to-concur_connectors">Connecting to SAP Concur</a></p></li><li><p><a href="https://zregvart.github.io/syndesis.io/manual/connecting/#register-with-twitter_twitter">Registering with Twitter</a></p></li></ul></div></li><li><p>In the left panel, click <strong>Connections</strong> and confirm that there are no longer any connections that require configuration.</p></li><li><p>In the left panel, click <strong>Integrations</strong>. In the list of integrations, imported integrations have a green triangle in the upper left corner of their entries.</p></li><li><p>In the list of integrations, at the right of the entry for the integration that you imported, click <span class="image"><img src="images/tutorials/ThreeVerticalDotsKebab.png" alt="Three Vertical Dots"></span>and select <strong>Edit</strong>.</p></li><li><p>In the upper right, click <strong>Save</strong> or, if you want to start running the imported integration, click <strong>Publish</strong>. Regardless of whether you save the integration as a draft or you publish the integration, Syndesis updates the integration to use the updated connections.</p></li></ol></div></div></div></div></div><div class="sect1"><h2 id="customizing_ug">Customizing Syndesis</h2><div class="sectionbody"><div class="paragraph"><p>Syndesis provides many connectors that you can use to connect to common applications and services. There are also a number of built-in steps for processing data in common ways. However, if Syndesis does not provide a feature that you need, talk with a developer about your requirements. An experienced developer can help you customize integrations by providing any of the following:</p></div><div class="ulist"><ul><li><p>An OpenAPI document that Syndesis can use to create a connector for a REST API client.</p><div class="paragraph"><p>You upload this schema to Syndesis and Syndesis creates a connector according to the schema. You then use the connector to create a connection that you can add to an integration. For example, many retail web sites provide a REST API client interface that a developer can capture in an OpenAPI document.</p></div></li><li><p>An OpenAPI document that defines a REST API service.</p><div class="paragraph"><p>You upload this schema to Syndesis. Syndesis makes the API service available and provides the URL for API calls. This lets you <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#trigger-integrations-with-api-calls_ug">trigger integration execution with an API call</a>.</p></div></li><li><p>A WSDL file that Syndesis can use to create a connector for a SOAP client.</p><div class="paragraph"><p><strong>Note:</strong> This is a Technology Preview feature.</p></div></li><li><p>A <code>JAR</code> file that implements a Syndesis extension. An extension can be any one of the following:</p><div class="ulist"><ul><li><p>One or more steps that operate on integration data between connections</p></li><li><p>A connector for an application or service</p></li><li><p>A library resource such as a JDBC driver for a proprietary SQL database</p><div class="paragraph"><p>You upload this <code>JAR</code> file to Syndesis and Syndesis makes the custom feature provided by the extension available.</p></div></li></ul></div></li></ul></div><div class="paragraph"><p>See the following topics for details:</p></div><div class="ulist"><ul><li><p><a href="#developing-rest-api-client-connectors_custom">Developing REST API client connectors</a></p></li><li><p><a href="#adding-api-connectors_custom">Adding and managing API client connectors</a></p></li><li><p><a href="#developing-extensions_custom">Developing Syndesis extensions</a></p></li><li><p><a href="#adding-extensions_custom">Adding and managing extensions</a></p></li></ul></div><div class="sect2"><h3 id="developing-rest-api-client-connectors_custom">Developing REST API client connectors</h3><div class="paragraph"><p>Syndesis can create connectors for Representational State Transfer Application Programming Interfaces (REST APIs) that support Hypertext Transfer Protocol (HTTP). To do this, Syndesis requires a valid OpenAPI 3 (or 2) document that describes a REST API that you want to connect to. If the API service provider does not make an OpenAPI document available then an experienced developer must create the OpenAPI document.</p></div><div class="paragraph"><p>The following topics provide information and instructions for developing REST API connectors:</p></div><div class="ulist"><ul><li><p><a href="#about-api-client-connectors_dev-client-connector">Requirements for REST API client connectors</a></p></li><li><p><a href="#guidelines-for-openapi-documents_dev-client-connector">Guidelines for OpenAPI schemas for REST API client connectors</a></p></li><li><p><a href="#providing-client-credentials_dev-client-connector">Provide client credentials in parameters</a></p></li><li><p><a href="#refreshing-access-tokens_dev-client-connector">Automatically refresh access tokens</a></p></li></ul></div><div class="sect3"><h4 id="about-api-client-connectors_dev-client-connector">Requirements for REST API client connectors</h4><div class="paragraph"><p>After you upload an OpenAPI schema to Syndesis, a connector to the REST API becomes available. You can select the connector to create a REST API client connection. You can then create a new integration and add the REST API client connection, or you can edit an existing integration to add the REST API client connection.</p></div><div class="paragraph"><p>Syndesis connectors support OAuth 2.0, HTTP basic authorization, and API keys. If access to the REST API requires Transport Layer Security (TLS) then the API needs to use a valid certificate that is issued by a recognized Certificate Authority (CA).</p></div><div class="paragraph"><p>A REST API that uses OAuth must have an authorization URL that takes a client callback URL as input. After Syndesis creates the connector and before you use the connector to create a connection, you must visit that URL to register your Syndesis environment as a client of the REST API. This authorizes your Syndesis environment to access the REST API. As part of registration, you provide the Syndesis callback URL. The details for doing this are described in <a href="https://zregvart.github.io/syndesis.io/manual/connecting/#register-with-rest-api_rest">Connecting to Applications and Services, Registering Syndesis as a REST API client</a>.</p></div><div class="paragraph"><p>For a REST API that uses OAuth, Syndesis supports only the <strong>Authorization Code</strong> grant flow for obtaining authorization. In the OpenAPI document that you upload to create the connector, in the OAuth <code>securityDefinitions</code> object, you must set the <code>flow</code> attribute to <code>accessCode</code>, for example:</p></div><div class="listingblock"><div class="content"><pre>securityDefinitions:
  OauthSecurity:
    type: oauth2
    flow: accessCode
    authorizationUrl: 'https://oauth.simple.api/authorization'
    tokenUrl: 'https://oauth.simple.api/token'</pre></div></div><div class="paragraph"><p>You must not set <code>flow</code> to <code>implicit</code>, <code>password</code>, or <code>application</code>.</p></div><div class="paragraph"><p>The OpenAPI schema for a REST API client connector cannot have cyclic schema references. For example, a JSON schema that specifies a request or response body cannot reference itself as a whole nor reference any part of itself through any number of intermediate schemas.</p></div><div class="paragraph"><p>Syndesis cannot create connectors for REST APIs that support the HTTP 2.0 protocol.</p></div></div><div class="sect3"><h4 id="guidelines-for-openapi-documents_dev-client-connector">Guidelines for OpenAPI schemas for REST API client connectors</h4><div class="paragraph"><p>When Syndesis creates a REST API client connector, it maps each resource operation in the OpenAPI document to a connection action. The action name and action description come from documentation in the OpenAPI document.</p></div><div class="paragraph"><p>The more detail that the OpenAPI document provides, the more support Syndesis can offer when connecting to the API. For example, the API definition is not required to declare data types for requests and responses. Without type declarations, Syndesis defines the corresponding connection action as typeless. However, in an integration, you cannot add a data mapping step immediately before or immediately after an API connection that performs a typeless action.</p></div><div class="paragraph"><p>One remedy for this is to add more information to the OpenAPI document. Identify the OpenAPI resource operations that will map to the actions you want the API connection to perform. In the OpenAPI document, ensure that there is a YAML or JSON schema that specifies each operation&#8217;s request and response types.</p></div><div class="paragraph"><p>After you upload the schema, Syndesis gives you an opportunity to review and edit it in API Designer, which is a visual editor for designing APIs based on the OpenAPI document. You can add more detail, save your updates, and Syndesis creates an API client connector that incorporates your updates. After Syndesis creates the client connector, you can no longer edit the OpenAPI document. To implement a change, you must create a new client connector.</p></div><div class="paragraph"><p>If the OpenAPI document for the API declares support for <code>application/json</code> content type and also <code>application/xml</code> content type then the connector uses the JSON format. If the OpenAPI document specifies <code>consumes</code> or <code>produces</code> parameters that define both <code>application/json</code> and <code>application/xml</code>, then the connector uses the JSON format.</p></div></div><div class="sect3"><h4 id="providing-client-credentials_dev-client-connector">Provide client credentials in parameters</h4><div class="paragraph"><p>When Syndesis tries to obtain authorization to access an OAuth2 application, it uses HTTP basic authentication to provide client credentials. If you need to, you can change this default behavior so that Syndesis passes client credentials to the provider as parameters instead of using HTTP basic authentication. This affects the use of the <code>tokenUrl</code> endpoint that is used to obtain an OAuth access token.</p></div><div class="paragraph"><p>To specify that Syndesis should pass client credentials as parameters, in the <code>securityDefinitions</code> section of the OpenAPI document, add the <code>x-authorize-using-parameters</code> vendor extension with a setting of <code>true</code>. In the example below, the last line specifies <code>x-authorize-using-parameters</code>:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code>securityDefinitions:
  concur_oauth2:
    type: 'oauth2'
    flow: 'accessCode'
    authorizationUrl: 'https://example.com/oauth/authorize'
    tokenUrl: 'https://example.com/oauth/token'
    scopes:
      LIST: Access List API
    x-authorize-using-parameters: true</code></pre></div></div><div class="paragraph"><p>The setting of the <code>x-authorize-using-parameters</code> vendor extension is <code>true</code> or <code>false</code>:</p></div><div class="ulist"><ul><li><p><code>true</code> indicates that client credentials are in parameters.</p></li><li><p><code>false</code>, the default, indicates that Syndesis uses HTTP basic authentication to provide client credentials.</p></li></ul></div></div><div class="sect3"><h4 id="refreshing-access-tokens_dev-client-connector">Automatically refresh access tokens</h4><div class="paragraph"><p>If an access token has an expiration date, then Syndesis integrations that use that token to connect to an application stop running successfully when the token expires. To obtain a new access token, you must either reconnect to the application or re-register with the application.</p></div><div class="paragraph"><p>If you need to, you can change this default behavior so that Syndesis automatically requests a new access token in the following situations:</p></div><div class="ulist"><ul><li><p>When the expiration date has been reached.</p></li><li><p>When HTTP response status codes that you specify are received.</p></li></ul></div><div class="paragraph"><p>To specify that Syndesis should automatically try to obtain a new access token in the situations described, in the <code>securityDefinitions</code> section of the OpenAPI document, add the <code>x-refresh-token-retry-statuses</code> vendor extension. The setting of this extension is a comma separated list that specifies HTTP response status codes. When an access token&#8217;s expiration date is reached or when Syndesis receives a message from an OAuth2 provider and the message has one of these response status codes, then Syndesis automatically tries to obtain a new access token. In the example below, the last line specifies <code>x-refresh-token-retry-statuses</code>:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code>securityDefinitions:
  concur_oauth2:
    type: 'oauth2'
    flow: 'accessCode'
    authorizationUrl: 'https://example.com/oauth/authorize'
    tokenUrl: 'https://example.com/oauth/token'
    scopes:
      LIST: Access List API
    x-refresh-token-retry-statuses: 401,402,403</code></pre></div></div><div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content"><div class="paragraph"><p>Sometimes, an API operation fails and a side effect of that failure is that the access token is refreshed. In this situation, even when obtaining a new access token is successful, the API operation still fails. In other words, Syndesis does not retry the failed API operation after it receives the new access token.</p></div></td></tr></table></div></div></div><div class="sect2"><h3 id="adding-api-connectors_custom">Adding and managing API client connectors</h3><div class="paragraph"><p>Syndesis can create these API client connectors:</p></div><div class="ulist"><ul><li><p>A REST API client connector from an OpenAPI document. For information about the content of the OpenAPI document, see <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#developing-rest-api-client-connectors_custom">Developing REST API client connectors</a>.</p></li><li><p>A SOAP API client connector from a WSDL file.</p><div class="admonitionblock important"><table><tr><td class="icon"><div class="title">Important</div></td><td class="content">The SOAP API client connector is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production.These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.For more information about the support scope of Red Hat Technology Preview features, see <a href="https://access.redhat.com/support/offerings/techpreview/" class="bare">https://access.redhat.com/support/offerings/techpreview/</a></td></tr></table></div></li></ul></div><div class="paragraph"><p>The following topics provide information and instructions for adding and managing REST API client connectors:</p></div><div class="ulist"><ul><li><p><a href="#creating-rest-api-connectors_add-client-connector">Creating REST API client connectors</a></p></li><li><p><a href="#creating-soap-api-connectors_add-client-connector">Creating SOAP API client connectors</a></p></li><li><p><a href="#updating-api-connectors_add-client-connector">Updating API client connectors by creating new ones</a></p></li><li><p><a href="#deleting-api-connectors_add-client-connector">Deleting API client connectors</a></p></li></ul></div><div class="paragraph"><p>After you create an API client connector, for details about using that connector, see <a href="https://zregvart.github.io/syndesis.io/manual/connecting/#connecting-to-api-clients_connectors">Connecting to Applications and Services, Connecting to API clients</a>.</p></div><div class="sect3"><h4 id="creating-rest-api-connectors_add-client-connector">Creating REST API client connectors</h4><div class="paragraph"><p>Upload an OpenAPI document to enable Syndesis to create a REST API client connector.</p></div><div class="paragraph"><div class="title">Prerequisite</div><p>You have an OpenAPI document for the connector that you want Syndesis to create.</p></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the Syndesis navigation panel, click <strong>Customizations</strong> &gt; <strong>API Client Connectors</strong>. Any API client connectors that are already available are listed here.</p></li><li><p>Click <strong>Create API Connector</strong>.</p></li><li><p>On the <strong>Create API Connector</strong> page, do one of the following:</p><div class="ulist"><ul><li><p>Click in the dotted-line box and select the OpenAPI file that you want to upload.</p></li><li><p>Select <strong>Use a URL</strong> and paste the URL for the OpenAPI document in the input field.</p></li></ul></div></li><li><p>Click <strong>Next</strong>. If there is invalid or missing content, Syndesis displays information about what needs to be corrected. Select a different OpenAPI file to upload or click <strong>Cancel</strong>, revise the OpenAPI file, and upload the updated file.</p><div class="paragraph"><p>If the schema is valid, Syndesis displays a summary of the operations that the connector provides. This might include errors and warnings about the operation definitions.</p></div></li><li><p>If you are satisfied with the summary, click <strong>Next</strong>.</p><div class="paragraph"><p>Or, to revise the OpenAPI document, click <strong>Review/Edit</strong> to open the API Designer editor. Update the schema as needed. For details about using the API editor, see <a href="https://access.redhat.com/documentation/en-us/red_hat_fuse/7.7/html-single/designing_apis/index#create-api-definition">Design and develop an API definition with API Designer</a>. When you are done, <strong>Save</strong> your changes to incorporate your updates into the new API client connector. Then click <strong>Next</strong> to continue creating the API client connector.</p></div><div class="paragraph"><p>Sometimes, if you provide a URL for the OpenAPI document, Syndesis can upload it but cannot open it for editing. Typically, this is caused by settings on the files host. To open the schema for editing, Syndesis requires that the file host has:</p></div><div class="ulist"><ul><li><p>An <code>https</code> URL. (An <code>http</code> URL does not work.)</p></li><li><p>Enabled CORS.</p></li></ul></div></li><li><p>Indicate the API&#8217;s security requirements. Syndesis reads the OpenAPI definition to determine the information needed to configure the connector to meet the APIs security requirements. Syndesis can display any of the following:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p><strong>No Security</strong></p></li><li><p><strong>HTTP Basic Authorization</strong> If the API service uses HTTP basic authorization, select this checkbox. Later, when you use this connector to create a connection, Syndesis prompts you to enter a user name and password.</p></li><li><p><strong>OAuth 2.0</strong>  Syndesis prompts you to enter:</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p><strong>Authorization URL</strong> is the location for registering Syndesis as a client of the API. Registration authorizes Syndesis to access the API. See <a href="https://zregvart.github.io/syndesis.io/manual/connecting/#register-with-rest-api_rest">Connecting to Applications and Services, Registering Syndesis as a REST API client</a>. The OpenAPI document or other documentation for the API should specify this URL. If it does not then you must contact the service provider to obtain this URL.</p></li><li><p><strong>Access Token URL</strong> is required for OAuth authorization. Again, the OpenAPI document or other documentation for the API should provide this URL. If it does not then you must contact the service provider.</p></li></ol></div></li><li><p><strong>API Key</strong> If the API service requires an API key, Syndesis prompts for any information that it needs to create the connector. Prompts are based on the OpenAPI definition. For example, you might need to indicate if the API key is in message headers or in query parameters. If the OpenAPI definition specifies API key security, as well as another security type, select the checkbox to indicate that you want to use API key security in connections based on this connector. Later, when you use this connector to create a connection, Syndesis prompts you to enter the value of an API key.</p></li></ol></div></li><li><p>Click <strong>Next</strong>. Syndesis displays the connector&#8217;s name, description, host, and base URL as indicated by the OpenAPI document. For connections that you create from this connector,</p><div class="ulist"><ul><li><p>Syndesis concatenates the host and base URL values to define the endpoint for the connection. For example, if the host is <code>https://example.com</code> and the base URL is <code>/api/v1</code> then the connection endpoint is <code>https://example.com/api/v1</code>.</p></li><li><p>Syndesis applies the OpenAPI document to data mapping steps. If the OpenAPI document supports more than one schema then Syndesis uses the TLS (HTTPS) schema.</p></li></ul></div></li><li><p>Review the connector details and optionally upload an icon for the connector. If you do not upload an icon, Syndesis generates one. You can upload an icon at a later time. When Syndesis displays the flow of an integration, it displays a connector&#8217;s icon to represent connections that are created from that connector.</p></li><li><p>To override a value obtained from the OpenAPI file, edit the field value that you want to change.</p><div class="admonitionblock important"><table><tr><td class="icon"><div class="title">Important</div></td><td class="content">After Syndesis creates a connector, <strong>you cannot change it</strong>. To effect a change, you need to upload an updated OpenAPI document so that Syndesis can create a new connector or you can upload the same schema and then edit it in the API editor. You then continue the process for creating a new API client connector.</td></tr></table></div></li><li><p>When you are satisfied with the connector details, click <strong>Save</strong>. Syndesis displays the new connector in the list of API Client Connectors.</p></li></ol></div><div class="paragraph"><div class="title">Next step</div><p>For details about using your new API connector, see <a href="https://zregvart.github.io/syndesis.io/manual/connecting/#connecting-to-api-clients_connectors">Connecting to Applications and Services, Connecting to API clients</a>.</p></div></div><div class="sect3"><h4 id="creating-soap-api-connectors_add-client-connector">Creating SOAP API client connectors</h4><div class="paragraph"><p>Upload a WSDL file to enable Syndesis to create a SOAP API client connector.</p></div><div class="admonitionblock important"><table><tr><td class="icon"><div class="title">Important</div></td><td class="content">The SOAP API client connector is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production.These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.For more information about the support scope of Red Hat Technology Preview features, see <a href="https://access.redhat.com/support/offerings/techpreview/" class="bare">https://access.redhat.com/support/offerings/techpreview/</a></td></tr></table></div><div class="paragraph"><div class="title">Prerequisite</div><p>You have a WSDL file for the SOAP client connector that you want Syndesis to create.</p></div><div class="paragraph"><p><strong>Note:</strong> For this release, the WSDL files extension (<code>.wsdl</code>) must be lowercase. If the file extension is uppercase (<code>.WSDL</code>) you must rename the file to have a lowercase extension before you import it into Syndesis.</p></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the Syndesis navigation panel, click <strong>Customizations</strong> &gt; <strong>API Client Connectors</strong>. Any API client connectors that are already available are listed here.</p></li><li><p>Click <strong>Create API Connector</strong>.</p></li><li><p>On the <strong>Create API Connector</strong> page, do one of the following:</p><div class="ulist"><ul><li><p>Click in the dotted-line box and select the WSDL (<code>.wsdl</code>) file that you want to upload.</p></li><li><p>Select <strong>Use a URL</strong> and paste the URL for the WSDL (<code>.wsdl</code>) file in the input field.</p></li></ul></div></li><li><p>Click <strong>Next</strong>.</p></li><li><p>On the <strong>Specify service and port</strong> page, verify the service and port.</p></li><li><p>Click <strong>Next</strong>. If there is invalid or missing content, Syndesis displays information about what needs to be corrected. Select a different WSDL file to upload or click <strong>Cancel</strong>, revise the WSDL file, and then upload the updated file. If the schema is valid, Syndesis displays a summary of the API definition (name and description) and a list of imported elements, such as the number of operations.</p></li><li><p>Click <strong>Next</strong>.</p><div class="paragraph"><p><strong>Note:</strong> For this release, the security requirements on this page are inactive. Instead, you can define the security options when you create a connection from the connector, as described in <a href="https://zregvart.github.io/syndesis.io/manual/connecting/#create-soap-api-connection">Connecting to Applications and Services, Creating a SOAP API client connection</a>.</p></div></li></ol></div><div class="olist arabic"><ol class="arabic"><li><p>Click <strong>Next</strong>. Syndesis displays the connectors name, description, and WSDL endpoint address.</p><div class="ulist"><ul><li><p>Optionally, upload an icon for the connector. You can also upload an icon at a later time.</p><div class="paragraph"><p><strong>Note:</strong> For this release, If you do not upload an icon, Syndesis does <em>not</em> generate one for you.</p></div><div class="paragraph"><p>When Syndesis displays the flow of an integration, it displays a connectors icon to represent connections that are created from that connector.</p></div></li><li><p>For <strong>Name</strong>, enter your choice of a name that helps you distinguish this connection from any other connections.</p></li><li><p>Optionally, for <strong>Description</strong>, enter information that is helpful to know about this connection.</p></li></ul></div></li><li><p>Review the connector details and to override a value obtained from the WSDL file, edit the field value that you want to change.</p><div class="admonitionblock important"><table><tr><td class="icon"><div class="title">Important</div></td><td class="content">After Syndesis creates a connector, <strong>you cannot change it</strong>. To effect a change, you need to upload an updated OpenAPI document so that Syndesis can create a new connector or you can upload the same schema and then edit it in the API editor. You then continue the process for creating a new API client connector.</td></tr></table></div></li><li><p>When you are satisfied with the connector details, click <strong>Save</strong>. Syndesis displays the new connector in the list of API Client Connectors.</p></li></ol></div><div class="paragraph"><div class="title">Next step</div><p>For details about using your new API connector, see <a href="https://zregvart.github.io/syndesis.io/manual/connecting/#connecting-to-api-clients_connectors">Connecting to Applications and Services, Connecting to API clients</a>.</p></div></div><div class="sect3"><h4 id="updating-api-connectors_add-client-connector">Updating API client connectors by creating new ones</h4><div class="paragraph"><p>When there is an update to an OpenAPI document or WSDL file from which you created an API client connector, and you want your API client connector to use those updates, you must create a new API client connector. You cannot directly update an API client connector. After you create the new API client connector, you use it to create a new connection and then you edit each integration that uses a connection that was created from the out-of-date connector.</p></div><div class="paragraph"><div class="title">Prerequisites</div><p>Be prepared to do one of the following:</p></div><div class="ulist"><ul><li><p>For a REST API client connector:</p><div class="ulist"><ul><li><p>Upload the updated OpenAPI document.</p></li><li><p>Upload the out-of-date schema again and update it in API Designer.</p></li></ul></div></li><li><p>For a SOAP API client connector, upload the updated WSDL file.</p></li></ul></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>Create a new API client connector based on the updated OpenAPI document or WSDL file. To easily distinguish between the old connector and the new connector, you might want to specify a version number in the connector name or the connector description.</p><div class="paragraph"><p>See <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#developing-rest-api-client-connectors_custom">Developing REST API client connectors</a>.</p></div></li><li><p>Create a new connection from the new connector. Again, you want to be able to easily distinguish between connections created from the old connector and connections created from the new connector. A version number in the connection name or connection description is helpful.</p></li><li><p>Edit each integration that uses a connection that was created from the old connector by removing the old connection and adding the new connection.</p></li><li><p>Publish each updated integration.</p></li><li><p>Recommended, but not required: delete the old connector and the old connections.</p></li></ol></div></div><div class="sect3"><h4 id="deleting-api-connectors_add-client-connector">Deleting API client connectors</h4><div class="paragraph"><p>You cannot delete a connector when there is a connection that was created from that connector and this connection is being used in an integration. After you delete an API client connector, you cannot use a connection that was created from that connector.</p></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the left panel, click <strong>Customizations</strong> &gt; <strong>API Client Connectors</strong>.</p></li><li><p>To the right of the name of the connector that you want to delete, click <strong>Delete</strong>.</p></li><li><p>In the confirmation popup, if you sure that you want to delete the connector, click <strong>Delete</strong>.</p></li></ol></div></div></div><div class="sect2"><h3 id="developing-extensions_custom">Developing Syndesis extensions</h3><div class="paragraph"><p>If Syndesis does not provide a feature that is needed to create an integration, then an expert developer can code an extension that provides the needed behavior. The Syndesis extension repository, <a href="https://github.com/syndesisio/syndesis-extensions" class="bare">https://github.com/syndesisio/syndesis-extensions</a>, contains examples of extensions.</p></div><div class="paragraph"><p>A business integrator shares requirements with a developer who codes the extension. The developer provides a <code>.jar</code> file that contains the extension. The business integrator uploads the <code>.jar</code> file in Syndesis to make the custom connector, custom step(s), or library resource available for use in Syndesis.</p></div><div class="paragraph"><p>The Fuse Tooling plugin to Red Hat Developer Studio provides a wizard that helps you develop a step extension or a connector extension. It is a matter of personal preference whether you choose to develop a step extension or a connector extension in Developer Studio or in some other IDE. For information about using the Developer Studio plugin, see <a href="https://access.redhat.com/documentation/en-us/red_hat_fuse/7.7/html-single/tooling_user_guide/index#FuseOnlineExtension">Developing extensions for Syndesis integrations</a>.</p></div><div class="paragraph"><p>In this document, the following topics outline the procedure, describe the requirements, and provide additional examples for developing extensions in an IDE that you choose.</p></div><div class="ulist"><ul><li><p><a href="#procedure-for-developing-extensions_extensions">General procedure for developing extensions</a></p></li><li><p><a href="#description-kinds-extensions_extensions">Description of the kinds of extensions</a></p></li><li><p><a href="#overview-extension-content-structure_extensions">Overview of extension content and structure</a></p></li><li><p><a href="#about-extension-definitions_extensions">Requirements in an extension definition JSON file</a></p></li><li><p><a href="#descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</a></p></li><li><p><a href="#using-maven-to-generate-extension-definitions_extensions">Description of Maven plugin that supports extensions</a></p></li><li><p><a href="#how-to-specify-data-shapes_extensions">How to specify data shapes in extensions</a></p></li><li><p><a href="#develop-step-extensions_extensions">Examples of developing step extensions</a></p></li><li><p><a href="#develop-connector-extensions_extensions">Example of developing a connector extension</a></p></li><li><p><a href="#develop-library-extensions_extensions">How to develop library extensions</a></p></li><li><p><a href="#creating-jdbc-driver-library-extensions_extensions">Creating JDBC driver library extensions</a></p></li></ul></div><div class="sect3"><h4 id="procedure-for-developing-extensions_extensions">General procedure for developing extensions</h4><div class="paragraph"><p>Before you start to develop an extension, become familiar with the tasks that you will need to accomplish.</p></div><div class="ulist"><div class="title">Prerequisites</div><ul><li><p>Familiarity with <a href="https://maven.apache.org/">Maven</a></p></li><li><p>Familiarity with <a href="https://camel.apache.org/">Camel</a> if you are developing an extension that provides a connector or that provides an integration step that operates on data between connections</p></li><li><p>Experience programming</p></li></ul></div><div class="admonitionblock caution"><table><tr><td class="icon"><div class="title">Caution</div></td><td class="content"><div class="paragraph"><p>An integration pod runs in a Java process with a flat classpath. To avoid version clashes, make sure that the dependencies that an extension uses are aligned with the imported bill of materials (BOM) from all of these sources:</p></div><div class="ulist"><ul><li><p><code>org.springframework.boot:spring-boot-dependencies:$SPRING_BOOT_VERSION</code></p></li><li><p><code>org.apache.camel:camel-spring-boot-dependencies:$CAMEL_VERSION</code></p></li><li><p><code>io.syndesis.integration:integration-bom:$SYNDESIS_VERSION</code></p></li></ul></div><div class="paragraph"><p>If there are additional dependencies that are not part of the imported BOMs, you must:</p></div><div class="ulist"><ul><li><p>Package them in the extension JAR file that is in the <code>lib</code> directory.</p></li><li><p>Omit them from the <code>dependencies</code> property of the extension&#8217;s JSON descriptor file.</p></li></ul></div></td></tr></table></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>Obtain an understanding of what the extended feature must do. Talk to your business colleague to understand the feature requirements.</p></li><li><p>Determine whether you need to develop a step extension, a connector extension, or a library extension.</p></li><li><p>Set up the Maven project in which to develop the extension.</p></li><li><p>If you are developing a step extension:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Decide whether to implement it as a Camel route or implement it by using the Syndesis <code>Step</code> API. Information for the Syndesis API is at <a href="http://javadoc.io/doc/io.syndesis.extension/extension-api" class="bare">http://javadoc.io/doc/io.syndesis.extension/extension-api</a>.</p></li><li><p>If you choose to implement the extension as a Camel route, decide whether to implement XML fragments, a <code>RouteBuilder</code> class, or a bean.</p></li><li><p>In your Maven project, specify the required metadata, such as the <code>schemaVersion</code>, extension <code>name</code>, <code>extensionId</code>, and so on.</p></li></ol></div></li><li><p>Code the classes that implement the feature.</p></li><li><p>Add dependencies to the project&#8217;s <code>pom.xml</code> file.</p></li><li><p>For connector and library extensions, and for step extensions that you implement in XML, create the JSON file that defines the extension.</p><div class="paragraph"><p>For step extensions that you implement in Java, Maven can generate the JSON extension definition file for you when you specify corresponding data structure values in your Maven project.</p></div></li><li><p>Run Maven to build the extension and create the extension&#8217;s JAR file.</p></li><li><p>Test the extension by uploading the JAR file to a Syndesis development environment.</p></li><li><p>Provide the JAR file that packages the extension to your business colleague, who uploads it to a Syndesis production environment. When you provide the JAR file, let your business colleague know about any configuration settings that require information beyond what appears in the Syndesis web interface.</p></li></ol></div></div><div class="sect3"><h4 id="description-kinds-extensions_extensions">Description of the kinds of extensions</h4><div class="paragraph"><p>An extension defines one of the following:</p></div><div class="ulist"><ul><li><p>One or more custom steps that operate on integration data between connections. Each custom step performs one action. This is a step extension.</p></li><li><p>A library resource that an integration runtime uses. For example, a library extension can provide a JDBC driver for connecting to a proprietary SQL database, such as Oracle.</p></li><li><p>A single custom connector for creating connections to a particular application or service that you want to integrate. This is a connector extension.</p><div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">Syndesis can use an OpenAPI document to create a connector for a REST API client. See <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#developing-rest-api-client-connectors_custom">Develop a REST API client connector</a>.</td></tr></table></div></li></ul></div><div class="paragraph"><p>A business integrator shares requirements with a developer who codes the extension. The developer provides a <code>.jar</code> file that contains the extension. The business integrator uploads the <code>.jar</code> file in Syndesis to make the custom connector, custom step(s), or library resource available for use within Syndesis.</p></div><div class="paragraph"><p>An extension <code>.jar</code> file that you upload to Syndesis always contains exactly one extension.</p></div><div class="paragraph"><p>For an example of uploading and using an extension that provides a step that operates on data between connections, see the <a href="https://zregvart.github.io/syndesis.io/manual/tutorials/#amq-to-rest-api_tutorials">AMQ to REST API sample integration tutorial</a>.</p></div></div><div class="sect3"><h4 id="overview-extension-content-structure_extensions">Overview of extension content and structure</h4><div class="paragraph"><p>An extension is a collection of classes, dependencies, and resources that are packaged in a <code>.jar</code> file.</p></div><div class="paragraph"><p>Syndesis uses Spring Boot to load an extension. Consequently, you must package an extension according to Spring Boot&#8217;s executable JAR format. For example, ensure that you use the <code>ZipEntry.STORED()</code> method to save a nested JAR file.</p></div><div class="paragraph"><p>The structure of a <code>.jar</code> file that packages an extension is as follows:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code>extension.jar
|
+- META-INF
|  |
|  +- syndesis
|     |
|     +- syndesis-extension-definition.json <b class="conum">(1)</b>
|
+- mycompany
|  |
|  +-project
|    |
|    +-YourClasses.class <b class="conum">(2)</b>
|
+- lib <b class="conum">(3)</b>
  |
  +-dependency1.jar
  |
  +-dependency2.jar</code></pre></div></div><div class="colist arabic"><ol><li><p>A JSON schema file that specifies the data structures that define the extension. This is referred to as the extension definition JSON file.</p></li><li><p>The Java classes that implement the behavior that the extension provides.</p></li><li><p>Additional dependencies that are required to build and execute the custom feature.</p></li></ol></div></div><div class="sect3"><h4 id="about-extension-definitions_extensions">Requirements in an extension definition JSON file</h4><div class="paragraph"><p>Each extension must have a <code>.json</code> file that defines the extension by specifying values for data structures such as name, description, supported actions, and dependencies. For each extension type, the following table indicates whether Maven can generate the extension definition JSON file and which data structures are required.</p></div><table class="tableblock frame-all grid-all stretch"><colgroup><col style="width:50%"><col style="width:16.6666%"><col style="width:33.3334%"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Extension Type</th><th class="tableblock halign-left valign-top">Maven Can Generate Extension Definition</th><th class="tableblock halign-left valign-top">Required Data Structures</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Step extension in Java</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>schemaVersion</code><br><code>name</code><br><code>description</code><br><code>version</code><br><code>extensionId</code><br><code>extensionType</code><br><code>actions</code><br><code>dependencies</code> *</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Step extension in XML</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>schemaVersion</code><br><code>name</code><br><code>description</code><br><code>version</code><br><code>extensionId</code><br><code>extensionType</code><br><code>actions</code><br><code>dependencies</code> *</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Connector extension</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>schemaVersion</code><br><code>name</code><br><code>description</code><br><code>version</code><br><code>extensionId</code><br><code>extensionType</code><br><code>properties</code><br><code>actions</code><br><code>dependencies</code> *<br><code>componentScheme</code><br><code>connectorCustomizers</code><br><code>connectorFactory</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Library extension</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>schemaVersion</code><br><code>name</code><br><code>description</code><br><code>version</code><br><code>extensionId</code><br><code>extensionType</code><br><code>dependencies</code> *</p></td></tr></tbody></table><div class="paragraph"><p>*While specification of <code>dependencies</code> is not strictly required, in practice, there are almost always dependencies that you need to specify.</p></div><div class="paragraph"><p>Typically, an extension definition file has the following layout:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">{
  "schemaVersion": "v1",
  "name": "",
  "description": "",
  "version": "",
  "extensionId": "",
  "extensionType": "",
  "properties": {
  },
  "actions": [
  ],
  "dependencies": [
  ],
}</code></pre></div></div><div class="ulist"><ul><li><p><strong>schemaVersion</strong> defines the version of the extension definition schema. Internally, Syndesis uses <strong>schemaVersion</strong> to determine how to map the extension definition to the internal model. This allows extensions that were developed against an old version of Syndesis to be deployed on newer versions of Syndesis.</p></li><li><p><strong>name</strong> is the name of the extension. When you upload an extension to Syndesis, this name appears.</p></li><li><p><strong>description</strong> is any useful information that you want to specify. Syndesis does not operate on this value.</p></li><li><p><strong>version</strong> is for your convenience to help you distinguish updates to an extension. Syndesis does not operate on this value.</p></li><li><p><strong>extensionId</strong> defines a unique ID for the extension. This should be unique at least across a Syndesis environment.</p></li><li><p><strong>extensionType</strong> indicates to Syndesis what the extension provides. As of Syndesis version 1.3, the following extension types are supported:</p><div class="ulist"><ul><li><p><code>Steps</code></p></li><li><p><code>Connectors</code></p></li><li><p><code>Libraries</code></p></li></ul></div></li><li><p><strong>properties</strong> at the top level in a connector extension is required. It controls what Syndesis displays when a Syndesis user selects the connector to create a connection. This <code>properties</code> object contains a set of properties for each form control for creating a connection. For example:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">"myControlName": {
  "deprecated": true|false,
  "description": "",
  "displayName": "",
  "group": "",
  "kind": "",
  "label": "",
  "required": true|false,
  "secret": true|false,
  "javaType": "",
  "type": "",
  "defaultValue": "",
  "enum": {
  }
}</code></pre></div></div><div class="paragraph"><p>In connector extensions, nested <code>properties</code> objects define HTML form controls for configuring connection actions. In step extensions, the <code>actions</code> object contains a <code>properties</code> object. The <code>properties</code> object defines a set of properties for each form control for configuring the step. See also: <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</a>.</p></div></li><li><p><strong>actions</strong> defines the operations that a connector can perform or the operation that a step between connections can perform. Only connector and step extensions use actions that you specify. The format for an action specification looks like this:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">{
    "id": "",
    "name": "",
    "description": "",
    "actionType": "step|connector",
    "descriptor": {
    }
}</code></pre></div></div><div class="ulist"><ul><li><p><strong>id</strong> is a unique ID for the action. This should be unique at least within a Syndesis environment.</p></li><li><p><strong>name</strong> is the action name that appears in Syndesis. An integrator sees this value as the name of a connection action or as the name of a step that operates on integration data between connections.</p></li><li><p><strong>description</strong> is the action description that appears in Syndesis. Use this field to help the integrator understand what the action does.</p></li><li><p><strong>actionType</strong> indicates whether the action is performed by a connection or a step that is between connections.</p></li><li><p><strong>descriptor</strong> specifies nested attributes such as <code>kind</code>, <code>entrypoint</code>, <code>inputDataType</code>, <code>outputDatatype</code> and more.</p></li></ul></div></li><li><p><strong>dependencies</strong> defines the resources that this extension requires Syndesis to provide.</p><div class="paragraph"><p>Define a dependency as follows:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">{
  "type": "MAVEN",
  "id"   : "org.apache.camel:camel-telegram:jar:2.21.0"
}</code></pre></div></div><div class="ulist"><ul><li><p><strong>type</strong> indicates the type of the dependency. Specify <strong>MAVEN</strong>. (It is expected that other types will be supported in the future.)</p></li><li><p><strong>id</strong> is the ID of the Maven dependency, which is a Maven GAV.</p></li></ul></div></li></ul></div></div><div class="sect3"><h4 id="descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</h4><div class="paragraph"><p>In connector extensions and step extensions, specify user interface properties in the extension definition JSON file or in Java class files. The settings of these properties define the HTML form controls that Syndesis displays when a Syndesis user creates a connection, configures a connection action, or configures a step that is provided by the extension.</p></div><div class="paragraph"><p>You must specify properties for each form control that you want to appear in the extension&#8217;s user interface in the Syndesis console. For each form control, specify some or all properties in any order.</p></div><div class="paragraph"><div class="title">Example of user interface property specifications</div><p>In the JSON file that is part of the IRC connector, the top level <code>properties</code> object defines the HTML form controls that appear after a Syndesis user selects the IRC connector to create a connection. There are three sets of property definitions for three form controls: <code>hostname</code>, <code>password</code>, and <code>port</code>:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">"properties": {
   "hostname": {
     "description": "IRC Server hostname",
     "displayName": "Hostname",
     "labelHint": "Hostname of the IRC server to connect to",
     "order": "1",
     "required": true,
     "secret": false,
     "type": "string"
   },
   "password": {
     "description": "IRC Server password",
     "displayName": "Password",
     "labelHint": "Required if IRC server requires it to join",
     "order": "3",
     "required": false,
     "secret": true,
     "type": "string"
   },
   "port": {
     "description": "IRC Server port",
     "displayName": "Port",
     "labelHint": "Port of the IRC server to connect to",
     "order": "2",
     "required": true,
     "secret": false,
     "tags": [],
     "type": "int"
   }
 },</code></pre></div></div><div class="paragraph"><p>Based on these property specifications, when a Syndesis user selects the IRC connector, Syndesis displays the following dialog. After the user enters values in the two required fields and clicks <strong>Next</strong>, Syndesis creates an IRC connection that is configured with the values that the Syndesis user enters.</p></div><div class="paragraph"><p><span class="image"><img src="images/integrating-applications/IRC-create-connection-fields.png" alt="Hostname" width="Password" height="Port"></span></p></div><div class="paragraph"><div class="title">About <code>properties</code> objects in extension definition JSON files</div><p>In a connector extension:</p></div><div class="ulist"><ul><li><p>The toplevel <code>properties</code> object is required. It controls what Syndesis displays when a Syndesis user selects the connector to create a connection. This <code>properties</code> object contains a set of properties for each form control for creating a connection.</p></li><li><p>In the <code>actions</code> object, there is a <code>properties</code> object for each action. In each of these <code>properties</code> objects, there is a set of properties for each form control for configuring that action.</p></li></ul></div><div class="paragraph"><p>In a step extension, the <code>actions</code> object contains a <code>properties</code> object. The <code>properties</code> object defines a set of properties for each form control for configuring the step. The JSON hierarchy looks like this:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">"actions": [
   {
      ...

      "propertyDefinitionSteps": [
         {
            ...

            "properties":
               {
                  "control-ONE": {
                     "type": "string",
                     "displayName": "Topic Name",
                     "order": "2",
                     ...,
                     }

                  "control-TWO": {
                     "type": "boolean",
                     "displayName": "Urgent",
                     "order": "3",
                     ...
                     }

                  "control-THREE": {
                     "type": "textarea",
                     "displayName": "Comment",
                     "order": "1",
                     ...,
                     }
 } } ]</code></pre></div></div><div class="paragraph"><div class="title">About user interface properties in Java files</div><p>To define user interface form controls in Java files, import <code>io.syndesis.extension.api.annotations.ConfigurationProperty</code> in each class file that defines user configuration of a connection, action, or step. For each form control that you want the Syndesis console to display, specify the <code>@ConfigurationProperty</code> annotation, followed by a list of properties. For information about the properties that you can specify, see the user interface property reference table at the end of this section.</p></div><div class="paragraph"><p>The following code shows property definitions for one form control. This code is in the example of developing a Camel route with <code>RouteBuilder</code>:</p></div><div class="listingblock"><div class="content"><pre>public class LogAction extends RouteBuilder {
    @ConfigurationProperty(
        name = "prefix",
        description = "The Log body prefix message",
        displayName = "Log Prefix",
        type = "string")</pre></div></div><div class="paragraph"><p>The following code shows property definitions for two controls. This code is from the example of using the Syndesis Step API:</p></div><div class="listingblock"><div class="content"><pre>@Action(id = "split", name = "Split", description = "Split your exchange")
public class SplitAction implements Step {

    @ConfigurationProperty(
        name = "language",
        displayName = "Language",
        description = "The language used for the expression")
    private String language;

    @ConfigurationProperty(
        name = "expression",
        displayName = "Expression",
        description = "The expression used to split the exchange
     private String language;</pre></div></div><div class="paragraph"><div class="title">Descriptions of control form input types</div><p>In the set of properties for each HTML form control, the <code>type</code> property defines the input type of the form control that Syndesis displays. For details about HTML form input types, see <a href="https://www.w3schools.com/html/html_form_input_types.asp">https://www.w3schools.com/html/html_form_input_types.asp</a>.</p></div><div class="paragraph"><p>The following table lists the possible input types for Syndesis form controls. In the set of properties for a control, if you specify a <code>type</code> value that is unknown, Syndesis displays an input field that accepts one line of text. That is, the default is <code>"type": "text"</code>.</p></div><table class="tableblock frame-all grid-all stretch"><colgroup><col style="width:20%"><col style="width:40%"><col style="width:40%"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Value of <code>type</code> property</th><th class="tableblock halign-left valign-top">HTML</th><th class="tableblock halign-left valign-top">Syndesis displays</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;input type="checkbox"&gt;</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">A checkbox that the user can select or not select.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>duration</code></p></td><td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock">A custom control that lets the Syndesis user select a unit of time: milliseconds, seconds, minutes, hours, or days. The user also enters a number and Syndesis returns a number of milliseconds. For example:<br><code>"properties": {<br>&nbsp;&nbsp;&nbsp;"period": {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"type": "duration"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"defaultValue": 60000,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"description": "Period",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"displayName": "Period",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"labelHint": "Delay between integration executions.",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"required": true,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"secret": false,<br>&nbsp;&nbsp;&nbsp;}<br>}</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>hidden</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;input type="hidden"&gt;</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">This field does not appear in the Syndesis console. You can use other properties to specify data that is associated with this field, for example, textual data of some kind. While Syndesis users cannot see or modify this data, if a user selects <strong>View Source</strong> for a Syndesis page, hidden fields are visible in the source display. Therefore, do not use hidden fields for security purposes.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>int</code>, <code>integer</code>, <code>long</code>, <code>number</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;input type="number"&gt;</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">An input field that accepts a number.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>password</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;input type="password"&gt;</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">An input field in which Syndesis masks the characters that the user enters, typically with asterisks.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>select</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">A <code>&lt;select&gt;</code> element, for example:<br><code>&lt;select name="targets"&gt;<br>&nbsp;&nbsp;&lt;option value="queue"&gt;Queue&lt;/option&gt;<br>&nbsp;&nbsp;&lt;option value="topic"&gt;Topic&lt;/option&gt;<br>&lt;/select&gt;</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">A drop-down list with an entry for each label/value pair that you specify in the form controls <code>enum</code> property.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>text</code>, <code>string</code>, or any unknown value</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;input type="text"&gt;`</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">An input field that accepts one line of text.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>textarea</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;input type="textarea"</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">A textarea element is used</p></td></tr></tbody></table><div class="paragraph"><div class="title">Descriptions of control form user interface properties</div><p>In a connector or step extension, for each HTML form control that appears in the Syndesis console, you can specify one or more of the properties described in the following table. For details about HTML form input types, see <a href="https://www.w3schools.com/html/html_form_input_types.asp">https://www.w3schools.com/html/html_form_input_types.asp</a>.</p></div><table class="tableblock frame-all grid-all stretch"><colgroup><col style="width:25%"><col style="width:25%"><col style="width:50%"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Property name</th><th class="tableblock halign-left valign-top">Type</th><th class="tableblock halign-left valign-top">Description</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>type</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Controls the kind of form control that Syndesis displays. See the previous table for details.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>cols</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If set for a <code>textarea</code> field, controls the number of columns initially displayed for the textarea control.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>controlHint</code> or <code>controlTooltip</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If set, the value is mapped to the HTML <code>title</code> attribute of the form control element. Just like other elements that have a <code>title</code> attribute, when the cursor hovers over the control, a tooltip appears. The content of the tooltip comes from the value of the <code>controlHint</code> or <code>controlTooltip</code> property.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>dataList</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">array</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If the value of the <code>type</code> property is <code>text</code>, Syndesis uses the value of the <code>dataList</code> property to add typeahead support. Specify an array of strings.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>defaultValue</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Varies according to the value of the <code>type</code> property.</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Syndesis initially displays this value in the form field. The type of the setting of the <code>defaultValue</code> property should match the value of the <code>type</code> property. For example, when the <code>type</code> property is set to <code>number</code>, the <code>defaultValue</code> setting should be a number. If the user does not change this initial field value, Syndesis uses <code>defaultValue</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>description</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If set, Syndesis displays this value below the form control. Typically, this is a short, useful message about the control.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>displayName</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Syndesis displays this value.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>enum</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">array</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If set, Syndesis overrides any setting for the <code>type</code> property and implements a <code>select</code> control. Specify the array as a set of <code>label</code> and <code>value</code> attributes. The <code>label</code> attribute appears in the user interface as the select item&#8217;s label. The <code>value</code> attribute becomes the value for the corresponding select item.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>labelHint</code> or <code>labelTooltip</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If set, a <code>?</code> icon appears next to the display name. When the Syndesis user clicks the <code>?</code> icon, the value of the <code>labelHint</code> property displays.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>max</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If set for a <code>number</code> field, defines the highest acceptable value.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>min</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If set for a <code>number</code> field, defines the lowest acceptable value.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>multiple</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If set to <code>true</code> for a <code>select</code> field or for a field that has the <code>enum</code> property set, Syndesis displays a multi-select control instead of a select drop-down.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>order</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Determines the order of controls in the Syndesis console. Syndesis applies ascending order, that is, the control that has <code>"order": "1"</code> appears first. Without specification of the <code>order</code> property, Syndesis displays controls in the order in which the JSON file defines them.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>placeholder</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If set, Syndesis displays this value in a hazed font in an input field to help the user understand the expected input.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>required</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Controls whether or not the <code>required</code> attribute is set on the control. If true, then the Syndesis user must enter a value for this control.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>rows</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If the value of the <code>type</code> property is <code>textarea</code>, the value of the <code>rows</code> property controls the number of rows initially displayed in the textarea control.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>secret</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If specified, Syndesis changes the setting of the control&#8217;s <code>type</code> property to <code>password</code> if that is not already the setting.</p></td></tr></tbody></table></div><div class="sect3"><h4 id="using-maven-to-generate-extension-definitions_extensions">Description of Maven plugin that supports extensions</h4><div class="paragraph"><p>The <code>extension-maven-plugin</code> supports extension development by packaging the extension as a valid Spring Boot module. For step extensions that you implement in Java, this plugin can generate the extension definition JSON file.</p></div><div class="paragraph"><p>In your Maven project&#8217;s <code>pom.xml</code> file, add the following plugin declaration:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
    &lt;groupId&gt;io.syndesis.extension&lt;/groupId&gt;
    &lt;artifactId&gt;extension-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;${syndesis.version}&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
        &lt;goals&gt;
            &lt;goal&gt;generate-metadata&lt;/goal&gt;
            &lt;goal&gt;repackage-extension&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;</code></pre></div></div><div class="paragraph"><p>The <code>extension-maven-plugin</code> defines the following goals:</p></div><div class="ulist"><ul><li><p><strong>generate-metadata</strong> generates the JSON extension definition file that will be in the generated JAR file as follows:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Maven starts with the data structure specifications that are in the <code>META-INF/syndesis/syndesis-extension-definition.json</code> file, if there is one.</p><div class="paragraph"><p>If you are coding in XML, then you must define the extension definition JSON file yourself and it must specify all required data structures.</p></div><div class="paragraph"><p>If you are developing a connector or library extension, then you must define the extension definition JSON file yourself and it must specify all required data structures.</p></div><div class="paragraph"><p>If you are developing a step extension in Java, you can:</p></div><div class="ulist"><ul><li><p>Create the extension definition JSON file yourself.</p></li><li><p>In your Java code, specify annotations that define all required data structures. You do not create an extension definition JSON file.</p></li><li><p>Create an extension definition JSON file and specify some but not all data structures.</p></li></ul></div></li><li><p>For step extensions that you develop in Java, Maven obtains missing specifications from code annotations</p></li><li><p>Maven adds the dependencies list, which specifies dependencies that are provided with a scope of <code>provided</code> and that are managed through the <code>extension-bom</code>.</p></li></ol></div></li><li><p><strong>repackage-extension</strong> packages the extension.</p><div class="ulist"><ul><li><p>Dependencies and related transitive dependencies that are not managed through the <code>extension-bom</code> are in the <code>lib</code> folder of the generated JAR.</p></li><li><p>For library extensions, dependencies whose scope is <code>system</code> are in the <code>lib</code> folder of the generated JAR.</p></li></ul></div></li></ul></div><div class="paragraph"><p>For example, suppose your Maven project has the following <code>pom.xml</code> file:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;

  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;com.company&lt;/groupId&gt;
  &lt;artifactId&gt;my-extension&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;name&gt;MyExtension&lt;/name&gt;
  &lt;description&gt;A Sample Extension&lt;/description&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;dependencyManagement&gt;
    &lt;dependencies&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;io.syndesis.extension&lt;/groupId&gt;
        &lt;artifactId&gt;extension-bom&lt;/artifactId&gt;
        &lt;version&gt;1.3.10&lt;/version&gt;
        &lt;type&gt;pom&lt;/type&gt;
        &lt;scope&gt;import&lt;/scope&gt;
      &lt;/dependency&gt;
    &lt;/dependencies&gt;
  &lt;/dependencyManagement&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;io.syndesis.extension&lt;/groupId&gt;
      &lt;artifactId&gt;extension-api&lt;/artifactId&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.github.lalyos&lt;/groupId&gt;
      &lt;artifactId&gt;jfiglet&lt;/artifactId&gt;
      &lt;version&gt;0.0.8&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
        &lt;version&gt;3.7.0&lt;/version&gt;
        &lt;configuration&gt;
          &lt;source&gt;1.8&lt;/source&gt;
          &lt;target&gt;1.8&lt;/target&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;io.syndesis.extension&lt;/groupId&gt;
        &lt;artifactId&gt;extension-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.3.10&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;goals&gt;
              &lt;goal&gt;generate-metadata&lt;/goal&gt;
              &lt;goal&gt;repackage-extension&lt;/goal&gt;
            &lt;/goals&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;</code></pre></div></div><div class="paragraph"><p>Based on this <code>pom.xml</code> file, the generated extension definition JSON file looks like this:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">{
  "name": "MyExtension",
  "description": "A Sample Extension",
  "extensionId": "com.company:my-extension",
  "version": "1.0.0",
  "dependencies": [ {
    "type": "MAVEN",
    "id": "io.syndesis.extension:extension-api:jar:1.3.10"
  } ],
  "extensionType": "Libraries",
  "schemaVersion": "v1"
}</code></pre></div></div><div class="paragraph"><p>The generated archive has this structure and content:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code>my-extension-1.0.0.jar
|
+- lib
|  |
|+ jfiglet-0.0.8.jar
|
+- META-INF
  |
  +- MANIFEST.MF
     |
     +- syndesis
        |
        +- syndesis-extension-definition.json</code></pre></div></div></div><div class="sect3"><h4 id="how-to-specify-data-shapes_extensions">How to specify data shapes in extensions</h4><div class="paragraph"><p>A data shape holds data type metadata for use by the data mapper. The data mapper transforms this metadata into internal documents that it uses to display the source and target data fields in the data mapper user interface. In an extension definition JSON file for a connector or for a custom step, each action specification defines an input data shape (<code>inputDataShape</code>) and an output data shape (<code>outputDataShape</code>).</p></div><div class="paragraph"><p>When you are developing an extension, it is important to specify data shape properties that allow the data mapper to correctly handle and display the source and target fields. The following data shape properties affect data mapper behavior:</p></div><div class="ulist"><ul><li><p><code>kind</code></p></li><li><p><code>type</code></p></li><li><p><code>specification</code></p></li><li><p><code>name</code></p></li><li><p><code>description</code></p></li></ul></div><div class="paragraph"><div class="title">About the <code>kind</code> property</div><p>The data shape <code>kind</code> property is represented by the <code>DataShapeKinds</code> enum. The possible values for the <code>kind</code> property are:</p></div><div class="ulist"><ul><li><p><code>java</code> indicates that the data type is represented by a Java class. Follow the <code>"kind": "java"</code> declaration by specifying a fully qualified class name for the <code>type</code> property. For example:</p><div class="listingblock"><div class="content"><pre>"outputDataShape": {
     "kind": "java",
     "type": "org.apache.camel.component.telegram.model.IncomingMessage"
},</pre></div></div></li><li><p><code>json-schema</code> indicates that the data type is represented by a JSON schema. When <code>kind</code> is set to <code>json-schema</code>, specify a JSON schema as the value of the data shape&#8217;s <code>specification</code> property. For example:</p><div class="listingblock"><div class="content"><pre>"inputDataShape": {
  "description": "Person data",
  "kind": "json-schema",
  "name": "Person",
  "specification": "{\"$schema\":\"http://json-schema.org/draft-04/schema#\",\"title\":\"Person\",\"type\":\"object\",\"properties\":{\"firstName\":{...}}}"
}</pre></div></div><div class="paragraph"><p>The code for the SAP Concur connector contains <a href="https://github.com/syndesisio/syndesis/blob/master/app/connector/concur/src/main/resources/META-INF/syndesis/connector/concur-api.json">examples of data shapes that are specified by JSON schemas</a>.</p></div></li><li><p><code>json-instance</code> indicates that the data type is represented by a JSON instance. When <code>kind</code> is set to <code>json-instance</code>, specify a JSON instance as the value of the data shape&#8217;s <code>specification</code> property. For example:</p><div class="listingblock"><div class="content"><pre>"inputDataShape": {
  "description": "Person data",
  "kind": "json-instance",
  "name": "Person",
  "specification": "{\"firstName\":\"John\",...}"
}</pre></div></div></li><li><p><code>xml-schema</code> indicates that the data type is represented by an XML schema. When <code>kind</code> is set to <code>xml-schema</code>, specify an XML Schema as the value of the data shape&#8217;s <code>specification</code> property. For example:</p><div class="listingblock"><div class="content"><pre>"inputDataShape": {
  "description": "Person data",
  "kind": "xml-schema",
  "name": "Person",
  "specification": "&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"&gt;...&lt;/xs:schema&gt;"
}</pre></div></div></li><li><p><code>xml-instance</code> indicates that the data type is represented by an XML instance. When <code>kind</code> is set to <code>xml-instance</code>, specify an XML instance as the value of the data shape&#8217;s <code>specification</code> property. For example:</p><div class="listingblock"><div class="content"><pre>"inputDataShape": {
  "description": "Person data",
  "kind": "xml-instance",
  "name": "Person",
  "specification": "&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;Person&gt;&lt;firstName&gt;Jane&lt;/firstName&gt;&lt;/Person&gt;"
}</pre></div></div></li><li><p><code>any</code> indicates that the data type is not structured. For example, it might be a byte array or free format text. The data mapper ignores a data shape when its <code>kind</code> property is set to <code>any</code>. In other words, the data does not appear in the data mapper and therefore you cannot map any fields to or from this data.</p><div class="paragraph"><p>However, for a custom connector, when its <code>kind</code> property is set to <code>any</code>, Syndesis prompts you to specify input and/or output data types when you configure a connection that you have created from the custom connector. This happens when you add a connection to an integration. You can specify the kind of the data shapes schema, an appropriate document for the kind of schema that you specify, and a name for the data type.</p></div></li><li><p><code>none</code> indicates that there is no data type. For an input data shape, this indicates that the connection or step does not read data. For an output data shape, this indicates that the connection or step does not modify data. For example, when an input message body is being transferred to an output message body, setting the <code>kind</code> property to <code>none</code> indicates that the data is only passing through. The data mapper ignores data shapes when <code>kind</code> is set to <code>none</code>. In other words, the data does not appear in the data mapper and therefore you cannot map any fields to or from this data.</p></li></ul></div><div class="paragraph"><div class="title">About the <code>type</code> property</div><p>When the value of the <code>kind</code> property is <code>java</code>, the <code>"kind": "java"</code> declaration is followed by a <code>type</code> declaration that specifies a fully qualified Java class name. For example:</p></div><div class="listingblock"><div class="content"><pre>"outputDataShape": {
     "kind": "java",
     "type": "org.apache.camel.component.telegram.model.IncomingMessage"
},</pre></div></div><div class="paragraph"><p>When the <code>kind</code> property is set to anything other than <code>java</code> then any setting for the <code>type</code> property is ignored.</p></div><div class="paragraph"><div class="title">About the <code>specification</code> property</div><p>The setting of the <code>kind</code> property determines the setting of the <code>specification</code> property, as shown in the following table.</p></div><table class="tableblock frame-all grid-all stretch"><colgroup><col style="width:50%"><col style="width:50%"></colgroup><thead><tr><th class="tableblock halign-left valign-top"><code>kind</code> property setting</th><th class="tableblock halign-left valign-top"><code>specification</code> property setting</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>java</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Java inspection result.</p><p class="tableblock">For each extension that you write in Java, use <code>extension-maven-plugin</code> to at least obtain the Java inspection result. The plugin inserts the Java inspection result in the JSON extension definition file as the setting of the <code>specification</code> property. This is the only way to obtain the Java inspection result, which is required for data mapping in Syndesis.</p><p class="tableblock">As a reminder, for step extensions written in Java, <code>extension-maven-plugin</code> generates the JSON extension definition file and populates it with required content. For connector extensions, while <code>extension-maven-plugin</code> inserts the Java inspection result in the JSON extension definition file, you will need to manually add the required content that the plugin does not insert.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>json-schema</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">An actual JSON schema document. The setting cannot be a reference to a document and the JSON schema cannot point to other JSON schema documents by means of references.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>json-instance</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">An actual JSON document that contains example data. The data mapper derives the data types from the example data. The setting cannot be a reference to a document.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>xml-schema</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">An actual XML schema document. The setting cannot be a reference to a document and the XML schema cannot point to other XML schema documents by means of references.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>xml-instance</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">An actual XML instance document. The setting cannot be a reference to a document.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>any</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">The <code>specification</code> property is not required. Any setting is ignored.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>none</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">The <code>specification</code> property is not required. Any setting is ignored.</p></td></tr></tbody></table><div class="paragraph"><div class="title">About the <code>name</code> property</div><p>The data shape <code>name</code> property specifies a human readable name for the data type. The data mapper displays this name in its user interface as the label for the data fields. In the following image, <strong>Person</strong> is an example of where you would see the value of the <code>name</code> property.</p></div><div class="paragraph"><p><span class="image"><img src="images/integrating-applications/PersonDataType.png" alt="Name example"></span></p></div><div class="paragraph"><p>This name also appears in data type indicators in the Syndesis flow visualization.</p></div><div class="paragraph"><div class="title">About the <code>description</code> property</div><p>The data shape <code>description</code> property specifies text that appears as a tooltip when the cursor hovers over the data type name in the data mapper user interface.</p></div></div><div class="sect3"><h4 id="develop-step-extensions_extensions">Examples of developing step extensions</h4><div class="paragraph"><p>A step extension implements one or more custom steps. Each custom step implements one action for processing integration data between connections. The following examples demonstrate the alternatives for developing step extensions:</p></div><div class="ulist"><ul><li><p><a href="#example-route-xml-fragment_step-alternatives">Example of developing a Camel route with XML fragments</a></p></li><li><p><a href="#example-route-builder_step-alternatives">Example of developing a Camel route with <code>RouteBuilder</code></a></p></li><li><p><a href="#example-route-builder-spring-boot_step-alternatives">Example of developing a Camel route with <code>RouteBuilder</code> and Spring Boot</a></p></li><li><p><a href="#example-camel-bean_step-alternatives">Example of using a Camel bean</a></p></li><li><p><a href="#example-step-api_step-alternatives">Example of using the Syndesis Step API</a></p></li></ul></div><div class="paragraph"><p>Syndesis provides custom Java annotations that you can use in conjunction with the <code>syndesis-extension-plugin</code>. When you implement a step extension or a connector extension in Java, you can specify annotations that enable Maven to add action definitions to the extension definition JSON file. To enable annotation processing, add the following dependency to your Maven project:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;io.syndesis.extension&lt;/groupId&gt;
  &lt;artifactId&gt;extension-annotation-processor&lt;/artifactId&gt;
  &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;</code></pre></div></div><div class="paragraph"><p>Because Spring Boot is the integration runtime, to inject beans into a Camel context, be sure to follow standard Spring Boot practices. For example, <a href="https://docs.spring.io/spring-boot/docs/1.5.11.RELEASE/reference/html/boot-features-developing-auto-configuration.html">create an auto configuration class</a> and create beans there. However, the default behavior is that extension code is not subject to package scanning. Consequently, you must create and populate the <code>META-INF/spring.factories</code> file in a step extension.</p></div><div class="sect4"><h5 id="example-route-xml-fragment_step-alternatives">Example of developing a Camel route with XML fragments</h5><div class="paragraph"><p>To develop a custom step, you can implement the action as an XML fragment that is a Camel route that has an input such as <code>direct</code>. The Syndesis runtime invokes this route in the same way that it invokes any other Camel route.</p></div><div class="paragraph"><p>For example, suppose that you want to create a step that logs the body of a message with an optional prefix. The following XML defines a Camel route that does this.</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;routes xmlns="http://camel.apache.org/schema/spring"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
      http://camel.apache.org/schema/spring
      http://camel.apache.org/schema/spring/camel-spring.xsd"&gt;

  &lt;route id="log-body-with-prefix"&gt;
    &lt;from uri="direct:log"/&gt;
    &lt;choice&gt;
      &lt;when&gt;
        &lt;simple&gt;${header.prefix} != ''&lt;/simple&gt;
        &lt;log message="${header.prefix} ${body}"/&gt;
      &lt;/when&gt;
      &lt;otherwise&gt;
        &lt;log message="Output ${body}"/&gt;
      &lt;/otherwise&gt;
    &lt;/choice&gt;
  &lt;/route&gt;

&lt;/routes&gt;</code></pre></div></div><div class="paragraph"><p>When you develop an extension in XML, you must create the extension definition JSON file yourself. For this XML fragment, the <code>src/main/resources/META-INF/syndesis/syndesis-extension-definition.json</code> file could define the action as follows:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">{
  "actionType": "step",
  "id": "log-body-with-prefix",
  "name": "Log body with prefix",
  "description": "A simple body log with a prefix",
  "descriptor": {
    "kind": "ENDPOINT", <b class="conum">(1)</b>
    "entrypoint": "direct:log", <b class="conum">(2)</b>
    "resource": "classpath:log-body-action.xml", <b class="conum">(3)</b>
    "inputDataShape": {
      "kind": "none"
    },
    "outputDataShape": {
      "kind": "none"
    },
  "propertyDefinitionSteps": [ {
    "description": "extension-properties",
    "name": "extension-properties",
    "properties": { <b class="conum">(4)</b>
      "prefix": {
        "componentProperty": false,
        "deprecated": false,
        "description": "The Log body prefix message",
        "displayName": "Log Prefix",
        "javaType": "String",
        "kind": "parameter",
        "required": false,
        "secret": false,
        "type": "string"
      }
    }
  } ]
  }
}</code></pre></div></div><div class="colist arabic"><ol><li><p>The type of the action is set to <code>ENDPOINT</code>. The runtime invokes a Camel endpoint to execute the action provided by this custom step.</p></li><li><p>The Camel endpoint to invoke is <code>direct:log</code>. This is the <code>from</code> specification in the route.</p></li><li><p>This is the location of the XML fragment.</p></li><li><p>These are the properties that the action defined in this custom step exposes to the integrator who will be adding this step to an integration. In Syndesis, each value that the integrator specifies in the user interface gets mapped to a message header that has the same name as the property. In this example, the integrator will see one input field, with the <strong>Log Prefix</strong> display name. For more details, see <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</a>.</p></li></ol></div><div class="admonitionblock warning"><table><tr><td class="icon"><div class="title">Warning</div></td><td class="content"><div class="paragraph"><p>Syndesis does not support full Camel XML configuration. Syndesis supports only the &lt;routes&gt; tag.</p></div></td></tr></table></div></div><div class="sect4"><h5 id="example-route-builder_step-alternatives">Example of developing a Camel route with <code>RouteBuilder</code></h5><div class="paragraph"><p>You can implement a custom step by developing an action as a Camel route with the support of the <code>RouteBuilder</code> class. Such a route has an input such as <code>direct</code>. Syndesis invokes this route in the same way that it invokes any other Camel route.</p></div><div class="paragraph"><p>To implement the example that creates a step that logs the body of a message with an optional prefix, you can write something like this:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java">import org.apache.camel.builder.RouteBuilder;

import io.syndesis.extension.api.annotations.Action;
import io.syndesis.extension.api.annotations.ConfigurationProperty;

@Action( // <b class="conum">(1)</b>
    id = "log-body-with-prefix",
    name = "Log body with prefix",
    description = "A simple body log with a prefix",
    entrypoint = "direct:log")
public class LogAction extends RouteBuilder {
    @ConfigurationProperty( // <b class="conum">(2)</b>
        name = "prefix",
        description = "The Log body prefix message",
        displayName = "Log Prefix",
        type = "string")
    private String prefix;

    @Override
    public void configure() throws Exception {
        from("direct::start") // <b class="conum">(3)</b>
            .choice()
                .when(simple("${header.prefix} != ''"))
                    .log("${header.prefix} ${body}")
                .otherwise()
                    .log("Output ${body}")
            .endChoice();
    }
}</code></pre></div></div><div class="colist arabic"><ol><li><p>The <code>@Action</code> annotation indicates the action definition.</p></li><li><p>The <code>@ConfigurationProperty</code> annotation indicates definitions of user interface form controls. For details, see <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</a>.</p></li><li><p>This is the action implementation.</p></li></ol></div><div class="paragraph"><p>This Java code uses Syndesis annotations, which means that the <code>extension-maven-plugin</code> can automatically generate the action definition. In the extension definition JSON file, the action definition will look like this:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">{
  "id": "log-body-with-prefix",
  "name": "Log body with prefix",
  "description": "A simple body log with a prefix",
  "descriptor": {
    "kind": "ENDPOINT", <b class="conum">(1)</b>
    "entrypoint": "direct:log", <b class="conum">(2)</b>
    "resource": "class:io.syndesis.extension.log.LogAction", <b class="conum">(3)</b>
    "inputDataShape": {
      "kind": "none"
    },
    "outputDataShape": {
      "kind": "none"
    },
    "propertyDefinitionSteps": [ {
      "description": "extension-properties",
      "name": "extension-properties",
      "properties": { <b class="conum">(4)</b>
        "prefix": {
          "componentProperty": false,
          "deprecated": false,
          "description": "The Log body prefix message",
          "displayName": "Log Prefix",
          "javaType": "java.lang.String",
          "kind": "parameter",
          "required": false,
          "secret": false,
          "type": "string",
          "raw": false
        }
      }
    } ]
  },
  "actionType": "step"
}</code></pre></div></div><div class="colist arabic"><ol><li><p>The type of action is <code>ENDPOINT</code>. The runtime invokes a Camel endpoint to execute the action that this step implements.</p></li><li><p>This is the Camel endpoint to invoke. It is the <code>from</code> specification in the route.</p></li><li><p>This is the class that implements <code>RoutesBuilder</code>.</p></li><li><p>These are the properties that the action defined in this custom step exposes to the integrator who will be adding this step to an integration. In Syndesis, each value that the integrator specifies in the user interface gets mapped to a message header that has the same name as the property. In this example, the integrator will see one input field, with the <strong>Log Prefix</strong> display name. For more information, see <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</a>.</p></li></ol></div></div><div class="sect4"><h5 id="example-route-builder-spring-boot_step-alternatives">Example of developing a Camel route with <code>RouteBuilder</code> and Spring Boot</h5><div class="paragraph"><p>You can implement a custom step by developing an action as a Camel route with the support of the <code>RouteBuilder</code> class as well as Spring Boot. In this example, Spring Boot is the facility for registering a <code>RouteBuilder</code> object in a Camel context. Syndesis invokes this route in the same way that it invokes any other Camel route.</p></div><div class="paragraph"><p>To implement the example that creates a step that logs the body of a message with an optional prefix, you can write something like this:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java">import io.syndesis.extension.api.annotations.Action;
import io.syndesis.extension.api.annotations.ConfigurationProperty;
import org.apache.camel.builder.RouteBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ActionsConfiguration {

    @Action( // <b class="conum">(1)</b>
        id = "log-body-with-prefix",
        name = "Log body with prefix",
        description = "A simple body log with a prefix",
        entrypoint = "direct:log")
    @ConfigurationProperty( // <b class="conum">(2)</b>
        name = "prefix",
        description = "The Log body prefix message",
        displayName = "Log Prefix",
        type = "string")
    @Bean // <b class="conum">(3)</b>
    public RouteBuilder logBodyWithprefix() {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                from("direct::start") // <b class="conum">(4)</b>
                    .choice()
                        .when(simple("${header.prefix} != ''"))
                            .log("${header.prefix} ${body}")
                        .otherwise()
                            .log("Output ${body}")
                    .endChoice();
             }
        };
    }
}</code></pre></div></div><div class="colist arabic"><ol><li><p>The <code>@Action</code> annotation indicates the action definition.</p></li><li><p>The <code>@ConfigurationProperty</code> annotation indicates definitions of user interface form controls. For details, see <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</a>.</p></li><li><p>Register the <code>RouteBuilder</code> object as a bean.</p></li><li><p>This is the action implementation.</p></li></ol></div><div class="paragraph"><p>This Java code uses Syndesis annotations, which means that the <code>extension-maven-plugin</code> can automatically generate the action definition. In the extension definition JSON file, the action definition will look like this:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">{
  "id": "log-body-with-prefix",
  "name": "Log body with prefix",
  "description": "A simple body log with a prefix",
  "descriptor": {
    "kind": "ENDPOINT", <b class="conum">(1)</b>
    "entrypoint": "direct:log", <b class="conum">(2)</b>
    "inputDataShape": {
      "kind": "none"
    },
    "outputDataShape": {
      "kind": "none"
    },
    "propertyDefinitionSteps": [ {
      "description": "extension-properties",
      "name": "extension-properties",
      "properties": { <b class="conum">(3)</b>
        "prefix": {
          "componentProperty": false,
          "deprecated": false,
          "description": "The Log body prefix message",
          "displayName": "Log Prefix",
          "javaType": "java.lang.String",
          "kind": "parameter",
          "required": false,
          "secret": false,
          "type": "string",
          "raw": false
        }
      }
    } ]
  },
  "actionType": "step"
}</code></pre></div></div><div class="colist arabic"><ol><li><p>The type of action is <code>ENDPOINT</code>. The runtime invokes a Camel endpoint to execute the action that this step implements.</p></li><li><p>This is the Camel endpoint to invoke. It is the <code>from</code> specification in the route.</p></li><li><p>These are the properties that the action defined in this custom step exposes to the integrator who will be adding this step to an integration. In Syndesis, each value that the integrator specifies in the user interface gets mapped to a message header that has the same name as the property. In this example, the integrator will see one input field, with the <strong>Log Prefix</strong> display name. For more details, see <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</a>.</p></li></ol></div><div class="admonitionblock important"><table><tr><td class="icon"><div class="title">Important</div></td><td class="content"><div class="paragraph"><p>To make configuration classes discoverable by Spring Boot, you must list them in a file named <code>META-INF/spring.factories</code>, for example:</p></div><div class="paragraph"><p><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.company.ActionsConfiguration</code></p></div></td></tr></table></div><div class="paragraph"><p>With Spring Boot, every bean that you eventually register in your configuration classes is available to the Camel context. For details, see the Spring Boot documentation for <a href="https://docs.spring.io/spring-boot/docs/1.5.11.RELEASE/reference/html/boot-features-developing-auto-configuration.html">Creating your own auto-configuration</a>.</p></div></div><div class="sect4"><h5 id="example-camel-bean_step-alternatives">Example of using a Camel bean</h5><div class="paragraph"><p>You can implement a custom step by developing an action as a Camel bean processor. To implement the example that creates a step that logs the body of a message with an optional prefix, you can write something like this:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java">import org.apache.camel.Body;
import org.apache.camel.Handler;
import org.apache.camel.Header;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.syndesis.extension.api.annotations.Action;
import io.syndesis.extension.api.annotations.ConfigurationProperty;

@Action(
    id = "log-body-with-prefix",
    name = "Log body with prefix",
    description = "A simple body log with a prefix")
public class LogAction  {
    private static final Logger LOGGER = LoggerFactory.getLogger(LogAction.class);

    @ConfigurationProperty(
        name = "prefix",
        description = "The Log body prefix message",
        displayName = "Log Prefix",
        type = "string")
    private String prefix;

    @Handler // <b class="conum">(1)</b>
    public void process(@Header("prefix") String prefix, @Body Object body) {
        if (prefix == null) {
            LOGGER.info("Output {}", body);
        } else {
            LOGGER.info("{} {}", prefix, body);
        }
    }
}</code></pre></div></div><div class="colist arabic"><ol><li><p>This is the function that implements the action.</p></li></ol></div><div class="paragraph"><p>This Java code uses Syndesis annotations, which means that the <code>extension-maven-plugin</code> can automatically generate the action definition. In the extension definition JSON file, the action definition will look like this:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">{
  "id": "log-body-with-prefix",
  "name": "Log body with prefix",
  "description": "A simple body log with a prefix",
  "descriptor": {
    "kind": "BEAN", <b class="conum">(1)</b>
    "entrypoint": "io.syndesis.extension.log.LogAction::process", <b class="conum">(2)</b>
    "inputDataShape": {
      "kind": "none"
    },
    "outputDataShape": {
      "kind": "none"
    },
    "propertyDefinitionSteps": [ {
      "description": "extension-properties",
      "name": "extension-properties",
      "properties": {
        "prefix": { <b class="conum">(3)</b>
          "componentProperty": false,
          "deprecated": false,
          "description": "The Log body prefix message",
          "displayName": "Log Prefix",
          "javaType": "java.lang.String",
          "kind": "parameter",
          "required": false,
          "secret": false,
          "type": "string",
          "raw": false
        }
      }
    } ]
  },
  "actionType": "step"
}</code></pre></div></div><div class="colist arabic"><ol><li><p>The type of the action is <code>BEAN</code>. The runtime invokes a Camel bean processor to execute the action in this custom step.</p></li><li><p>This is the Camel bean to invoke.</p></li><li><p>These are the properties that the action defined in this custom step exposes to the integrator who will be adding this step to an integration. In Syndesis, each value that the integrator specifies in the user interface gets mapped to a message header that has the same name as the property. In this example, the integrator will see one input field, with the <strong>Log Prefix</strong> display name. For more details, see <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</a>.</p></li></ol></div><div class="paragraph"><p>When you use beans, you might find it convenient to inject user properties into the bean instead of retrieving them from the exchange header. To do this, implement getter and setter methods for the properties that you want to get injected. The action implementation would look like this:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java">import org.apache.camel.Body;
import org.apache.camel.Handler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.syndesis.extension.api.annotations.Action;
import io.syndesis.extension.api.annotations.ConfigurationProperty;

@Action(
    id = "log-body-with-prefix",
    name = "Log body with prefix",
    description = "A simple body log with a prefix")
public class LogAction  {
    private static final Logger LOGGER = LoggerFactory.getLogger(LogAction.class);

    @ConfigurationProperty(
        name = "prefix",
        description = "The Log body prefix message",
        displayName = "Log Prefix",
        type = "string")
    private String prefix;

    public void setPrefix(String prefix) { // <b class="conum">(1)</b>
        this.prefix = prefix;
    }

    public String getPrefix() { // <b class="conum">(2)</b>
        return prefix;
    }

    @Handler
    public void process(@Body Object body) {
        if (this.prefix == null) {
            LOGGER.info("Output {}", body);
        } else {
            LOGGER.info("{} {}", this.prefix, body);
        }
    }
}</code></pre></div></div><div class="colist arabic"><ol><li><p>This is the property setter method.</p></li><li><p>This is the property getter method.</p></li></ol></div></div><div class="sect4"><h5 id="example-step-api_step-alternatives">Example of using the Syndesis Step API</h5><div class="paragraph"><p>You can implement a custom step by using the Syndesis <code>Step</code> API. This provides a way to interact with runtime route creation. You can use any method provided by the <code>ProcessorDefinition</code> class and you can create more complex routes. Information for the Syndesis API is at <a href="http://javadoc.io/doc/io.syndesis.extension/extension-api" class="bare">http://javadoc.io/doc/io.syndesis.extension/extension-api</a>.</p></div><div class="paragraph"><p>Here is an example of a step extension that uses the Syndesis <code>Step</code> API to implement a split action:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java">import java.util.Map;
import java.util.Optional;

import io.syndesis.extension.api.Step;
import io.syndesis.extension.api.annotations.Action;
import io.syndesis.extension.api.annotations.ConfigurationProperty;
import org.apache.camel.CamelContext;
import org.apache.camel.model.ProcessorDefinition;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.Expression;
import org.apache.camel.builder.Builder;
import org.apache.camel.processor.aggregate.AggregationStrategy;
import org.apache.camel.processor.aggregate.UseOriginalAggregationStrategy;
import org.apache.camel.spi.Language;

@Action(id = "split", name = "Split", description = "Split your exchange")
public class SplitAction implements Step {

    @ConfigurationProperty(
        name = "language",
        displayName = "Language",
        description = "The language used for the expression")
    private String language;

    @ConfigurationProperty(
        name = "expression",
        displayName = "Expression",
        description = "The expression used to split the exchange")
    private String expression;

    public String getLanguage() {
        return language;
    }

    public void setLanguage(String language) {
        this.language = language;
    }

    public String getExpression() {
        return expression;
    }

    public void setExpression(String expression) {
        this.expression = expression;
    }

    @Override
    public Optional&lt;ProcessorDefinition&gt; configure(
            CamelContext context,
            ProcessorDefinition route,
            Map&lt;String, Object&gt; parameters) { // <b class="conum">(1)</b>

        String languageName = language;
        String expressionDefinition = expression;

        if (ObjectHelper.isEmpty(languageName) &amp;&amp; ObjectHelper.isEmpty(expressionDefinition)) {
            route = route.split(Builder.body());
        } else if (ObjectHelper.isNotEmpty(expressionDefinition)) {

            if (ObjectHelper.isEmpty(languageName)) {
                languageName = "simple";
            }

            final Language splitLanguage = context.resolveLanguage(languageName);
            final Expression splitExpression = splitLanguage.createExpression(expressionDefinition);
            final AggregationStrategy aggreationStrategy = new UseOriginalAggregationStrategy(null, false);

            route = route.split(splitExpression).aggregationStrategy(aggreationStrategy);
        }

        return Optional.of(route);
    }
}</code></pre></div></div><div class="colist arabic"><ol><li><p>This is the implementation of the action that the custom step performs.</p></li></ol></div><div class="paragraph"><p>This Java code uses Syndesis annotations, which means that the <code>extension-maven-plugin</code> can automatically generate the action definition. In the extension definition JSON file, the action definition will look like this:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">{
  "id": "split",
  "name": "Split",
  "description": "Split your exchange",
  "descriptor": {
    "kind": "STEP", <b class="conum">(1)</b>
    "entrypoint": "io.syndesis.extension.split.SplitAction", <b class="conum">(2)</b>
    "inputDataShape": {
      "kind": "none"
    },
    "outputDataShape": {
      "kind": "none"
    },
    "propertyDefinitionSteps": [ {
      "description": "extension-properties",
      "name": "extension-properties",
      "properties": {
        "language": {
          "componentProperty": false,
          "deprecated": false,
          "description": "The language used for the expression",
          "displayName": "Language",
          "javaType": "java.lang.String",
          "kind": "parameter",
          "required": false,
          "secret": false,
          "type": "string",
          "raw": false
        },
        "expression": {
          "componentProperty": false,
          "deprecated": false,
          "description": "The expression used to split the exchange",
          "displayName": "Expression",
          "javaType": "java.lang.String",
          "kind": "parameter",
          "required": false,
          "secret": false,
          "type": "string",
          "raw": false
        }
      }
    } ]
  },
  "tags": [],
  "actionType": "step"
}</code></pre></div></div><div class="colist arabic"><ol><li><p>The type of the action is <code>STEP</code>.</p></li><li><p>This is the class that is implementing the <code>Step</code> interface.</p></li></ol></div><div class="paragraph"><div class="title">Additional resource</div><p>For details about user interface properties, see <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</a>.</p></div></div></div><div class="sect3"><h4 id="develop-connector-extensions_extensions">Example of developing a connector extension</h4><div class="paragraph"><p>If Syndesis does not provide a connector for the application or service that you want to connect to in an integration, an experienced developer can code an extension that contributes a new connector to Syndesis. This documentation provides an introduction to developing a connector extension. For details about developing a connector, see <a href="https://syndesis.io/docs/connectors/">Developing Syndesis connectors</a> on the Syndesis community site.</p></div><div class="admonitionblock important"><table><tr><td class="icon"><div class="title">Important</div></td><td class="content"><div class="paragraph"><p>For connector extensions, it is not yet possible to automatically generate the extension definition JSON file from Java code.</p></div></td></tr></table></div><div class="paragraph"><p>A connector is essentially a proxy for a Camel component. A connector configures the underlying component and creates endpoints according to options that are defined in the extension definition and in user-supplied options that the Syndesis web interface collects.</p></div><div class="paragraph"><p>The connector extension definition extends the extension definition that is required for step extensions with the following additional data structures:</p></div><div class="ulist"><ul><li><p><code>componentScheme</code></p><div class="paragraph"><p>Defines the Camel component that the connector uses. You can set <code>componentScheme</code> for the connector or for actions. If you set <code>componentScheme</code> for both the connector and an action, the setting for the action has precedence.</p></div></li><li><p><code>connectorCustomizers</code></p><div class="paragraph"><p>Specifies a list of classes that implement the <a href="https://github.com/syndesisio/syndesis/blob/master/app/integration/component-proxy/src/main/java/io/syndesis/integration/component/proxy/ComponentProxyCustomizer.java">ComponentProxyCustomizer</a> class. Each class customizes the behavior of a connector. For example, a class might manipulate properties before they are applied to the underlying component/endpoint, or a class might add pre/post endpoint logic. For each class, specify the full class name of the implementation, for example, <code>com.mycomponent.MyCustomizer</code>. You can set <code>connectorCustomizers</code> on actions as well as connectors. According to what is set, Syndesis applies customizers to the connector first and then to actions.</p></div></li><li><p><code>connectorFactory</code></p><div class="paragraph"><p>Defines the class that implements the <a href="https://github.com/syndesisio/syndesis/blob/master/app/integration/component-proxy/src/main/java/io/syndesis/integration/component/proxy/ComponentProxyFactory.java">ComponentProxyFactory</a> class, which creates and/or configures the underlying component/endpoint. Specify the full class name of the implementation. You can set <code>connectorFactory</code> for the connector or for actions. Actions have precedence.</p></div></li></ul></div><div class="paragraph"><div class="title">Customizer example</div><p>The following customizer example sets up a <code>DataSource</code> from individual options:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java">public class DataSourceCustomizer implements ComponentProxyCustomizer, CamelContextAware {
    private final static Logger LOGGER = LoggerFactory.getLogger(DataSourceCustomizer.class);

    private CamelContext camelContext;

    @Override
    public void setCamelContext(CamelContext camelContext) { // <b class="conum">(1)</b>
        this.camelContext = camelContext;
    }

    @Override
    public CamelContext getCamelContext() { // <b class="conum">(1)</b>
        return this.camelContext;
    }

    @Override
    public void customize(ComponentProxyComponent component, Map&lt;String, Object&gt; options) {
        if (!options.containsKey("dataSource")) {
            if (options.containsKey("user") &amp;&amp; options.containsKey("password") &amp;&amp; options.containsKey("url")) {
                try {
                    BasicDataSource ds = new BasicDataSource();

                    consumeOption(camelContext, options, "user", String.class, ds::setUsername); // <b class="conum">(2)</b>
                    consumeOption(camelContext, options, "password", String.class, ds::setPassword); // <b class="conum">(2)</b>
                    consumeOption(camelContext, options, "url", String.class, ds::setUrl); // <b class="conum">(2)</b>

                    options.put("dataSource", ds);
                } catch (@SuppressWarnings("PMD.AvoidCatchingGenericException") Exception e) {
                    throw new IllegalArgumentException(e);
                }
            } else {
                LOGGER.debug("Not enough information provided to set-up the DataSource");
            }
        }
    }
}</code></pre></div></div><div class="colist arabic"><ol><li><p>&nbsp;By implementing <code>CamelContextAware</code>, Syndesis injects the Camel context and then invokes the customize method.</p></li><li><p>&nbsp;Processes options and then removes them from the options map.</p></li></ol></div><div class="paragraph"><div class="title">Example of injecting properties</div><p>If the customizer respects Java bean conventions, you can also inject the properties, as shown in this revision of the previous example:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java">public class DataSourceCustomizer implements ComponentProxyCustomizer, CamelContextAware {
    private final static Logger LOGGER = LoggerFactory.getLogger(DataSourceCustomizer.class);

    private CamelContext camelContext;
    private String userName;
    private String password;
    private String url;

    @Override
    public void setCamelContext(CamelContext camelContext) { // <b class="conum">(1)</b>
        this.camelContext = camelContext;
    }

    @Override
    public CamelContext getCamelContext() { // <b class="conum">(1)</b>
        return this.camelContext;
    }

    public void setUserName(String userName) { //<b class="conum">(1)</b>
      this.userName = userName;
    }

    public String getUserName() { // <b class="conum">(2)</b>
      return this.userName;
    }

    public void setPassword(String password) { // <b class="conum">(2)</b>
      this.password = password;
    }

    public String getPassword() { // <b class="conum">(2)</b>
      return this.password;
    }

    public void setUrl(String url) { // <b class="conum">(2)</b>
      this.url = url;
    }

    public String getUrl() { // <b class="conum">(2)</b>
      return this.url;
    }

    @Override
    public void customize(ComponentProxyComponent component, Map&lt;String, Object&gt; options) {
        if (!options.containsKey("dataSource")) {
            if (userName != null &amp;&amp; password != null &amp;&amp; url != null) {
                try {
                    BasicDataSource ds = new BasicDataSource();
                    ds.setUserName(userName);
                    ds.setPassword(password);
                    ds.setUrl(url);

                    options.put("dataSource", ds);
                } catch (@SuppressWarnings("PMD.AvoidCatchingGenericException") Exception e) {
                    throw new IllegalArgumentException(e);
                }
            } else {
                LOGGER.debug("Not enough information provided to set-up the DataSource");
            }
        }
    }
}</code></pre></div></div><div class="colist arabic"><ol><li><p>&nbsp;By implementing <code>CamelContextAware</code>, Syndesis injects the Camel context and then invokes the customize method. This sample code overrides the <code>setCamelContext()</code> and <code>getCamelContext()</code> methods, and sets the user name.</p></li><li><p>&nbsp;The sample code processes the injected options and automatically removes them from the options map.</p></li></ol></div><div class="paragraph"><div class="title">Using a customizer to configure before/after logic</div><p>You can use a customizer to configure before/after logic as shown in this example:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java">public class AWSS3DeleteObjectCustomizer implements ComponentProxyCustomizer {
  	private String filenameKey;

    public void setFilenameKey(String filenameKey) {
      this.filenameKey = filenameKey;
    }

    public String getFilenameKey() {
        return this.filenameKey;
    }

    @Override
    public void customize(ComponentProxyComponent component, Map&lt;String, Object&gt; options) {
      	component.setBeforeProducer(this::beforeProducer);
    }

    public void beforeProducer(final Exchange exchange) throws IOException {
      	exchange.getIn().setHeader(S3Constants.S3_OPERATION, S3Operations.deleteObject);

    	  if (filenameKey != null) {
    		    exchange.getIn().setHeader(S3Constants.KEY, filenameKey);
    	  }
    }
}</code></pre></div></div><div class="paragraph"><div class="title">Customizing behavior of <code>ComponentProxyComponent</code></div><p>The <a href="https://github.com/syndesisio/syndesis/blob/master/app/integration/component-proxy/src/main/java/io/syndesis/integration/component/proxy/ComponentProxyFactory.java">ComponentProxyFactory</a> class creates and/or configures the underlying component/endpoint. To customize the behavior of the <a href="https://github.com/syndesisio/syndesis/blob/master/app/integration/component-proxy/src/main/java/io/syndesis/integration/component/proxy/ComponentProxyComponent.java">ComponentProxyComponent</a> object that <code>ComponentProxyFactory</code> creates, you can override any of the following methods:</p></div><div class="ulist"><ul><li><p><code>createDelegateComponent()</code></p><div class="paragraph"><p>Syndesis invokes this method when the proxy starts and it is used to eventually create a dedicated instance of the component with the scheme defined by the <code>componentScheme</code> option.</p></div><div class="paragraph"><p>The default behavior of this method is to determine if any of the connector/action options applies at the component level. Only in the case that the same option cannot be applied at the endpoint, the method creates a custom component instance and configures it according to the applicable options.</p></div></li><li><p><code>configureDelegateComponent()</code></p><div class="paragraph"><p>Syndesis invokes this method only if a custom component instance has been created to configure additional behavior of the delegated component instance.</p></div></li><li><p><code>createDelegateEndpoint()</code></p><div class="paragraph"><p>Syndesis invokes this method when the proxy creates the endpoint and by default creates the endpoint by using Camel catalog facilities.</p></div></li><li><p><code>configureDelegateEndpoint()</code></p><div class="paragraph"><p>After the delegated endpoint has been created, Syndesis invokes this method to configure additional behavior of the delegated endpoint instance, for example:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java">public class IrcComponentProxyFactory implements ComponentProxyFactory {

    @Override
    public ComponentProxyComponent newInstance(String componentId, String componentScheme) {
        return new ComponentProxyComponent(componentId, componentScheme) {
            @Override
            protected void configureDelegateEndpoint(ComponentDefinition definition, Endpoint endpoint, Map&lt;String, Object&gt; options) throws Exception {
                if (!(endpoint instanceof IrcEndpoint)) {
                    throw new IllegalStateException("Endpoint should be of type IrcEndpoint");
                }

                final IrcEndpoint ircEndpoint = (IrcEndpoint)endpoint;
                final String channels = (String)options.remove("channels");

                if (ObjectHelper.isNotEmpty(channels)) {
                    ircEndpoint.getConfiguration().setChannel(
                        Arrays.asList(channels.split(","))
                    );
                }
            }
        };
    }
}</code></pre></div></div></li></ul></div></div><div class="sect3"><h4 id="develop-library-extensions_extensions">How to develop library extensions</h4><div class="paragraph"><p>A library extension provides a resource that an integration requires at runtime. A library extension does not contribute steps or connectors to Syndesis.</p></div><div class="paragraph"><p>When you save an integration, you can optionally select one or more imported library extensions that you want to include with the integration.</p></div><div class="paragraph"><p>A library extension does not define any actions. Here is a sample definition for a library extension:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">{
  "schemaVersion" : "v1",
  "name" : "Example Library Extension",
  "description" : "Syndesis Extension for adding a runtime library",
  "extensionId" : "io.syndesis.extensions:syndesis-library",
  "version" : "1.0.0",
  "tags" : [ "my-libraries-extension" ],
  "extensionType" : "Libraries"
}</code></pre></div></div><div class="paragraph"><p>See also the sample library extension here: <a href="https://github.com/syndesisio/syndesis-extensions" class="bare">https://github.com/syndesisio/syndesis-extensions</a></p></div><div class="paragraph"><p>Other than the lack of actions, the structure of a library extension is the same as the structure of a step or connector extension.</p></div><div class="paragraph"><p>In a Maven project that creates a library extension, to add dependencies that are not available from a Maven repository, specify a <code>system</code> dependency, for example:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.company&lt;/groupId&gt;
    &lt;artifactId&gt;my-library-extension&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
    &lt;scope&gt;system&lt;/scope&gt;
    &lt;systemPath&gt;${project.basedir}/lib/my-library-extension.jar&lt;/systemPath&gt;
&lt;/dependency&gt;</code></pre></div></div></div><div class="sect3"><h4 id="creating-jdbc-driver-library-extensions_extensions">Creating JDBC driver library extensions</h4><div class="paragraph"><p>To connect to a SQL database other than Apache Derby, MySQL, and PostgreSQL, you can create a library extension that wraps a JDBC driver for the database you want to connect to. After uploading this extension to Syndesis, the Syndesis-provided <strong>Database</strong> connector can access the driver to validate and create connections to the proprietary database. You do not create a new connector for your particular database.</p></div><div class="paragraph"><p>The Syndesis open source community provides a project for creating an extension that wraps a JDBC driver.</p></div><div class="paragraph"><p>Package one driver only in an extension. This makes it easier to manage the extension as part of managing your particular database. However, it is possible to create a library extension that wraps more than one driver.</p></div><div class="paragraph"><div class="title">Prerequisites</div><p>To use the Syndesis project, you must have a GitHub account.</p></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>Ensure access to the JDBC driver for the database you want to connect to by doing one of the following:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Confirm that the driver is in a Maven repository.</p></li><li><p>Download the driver.</p></li></ol></div></li><li><p>In a browser tab, go to <a href="https://github.com/syndesisio/syndesis-extensions" class="bare">https://github.com/syndesisio/syndesis-extensions</a></p></li><li><p>Fork the <code>syndesis-extensions</code> repository to your GitHub account.</p></li><li><p>Create a local clone from your fork.</p></li><li><p>In your <code>syndesis-extensions</code> clone:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>If the driver is not in a Maven repository, copy the driver into the <code>syndesis-library-jdbc-driver/lib</code> folder.</p></li><li><p>Edit the <code>syndesis-library-jdbc-driver/pom.xml</code> file:</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>Update the value of the <code>Name</code> element to be a name that you choose for this extension.</p></li><li><p>Update the value of the <code>Description</code> element to provide helpful information about this extension.</p></li><li><p>If you have copied the driver into <code>syndesis-library-jdbc-driver/lib</code> ensure that the <code>systemPath</code> in <code>pom.xml</code> points to that driver file. Optionally change the <code>groupId</code>, <code>artifactId</code> and <code>version</code> to reflect proper values according to the driver.</p></li><li><p>If the driver is in a Maven repository, ensure that a reference to that Maven dependency is in the <code>pom.xml</code> file.</p></li><li><p>Examine the rest of the content of the <code>pom.xml</code> file and change any relevant metadata as needed.</p></li></ol></div></li><li><p>Execute <code>./mvnw -pl :syndesis-library-jdbc-driver clean package</code> to build the extension.</p></li></ol></div></li></ol></div><div class="paragraph"><p>The generated <code>.jar</code> file is in the <code>syndesis-library-jdbc-driver/target</code> folder. Import this <code>.jar</code> file as an extension in Syndesis.</p></div><div class="paragraph"><p>After you import a library extension, when you save an integration in Syndesis you can optionally select the imported library extension and associate it with the integration.</p></div></div></div><div class="sect2"><h3 id="adding-extensions_custom">Adding and managing extensions</h3><div class="paragraph"><p>Extensions let you add customizations to Syndesis so you can integrate applications the way you want to. After you start using customizations provided in extensions, you can identify the integrations that use those customizations. This is helpful to do before you update or delete an extension.</p></div><div class="paragraph"><p>The following topics provide details:</p></div><div class="ulist"><ul><li><p><a href="#making-extensions-available_add-extension">Making custom features available</a></p></li><li><p><a href="#identifying-extension-use_add-extension">Identifying integrations that use extensions</a></p></li><li><p><a href="#updating-extensions_add-extension">Updating extensions</a></p></li><li><p><a href="#deleting-extensions_add-extension">Deleting extensions</a></p></li></ul></div><div class="sect3"><h4 id="making-extensions-available_add-extension">Making custom features available</h4><div class="paragraph"><p>To make a custom feature available for use in an integration, upload the extension to Syndesis.</p></div><div class="ulist"><div class="title">Prerequisites</div><ul><li><p>A developer has provided a <code>.jar</code> file that contains a Syndesis extension.</p></li></ul></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the left Syndesis panel, click <strong>Customizations</strong> &gt; <strong>Extensions</strong>.</p></li><li><p>Click <strong>Import Extension</strong>.</p></li><li><p>Drag and drop, or choose, the <code>.jar</code> file that contains the extension that you want to upload.</p><div class="paragraph"><p>Syndesis immediately tries to validate that the file contains an extension. If there is a problem, Syndesis displays a message about the error. You must coordinate with the extension developer to obtain an updated <code>.jar</code> file, which you can then try to upload.</p></div></li><li><p>Review the extension details.</p><div class="paragraph"><p>After Syndesis validates the file, it extracts and displays the extension&#8217;s name, ID, description, and type. The type indicates whether the extension defines a custom connector, or one or more custom steps for operating on data between connections, or a runtime library extension (including a JDBC driver).</p></div><div class="paragraph"><p>For a connector extension, Syndesis displays the actions that are available to a connection that is created from this custom connector. In the extension, the developer might have provided an icon that Syndesis can use to represent the application connections created from this connector. While you do not see this icon in the extension details page, it appears when you create connections from the custom connector. If the extension developer did not provide an icon in the extension, then Syndesis generates an icon.</p></div><div class="paragraph"><p>For a step extension, Syndesis displays the name of each custom step that the extension defines.</p></div><div class="paragraph"><p>For a library extension, Syndesis includes the imported Maven dependencies in the integration runtime classpath. You must ensure that the imported Maven dependencies do not conflict with other dependencies that are already used in the integration (including any other library extension, such as a JDBC driver).</p></div></li><li><p>Click <strong>Import Extension</strong>. Syndesis makes the custom connector or custom step(s) available and displays the extension&#8217;s details page.</p></li></ol></div><div class="ulist"><div class="title">Additional resources</div><ul><li><p><a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#creating-connections-from-custom-connectors_connections">Creating a connection from a custom connectors</a>.</p></li><li><p><a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#add-custom-step_create">Adding a custom step</a></p></li><li><p><a href="https://zregvart.github.io/syndesis.io/manual/connecting/#connecting-to-proprietary-databases_db">Connecting to a proprietary database</a></p></li></ul></div></div><div class="sect3"><h4 id="identifying-extension-use_add-extension">Identifying integrations that use extensions</h4><div class="paragraph"><p>Before you update or delete an extension, you should identify the integrations that use customizations that are provided by that extension.</p></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the left Syndesis panel, click <strong>Customizations</strong> &gt; <strong>Extensions</strong>.</p></li><li><p>In the list of extensions, find the entry for the extension that you want to update or delete and click its <strong>Details</strong> button.</p></li></ol></div><div class="paragraph"><div class="title">Result</div><p>Syndesis displays details about the extension including a list of any integrations that use a customization provided by the extension.</p></div></div><div class="sect3"><h4 id="updating-extensions_add-extension">Updating extensions</h4><div class="paragraph"><p>When a developer updates an extension, you can upload the updated <code>.jar</code> file to implement the updates in your integrations.</p></div><div class="paragraph"><div class="title">Prerequisite</div><p>A developer has provided you with an updated <code>.jar</code> file for an extension that you previously uploaded.</p></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In Syndesis, in the left panel, click <strong>Customizations</strong> &gt; <strong>Extensions</strong>.</p></li><li><p>At the right of the entry for the extension that you want to update, click <strong>Update</strong>.</p></li><li><p>Click in the dotted-line box to navigate to and select the updated <code>.jar</code> file, and click <strong>Open</strong>.</p></li><li><p>Confirm that the extension details are correct and click <strong>Import Extension</strong>.</p></li><li><p>In the details page for the updated extension, determine which integrations use the connector or custom step(s) defined in the extension.</p></li></ol></div><div class="paragraph"><p>It is up to you to know exactly what is required to update each integration that uses a custom connector or a custom step from the updated extension. At the very least, you must republish each integration that uses a customization defined in the updated extension.</p></div><div class="paragraph"><p>In some cases, you might need to edit the integration to change or add configuration details for a customization. You must communicate with the extension developer to understand how to update integrations.</p></div></div><div class="sect3"><h4 id="deleting-extensions_add-extension">Deleting extensions</h4><div class="paragraph"><p>You can delete an extension even if a running integration uses a step that is provided by that extension or uses a connection that was created from a connector that was provided by that extension. After you delete an extension, you cannot start an integration that uses a customization that was provided by that extension.</p></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>In the left Syndesis panel, click <strong>Customizations</strong> &gt; <strong>Extensions</strong>.</p></li><li><p>In the list of extensions, find the entry for the extension that you want to delete and click <strong>Delete</strong>, which appears at the right of the entry.</p></li></ol></div><div class="paragraph"><div class="title">Results</div><p>There might be stopped or draft integrations that use a customization provided by an extension that you delete. To run one of these integrations, you will need to edit the integration to remove the customization.</p></div><div class="ulist"><div class="title">Additional resources</div><ul><li><p><a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#identifying-extension-use_add-extension">Identifying extension use</a></p></li><li><p><a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#updating-extensions_add-extension">Updating extensions</a></p></li></ul></div></div></div></div></div></div><div id="footer"><div id="footer-text">Last updated 2020-10-18 11:28:31 UTC</div></div></div><footer class="page-footer text-center"><div class="row"><section class="col-md-6"><i class="fab fa-3x fa-github" aria-hidden="true"></i><h4>Get the source code</h4><p>Stay tuned to contribute or build your own solution.</p><p class="link-button"><a href="https://github.com/syndesisio" rel="nofollow" target="_blank" class="btn btn-primary">Syndesis on GitHub</a></p></section><section class="col-md-6"><i class="fas fa-3x fa-comments"></i><h4>Connect with us</h4><p>Chat with the Syndesis community.</p><p class="link-button"><a href="https://gitter.im/syndesisio/community" rel="nofollow" target="_blank" class="btn btn-primary">syndesisio on Gitter</a></p></section></div><div class="rh-logo"><section><a href="https://www.redhat.com" rel="nofollow" title="Red Hat, Inc." target="_blank"><img width="128" height="42" src="/images/redhatnew.svg" alt="Red Hat, Inc."></a></section></div></footer></div></body></html>