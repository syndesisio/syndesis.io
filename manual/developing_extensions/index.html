<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]--><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Asciidoctor 1.5.8"><title>Developing Syndesis extensions</title><link rel="stylesheet" href="/css/syndesis.css?t=1607699890167"><link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet"><link rel="icon" type="image/png" href="https://syndesis.io/images/favicon.png"></head><body class="page book toc2 toc-left" id="developing-extensions_extensions"><div id="wrapper"><a href="https://github.com/syndesisio" class="github-corner hidden-md-down" aria-label="View source on Github" rel="nofollow" target="_blank"><svg width="74" height="74" viewBox="0 0 250 250" style="fill:#fff;z-index:2000;color:#0088ce;mix-blend-mode:screen;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7
          120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9
          125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6
          C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0
          C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1
          C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4
          C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9
          C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5
          C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9
          L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><nav class="navbar topnav fixed-top navbar-inverse bg-primary navbar-toggleable-md sps sps--abv"><button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#top-nav" aria-controls="top-nav" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button> <a href="/" title="Syndesis - Open source integration platform"><svg id="artwork" xmlns="http://www.w3.org/2000/svg" width="190px" height="39.33px" viewBox="0 0 1300 300" preserveAspectRatio="xMidYMin slice"><defs><style>.cls-1{fill:#9adde8}.cls-2{fill:#49badc}.cls-3{fill:#fff}</style></defs><title>Syndesis - Open source integration platform</title><polygon class="cls-1" points="129.95 98.77 33.99 144.38 122.22 167.37 218.18 121.75 129.95 98.77"/><polygon class="cls-2" points="218.18 121.75 218.18 121.75 122.22 167.37 242.17 198.61 218.18 121.75"/><polygon class="cls-1" points="154.99 86.86 131 10 10 67.52 129.95 98.77 154.99 86.86"/><polygon class="cls-2" points="33.99 144.38 129.95 98.77 10 67.52 10 67.52 33.99 144.38"/><polygon class="cls-2" points="189.64 25.27 131 10 154.99 86.86 213.63 102.14 189.64 25.27"/><polygon class="cls-2" points="38.54 164 62.53 240.86 121.17 256.13 121.17 256.13 97.18 179.27 97.18 179.27 38.54 164"/><polygon class="cls-1" points="242.17 198.61 122.22 167.37 97.18 179.27 121.17 256.13 242.17 198.61"/><path class="cls-3" d="M358.91,210.23c-23.57,0-43.44-17.22-44.06-41.6H329.2c.41,22.74,17.21,29.3,37.09,29.3,16.6,0,35.65-9.63,35.65-28.48,0-14.76-10.65-21.73-23.15-25.82-24-8-60.45-15.58-60.45-47.55,0-25.82,23.77-40,47.13-40,19.47,0,44.88,6.77,48.15,35.25H399.28c-.41-18.24-17-23-32.17-23-15.37,0-34.43,7.79-34.43,25.82,0,42,83.61,23,83.61,74C416.29,200.39,388.62,210.23,358.91,210.23Z"/><path class="cls-3" d="M484.32,143.22l-54.51-84h17l45.29,71.52L537.4,59.2h14.34l-54.1,83.61v64.34H484.32Z"/><path class="cls-3" d="M572.24,59.2H587.4L669,189.32h.41V59.2h13.32v148h-16.8L586,79.28h-.41V207.15H572.24Z"/><path class="cls-3" d="M760,59.2c48.56,0,76.23,25,76.23,74s-27.67,74-76.23,74H720V59.2Zm3.27,135.66c41.6,0,58.61-24.39,58.61-61.69,0-43.64-25.61-62.91-67.62-61.68h-20.9V194.86Z"/><path class="cls-3" d="M870.19,207.15V59.2H958.1V71.49H883.51v53.08h71.73v12.29H883.51v58h77.67v12.29Z"/><path class="cls-3" d="M1030.44,210.23c-23.56,0-43.44-17.22-44.05-41.6h14.34c.41,22.74,17.21,29.3,37.09,29.3,16.6,0,35.66-9.63,35.66-28.48,0-14.76-10.66-21.73-23.16-25.82-24-8-60.45-15.58-60.45-47.55,0-25.82,23.77-40,47.13-40,19.47,0,44.88,6.77,48.16,35.25h-14.35c-.41-18.24-17-23-32.17-23-15.37,0-34.43,7.79-34.43,25.82,0,42,83.61,23,83.61,74C1087.82,200.39,1060.16,210.23,1030.44,210.23Z"/><path class="cls-3" d="M1121.63,207.15V58.58H1135V207.15Z"/><path class="cls-3" d="M1212.62,210.23c-23.56,0-43.44-17.22-44.06-41.6h14.35c.41,22.74,17.21,29.3,37.09,29.3,16.6,0,35.66-9.63,35.66-28.48,0-14.76-10.66-21.73-23.16-25.82-24-8-60.45-15.58-60.45-47.55,0-25.82,23.77-40,47.13-40,19.47,0,44.88,6.77,48.16,35.25H1253c-.41-18.24-17-23-32.17-23-15.37,0-34.43,7.79-34.43,25.82,0,42,83.61,23,83.61,74C1270,200.39,1242.34,210.23,1212.62,210.23Z"/></svg></a><div class="collapse navbar-collapse" id="top-nav"><ul class="navbar-nav ml-auto mt-2 mt-md-0 mr-lg-4"><li class="nav-item ml-lg-3 ml-0"><a class="nav-link" href="/quickstart">Quickstart</a></li><li class="nav-item ml-lg-3 ml-0"><a class="nav-link" href="/docs">Documentation</a></li><li class="nav-item ml-lg-3 ml-0"><a class="nav-link" href="/blog">Blog</a></li><li class="nav-item ml-lg-3 ml-0"><a class="nav-link" href="/faq">FAQ</a></li><li class="nav-item ml-lg-3 ml-0"><a class="nav-link" href="/community">Community</a></li><li class="nav-item ml-lg-3 ml-0"><a class="nav-link" href="/about">About</a></li></ul></div></nav><div class="article"><div id="header"><h1>Developing Syndesis extensions</h1><div id="toc" class="toc2"><div id="toctitle">On this page</div><ul class="sectlevel1"><li><a href="#procedure-for-developing-extensions_extensions">General procedure for developing extensions</a></li><li><a href="#description-kinds-extensions_extensions">Description of the kinds of extensions</a></li><li><a href="#overview-extension-content-structure_extensions">Overview of extension content and structure</a></li><li><a href="#about-extension-definitions_extensions">Requirements in an extension definition JSON file</a></li><li><a href="#descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</a></li><li><a href="#using-maven-to-generate-extension-definitions_extensions">Description of Maven plugin that supports extensions</a></li><li><a href="#how-to-specify-data-shapes_extensions">How to specify data shapes in extensions</a></li><li><a href="#develop-step-extensions_extensions">Examples of developing step extensions</a></li><li><a href="#develop-connector-extensions_extensions">Example of developing a connector extension</a></li><li><a href="#develop-library-extensions_extensions">How to develop library extensions</a></li><li><a href="#creating-jdbc-driver-library-extensions_extensions">Creating JDBC driver library extensions</a></li></ul></div></div><div id="content"><div id="preamble"><div class="sectionbody"><div class="paragraph"><p>If Syndesis does not provide a feature that is needed to create an integration, then an expert developer can code an extension that provides the needed behavior. The Syndesis extension repository, <a href="https://github.com/syndesisio/syndesis-extensions" class="bare">https://github.com/syndesisio/syndesis-extensions</a>, contains examples of extensions.</p></div><div class="paragraph"><p>A business integrator shares requirements with a developer who codes the extension. The developer provides a <code>.jar</code> file that contains the extension. The business integrator uploads the <code>.jar</code> file in Syndesis to make the custom connector, custom step(s), or library resource available for use in Syndesis.</p></div><div class="paragraph"><p>The Fuse Tooling plugin to Red Hat Developer Studio provides a wizard that helps you develop a step extension or a connector extension. It is a matter of personal preference whether you choose to develop a step extension or a connector extension in Developer Studio or in some other IDE. For information about using the Developer Studio plugin, see <a href="https://access.redhat.com/documentation/en-us/red_hat_fuse/7.7/html-single/tooling_user_guide/index#igniteextension">Developing extensions for Syndesis integrations</a>.</p></div><div class="paragraph"><p>In this document, the following topics outline the procedure, describe the requirements, and provide additional examples for developing extensions in an IDE that you choose.</p></div><div class="ulist"><ul><li><p><a href="#procedure-for-developing-extensions_extensions">General procedure for developing extensions</a></p></li><li><p><a href="#description-kinds-extensions_extensions">Description of the kinds of extensions</a></p></li><li><p><a href="#overview-extension-content-structure_extensions">Overview of extension content and structure</a></p></li><li><p><a href="#about-extension-definitions_extensions">Requirements in an extension definition JSON file</a></p></li><li><p><a href="#descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</a></p></li><li><p><a href="#using-maven-to-generate-extension-definitions_extensions">Description of Maven plugin that supports extensions</a></p></li><li><p><a href="#how-to-specify-data-shapes_extensions">How to specify data shapes in extensions</a></p></li><li><p><a href="#develop-step-extensions_extensions">Examples of developing step extensions</a></p></li><li><p><a href="#develop-connector-extensions_extensions">Example of developing a connector extension</a></p></li><li><p><a href="#develop-library-extensions_extensions">How to develop library extensions</a></p></li><li><p><a href="#creating-jdbc-driver-library-extensions_extensions">Creating JDBC driver library extensions</a></p></li></ul></div></div></div><div class="sect1"><h2 id="procedure-for-developing-extensions_extensions">General procedure for developing extensions</h2><div class="sectionbody"><div class="paragraph"><p>Before you start to develop an extension, become familiar with the tasks that you will need to accomplish.</p></div><div class="ulist"><div class="title">Prerequisites</div><ul><li><p>Familiarity with <a href="https://maven.apache.org/">Maven</a></p></li><li><p>Familiarity with <a href="https://camel.apache.org/">Camel</a> if you are developing an extension that provides a connector or that provides an integration step that operates on data between connections</p></li><li><p>Experience programming</p></li></ul></div><div class="admonitionblock caution"><table><tr><td class="icon"><div class="title">Caution</div></td><td class="content"><div class="paragraph"><p>An integration pod runs in a Java process with a flat classpath. To avoid version clashes, make sure that the dependencies that an extension uses are aligned with the imported bill of materials (BOM) from all of these sources:</p></div><div class="ulist"><ul><li><p><code>org.springframework.boot:spring-boot-dependencies:$SPRING_BOOT_VERSION</code></p></li><li><p><code>org.apache.camel:camel-spring-boot-dependencies:$CAMEL_VERSION</code></p></li><li><p><code>io.syndesis.integration:integration-bom:$SYNDESIS_VERSION</code></p></li></ul></div><div class="paragraph"><p>If there are additional dependencies that are not part of the imported BOMs, you must:</p></div><div class="ulist"><ul><li><p>Package them in the extension JAR file that is in the <code>lib</code> directory.</p></li><li><p>Omit them from the <code>dependencies</code> property of the extension&#8217;s JSON descriptor file.</p></li></ul></div></td></tr></table></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>Obtain an understanding of what the extended feature must do. Talk to your business colleague to understand the feature requirements.</p></li><li><p>Determine whether you need to develop a step extension, a connector extension, or a library extension.</p></li><li><p>Set up the Maven project in which to develop the extension.</p></li><li><p>If you are developing a step extension:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Decide whether to implement it as a Camel route or implement it by using the Syndesis <code>Step</code> API. Information for the Syndesis API is at <a href="http://javadoc.io/doc/io.syndesis.extension/extension-api" class="bare">http://javadoc.io/doc/io.syndesis.extension/extension-api</a>.</p></li><li><p>If you choose to implement the extension as a Camel route, decide whether to implement XML fragments, a <code>RouteBuilder</code> class, or a bean.</p></li><li><p>In your Maven project, specify the required metadata, such as the <code>schemaVersion</code>, extension <code>name</code>, <code>extensionId</code>, and so on.</p></li></ol></div></li><li><p>Code the classes that implement the feature.</p></li><li><p>Add dependencies to the project&#8217;s <code>pom.xml</code> file.</p></li><li><p>For connector and library extensions, and for step extensions that you implement in XML, create the JSON file that defines the extension.</p><div class="paragraph"><p>For step extensions that you implement in Java, Maven can generate the JSON extension definition file for you when you specify corresponding data structure values in your Maven project.</p></div></li><li><p>Run Maven to build the extension and create the extension&#8217;s JAR file.</p></li><li><p>Test the extension by uploading the JAR file to a Syndesis development environment.</p></li><li><p>Provide the JAR file that packages the extension to your business colleague, who uploads it to a Syndesis production environment. When you provide the JAR file, let your business colleague know about any configuration settings that require information beyond what appears in the Syndesis web interface.</p></li></ol></div></div></div><div class="sect1"><h2 id="description-kinds-extensions_extensions">Description of the kinds of extensions</h2><div class="sectionbody"><div class="paragraph"><p>An extension defines one of the following:</p></div><div class="ulist"><ul><li><p>One or more custom steps that operate on integration data between connections. Each custom step performs one action. This is a step extension.</p></li><li><p>A library resource that an integration runtime uses. For example, a library extension can provide a JDBC driver for connecting to a proprietary SQL database, such as Oracle.</p></li><li><p>A single custom connector for creating connections to a particular application or service that you want to integrate. This is a connector extension.</p><div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">Syndesis can use an OpenAPI document to create a connector for a REST API client. See <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#developing-rest-api-client-connectors_custom">Develop a REST API client connector</a>.</td></tr></table></div></li></ul></div><div class="paragraph"><p>A business integrator shares requirements with a developer who codes the extension. The developer provides a <code>.jar</code> file that contains the extension. The business integrator uploads the <code>.jar</code> file in Syndesis to make the custom connector, custom step(s), or library resource available for use within Syndesis.</p></div><div class="paragraph"><p>An extension <code>.jar</code> file that you upload to Syndesis always contains exactly one extension.</p></div><div class="paragraph"><p>For an example of uploading and using an extension that provides a step that operates on data between connections, see the <a href="https://zregvart.github.io/syndesis.io/manual/tutorials/#amq-to-rest-api_tutorials">AMQ to REST API sample integration tutorial</a>.</p></div></div></div><div class="sect1"><h2 id="overview-extension-content-structure_extensions">Overview of extension content and structure</h2><div class="sectionbody"><div class="paragraph"><p>An extension is a collection of classes, dependencies, and resources that are packaged in a <code>.jar</code> file.</p></div><div class="paragraph"><p>Syndesis uses Spring Boot to load an extension. Consequently, you must package an extension according to Spring Boot&#8217;s executable JAR format. For example, ensure that you use the <code>ZipEntry.STORED()</code> method to save a nested JAR file.</p></div><div class="paragraph"><p>The structure of a <code>.jar</code> file that packages an extension is as follows:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code>extension.jar
|
+- META-INF
|  |
|  +- syndesis
|     |
|     +- syndesis-extension-definition.json <b class="conum">(1)</b>
|
+- mycompany
|  |
|  +-project
|    |
|    +-YourClasses.class <b class="conum">(2)</b>
|
+- lib <b class="conum">(3)</b>
  |
  +-dependency1.jar
  |
  +-dependency2.jar</code></pre></div></div><div class="colist arabic"><ol><li><p>A JSON schema file that specifies the data structures that define the extension. This is referred to as the extension definition JSON file.</p></li><li><p>The Java classes that implement the behavior that the extension provides.</p></li><li><p>Additional dependencies that are required to build and execute the custom feature.</p></li></ol></div></div></div><div class="sect1"><h2 id="about-extension-definitions_extensions">Requirements in an extension definition JSON file</h2><div class="sectionbody"><div class="paragraph"><p>Each extension must have a <code>.json</code> file that defines the extension by specifying values for data structures such as name, description, supported actions, and dependencies. For each extension type, the following table indicates whether Maven can generate the extension definition JSON file and which data structures are required.</p></div><table class="tableblock frame-all grid-all stretch"><colgroup><col style="width:50%"><col style="width:16.6666%"><col style="width:33.3334%"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Extension Type</th><th class="tableblock halign-left valign-top">Maven Can Generate Extension Definition</th><th class="tableblock halign-left valign-top">Required Data Structures</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Step extension in Java</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>schemaVersion</code><br><code>name</code><br><code>description</code><br><code>version</code><br><code>extensionId</code><br><code>extensionType</code><br><code>actions</code><br><code>dependencies</code> *</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Step extension in XML</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>schemaVersion</code><br><code>name</code><br><code>description</code><br><code>version</code><br><code>extensionId</code><br><code>extensionType</code><br><code>actions</code><br><code>dependencies</code> *</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Connector extension</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>schemaVersion</code><br><code>name</code><br><code>description</code><br><code>version</code><br><code>extensionId</code><br><code>extensionType</code><br><code>properties</code><br><code>actions</code><br><code>dependencies</code> *<br><code>componentScheme</code><br><code>connectorCustomizers</code><br><code>connectorFactory</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Library extension</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>schemaVersion</code><br><code>name</code><br><code>description</code><br><code>version</code><br><code>extensionId</code><br><code>extensionType</code><br><code>dependencies</code> *</p></td></tr></tbody></table><div class="paragraph"><p>*While specification of <code>dependencies</code> is not strictly required, in practice, there are almost always dependencies that you need to specify.</p></div><div class="paragraph"><p>Typically, an extension definition file has the following layout:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">{
  "schemaVersion": "v1",
  "name": "",
  "description": "",
  "version": "",
  "extensionId": "",
  "extensionType": "",
  "properties": {
  },
  "actions": [
  ],
  "dependencies": [
  ],
}</code></pre></div></div><div class="ulist"><ul><li><p><strong>schemaVersion</strong> defines the version of the extension definition schema. Internally, Syndesis uses <strong>schemaVersion</strong> to determine how to map the extension definition to the internal model. This allows extensions that were developed against an old version of Syndesis to be deployed on newer versions of Syndesis.</p></li><li><p><strong>name</strong> is the name of the extension. When you upload an extension to Syndesis, this name appears.</p></li><li><p><strong>description</strong> is any useful information that you want to specify. Syndesis does not operate on this value.</p></li><li><p><strong>version</strong> is for your convenience to help you distinguish updates to an extension. Syndesis does not operate on this value.</p></li><li><p><strong>extensionId</strong> defines a unique ID for the extension. This should be unique at least across a Syndesis environment.</p></li><li><p><strong>extensionType</strong> indicates to Syndesis what the extension provides. As of Syndesis version 1.3, the following extension types are supported:</p><div class="ulist"><ul><li><p><code>Steps</code></p></li><li><p><code>Connectors</code></p></li><li><p><code>Libraries</code></p></li></ul></div></li><li><p><strong>properties</strong> at the top level in a connector extension is required. It controls what Syndesis displays when a Syndesis user selects the connector to create a connection. This <code>properties</code> object contains a set of properties for each form control for creating a connection. For example:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">"myControlName": {
  "deprecated": true|false,
  "description": "",
  "displayName": "",
  "group": "",
  "kind": "",
  "label": "",
  "required": true|false,
  "secret": true|false,
  "javaType": "",
  "type": "",
  "defaultValue": "",
  "enum": {
  }
}</code></pre></div></div><div class="paragraph"><p>In connector extensions, nested <code>properties</code> objects define HTML form controls for configuring connection actions. In step extensions, the <code>actions</code> object contains a <code>properties</code> object. The <code>properties</code> object defines a set of properties for each form control for configuring the step. See also: <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</a>.</p></div></li><li><p><strong>actions</strong> defines the operations that a connector can perform or the operation that a step between connections can perform. Only connector and step extensions use actions that you specify. The format for an action specification looks like this:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">{
    "id": "",
    "name": "",
    "description": "",
    "actionType": "step|connector",
    "descriptor": {
    }
}</code></pre></div></div><div class="ulist"><ul><li><p><strong>id</strong> is a unique ID for the action. This should be unique at least within a Syndesis environment.</p></li><li><p><strong>name</strong> is the action name that appears in Syndesis. An integrator sees this value as the name of a connection action or as the name of a step that operates on integration data between connections.</p></li><li><p><strong>description</strong> is the action description that appears in Syndesis. Use this field to help the integrator understand what the action does.</p></li><li><p><strong>actionType</strong> indicates whether the action is performed by a connection or a step that is between connections.</p></li><li><p><strong>descriptor</strong> specifies nested attributes such as <code>kind</code>, <code>entrypoint</code>, <code>inputDataType</code>, <code>outputDatatype</code> and more.</p></li></ul></div></li><li><p><strong>dependencies</strong> defines the resources that this extension requires Syndesis to provide.</p><div class="paragraph"><p>Define a dependency as follows:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">{
  "type": "MAVEN",
  "id"   : "org.apache.camel:camel-telegram:jar:2.21.0"
}</code></pre></div></div><div class="ulist"><ul><li><p><strong>type</strong> indicates the type of the dependency. Specify <strong>MAVEN</strong>. (It is expected that other types will be supported in the future.)</p></li><li><p><strong>id</strong> is the ID of the Maven dependency, which is a Maven GAV.</p></li></ul></div></li></ul></div></div></div><div class="sect1"><h2 id="descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</h2><div class="sectionbody"><div class="paragraph"><p>In connector extensions and step extensions, specify user interface properties in the extension definition JSON file or in Java class files. The settings of these properties define the HTML form controls that Syndesis displays when a Syndesis user creates a connection, configures a connection action, or configures a step that is provided by the extension.</p></div><div class="paragraph"><p>You must specify properties for each form control that you want to appear in the extension&#8217;s user interface in the Syndesis console. For each form control, specify some or all properties in any order.</p></div><div class="paragraph"><div class="title">Example of user interface property specifications</div><p>In the JSON file that is part of the IRC connector, the top level <code>properties</code> object defines the HTML form controls that appear after a Syndesis user selects the IRC connector to create a connection. There are three sets of property definitions for three form controls: <code>hostname</code>, <code>password</code>, and <code>port</code>:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">"properties": {
   "hostname": {
     "description": "IRC Server hostname",
     "displayName": "Hostname",
     "labelHint": "Hostname of the IRC server to connect to",
     "order": "1",
     "required": true,
     "secret": false,
     "type": "string"
   },
   "password": {
     "description": "IRC Server password",
     "displayName": "Password",
     "labelHint": "Required if IRC server requires it to join",
     "order": "3",
     "required": false,
     "secret": true,
     "type": "string"
   },
   "port": {
     "description": "IRC Server port",
     "displayName": "Port",
     "labelHint": "Port of the IRC server to connect to",
     "order": "2",
     "required": true,
     "secret": false,
     "tags": [],
     "type": "int"
   }
 },</code></pre></div></div><div class="paragraph"><p>Based on these property specifications, when a Syndesis user selects the IRC connector, Syndesis displays the following dialog. After the user enters values in the two required fields and clicks <strong>Next</strong>, Syndesis creates an IRC connection that is configured with the values that the Syndesis user enters.</p></div><div class="paragraph"><p><span class="image"><img src="images/integrating-applications/IRC-create-connection-fields.png" alt="Hostname" width="Password" height="Port"></span></p></div><div class="paragraph"><div class="title">About <code>properties</code> objects in extension definition JSON files</div><p>In a connector extension:</p></div><div class="ulist"><ul><li><p>The toplevel <code>properties</code> object is required. It controls what Syndesis displays when a Syndesis user selects the connector to create a connection. This <code>properties</code> object contains a set of properties for each form control for creating a connection.</p></li><li><p>In the <code>actions</code> object, there is a <code>properties</code> object for each action. In each of these <code>properties</code> objects, there is a set of properties for each form control for configuring that action.</p></li></ul></div><div class="paragraph"><p>In a step extension, the <code>actions</code> object contains a <code>properties</code> object. The <code>properties</code> object defines a set of properties for each form control for configuring the step. The JSON hierarchy looks like this:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">"actions": [
   {
      ...

      "propertyDefinitionSteps": [
         {
            ...

            "properties":
               {
                  "control-ONE": {
                     "type": "string",
                     "displayName": "Topic Name",
                     "order": "2",
                     ...,
                     }

                  "control-TWO": {
                     "type": "boolean",
                     "displayName": "Urgent",
                     "order": "3",
                     ...
                     }

                  "control-THREE": {
                     "type": "textarea",
                     "displayName": "Comment",
                     "order": "1",
                     ...,
                     }
 } } ]</code></pre></div></div><div class="paragraph"><div class="title">About user interface properties in Java files</div><p>To define user interface form controls in Java files, import <code>io.syndesis.extension.api.annotations.ConfigurationProperty</code> in each class file that defines user configuration of a connection, action, or step. For each form control that you want the Syndesis console to display, specify the <code>@ConfigurationProperty</code> annotation, followed by a list of properties. For information about the properties that you can specify, see the user interface property reference table at the end of this section.</p></div><div class="paragraph"><p>The following code shows property definitions for one form control. This code is in the example of developing a Camel route with <code>RouteBuilder</code>:</p></div><div class="listingblock"><div class="content"><pre>public class LogAction extends RouteBuilder {
    @ConfigurationProperty(
        name = "prefix",
        description = "The Log body prefix message",
        displayName = "Log Prefix",
        type = "string")</pre></div></div><div class="paragraph"><p>The following code shows property definitions for two controls. This code is from the example of using the Syndesis Step API:</p></div><div class="listingblock"><div class="content"><pre>@Action(id = "split", name = "Split", description = "Split your exchange")
public class SplitAction implements Step {

    @ConfigurationProperty(
        name = "language",
        displayName = "Language",
        description = "The language used for the expression")
    private String language;

    @ConfigurationProperty(
        name = "expression",
        displayName = "Expression",
        description = "The expression used to split the exchange
     private String language;</pre></div></div><div class="paragraph"><div class="title">Descriptions of control form input types</div><p>In the set of properties for each HTML form control, the <code>type</code> property defines the input type of the form control that Syndesis displays. For details about HTML form input types, see <a href="https://www.w3schools.com/html/html_form_input_types.asp">https://www.w3schools.com/html/html_form_input_types.asp</a>.</p></div><div class="paragraph"><p>The following table lists the possible input types for Syndesis form controls. In the set of properties for a control, if you specify a <code>type</code> value that is unknown, Syndesis displays an input field that accepts one line of text. That is, the default is <code>"type": "text"</code>.</p></div><table class="tableblock frame-all grid-all stretch"><colgroup><col style="width:20%"><col style="width:40%"><col style="width:40%"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Value of <code>type</code> property</th><th class="tableblock halign-left valign-top">HTML</th><th class="tableblock halign-left valign-top">Syndesis displays</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;input type="checkbox"&gt;</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">A checkbox that the user can select or not select.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>duration</code></p></td><td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock">A custom control that lets the Syndesis user select a unit of time: milliseconds, seconds, minutes, hours, or days. The user also enters a number and Syndesis returns a number of milliseconds. For example:<br><code>"properties": {<br>&nbsp;&nbsp;&nbsp;"period": {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"type": "duration"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"defaultValue": 60000,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"description": "Period",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"displayName": "Period",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"labelHint": "Delay between integration executions.",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"required": true,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"secret": false,<br>&nbsp;&nbsp;&nbsp;}<br>}</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>hidden</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;input type="hidden"&gt;</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">This field does not appear in the Syndesis console. You can use other properties to specify data that is associated with this field, for example, textual data of some kind. While Syndesis users cannot see or modify this data, if a user selects <strong>View Source</strong> for a Syndesis page, hidden fields are visible in the source display. Therefore, do not use hidden fields for security purposes.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>int</code>, <code>integer</code>, <code>long</code>, <code>number</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;input type="number"&gt;</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">An input field that accepts a number.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>password</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;input type="password"&gt;</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">An input field in which Syndesis masks the characters that the user enters, typically with asterisks.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>select</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">A <code>&lt;select&gt;</code> element, for example:<br><code>&lt;select name="targets"&gt;<br>&nbsp;&nbsp;&lt;option value="queue"&gt;Queue&lt;/option&gt;<br>&nbsp;&nbsp;&lt;option value="topic"&gt;Topic&lt;/option&gt;<br>&lt;/select&gt;</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">A drop-down list with an entry for each label/value pair that you specify in the form controlâ€™s <code>enum</code> property.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>text</code>, <code>string</code>, or any unknown value</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;input type="text"&gt;`</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">An input field that accepts one line of text.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>textarea</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;input type="textarea"</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">A textarea element is used</p></td></tr></tbody></table><div class="paragraph"><div class="title">Descriptions of control form user interface properties</div><p>In a connector or step extension, for each HTML form control that appears in the Syndesis console, you can specify one or more of the properties described in the following table. For details about HTML form input types, see <a href="https://www.w3schools.com/html/html_form_input_types.asp">https://www.w3schools.com/html/html_form_input_types.asp</a>.</p></div><table class="tableblock frame-all grid-all stretch"><colgroup><col style="width:25%"><col style="width:25%"><col style="width:50%"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Property name</th><th class="tableblock halign-left valign-top">Type</th><th class="tableblock halign-left valign-top">Description</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>type</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Controls the kind of form control that Syndesis displays. See the previous table for details.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>cols</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If set for a <code>textarea</code> field, controls the number of columns initially displayed for the textarea control.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>controlHint</code> or <code>controlTooltip</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If set, the value is mapped to the HTML <code>title</code> attribute of the form control element. Just like other elements that have a <code>title</code> attribute, when the cursor hovers over the control, a tooltip appears. The content of the tooltip comes from the value of the <code>controlHint</code> or <code>controlTooltip</code> property.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>dataList</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">array</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If the value of the <code>type</code> property is <code>text</code>, Syndesis uses the value of the <code>dataList</code> property to add typeahead support. Specify an array of strings.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>defaultValue</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Varies according to the value of the <code>type</code> property.</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Syndesis initially displays this value in the form field. The type of the setting of the <code>defaultValue</code> property should match the value of the <code>type</code> property. For example, when the <code>type</code> property is set to <code>number</code>, the <code>defaultValue</code> setting should be a number. If the user does not change this initial field value, Syndesis uses <code>defaultValue</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>description</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If set, Syndesis displays this value below the form control. Typically, this is a short, useful message about the control.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>displayName</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Syndesis displays this value.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>enum</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">array</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If set, Syndesis overrides any setting for the <code>type</code> property and implements a <code>select</code> control. Specify the array as a set of <code>label</code> and <code>value</code> attributes. The <code>label</code> attribute appears in the user interface as the select item&#8217;s label. The <code>value</code> attribute becomes the value for the corresponding select item.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>labelHint</code> or <code>labelTooltip</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If set, a <code>?</code> icon appears next to the display name. When the Syndesis user clicks the <code>?</code> icon, the value of the <code>labelHint</code> property displays.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>max</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If set for a <code>number</code> field, defines the highest acceptable value.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>min</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If set for a <code>number</code> field, defines the lowest acceptable value.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>multiple</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If set to <code>true</code> for a <code>select</code> field or for a field that has the <code>enum</code> property set, Syndesis displays a multi-select control instead of a select drop-down.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>order</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Determines the order of controls in the Syndesis console. Syndesis applies ascending order, that is, the control that has <code>"order": "1"</code> appears first. Without specification of the <code>order</code> property, Syndesis displays controls in the order in which the JSON file defines them.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>placeholder</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If set, Syndesis displays this value in a hazed font in an input field to help the user understand the expected input.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>required</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Controls whether or not the <code>required</code> attribute is set on the control. If true, then the Syndesis user must enter a value for this control.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>rows</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If the value of the <code>type</code> property is <code>textarea</code>, the value of the <code>rows</code> property controls the number of rows initially displayed in the textarea control.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>secret</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If specified, Syndesis changes the setting of the control&#8217;s <code>type</code> property to <code>password</code> if that is not already the setting.</p></td></tr></tbody></table></div></div><div class="sect1"><h2 id="using-maven-to-generate-extension-definitions_extensions">Description of Maven plugin that supports extensions</h2><div class="sectionbody"><div class="paragraph"><p>The <code>extension-maven-plugin</code> supports extension development by packaging the extension as a valid Spring Boot module. For step extensions that you implement in Java, this plugin can generate the extension definition JSON file.</p></div><div class="paragraph"><p>In your Maven project&#8217;s <code>pom.xml</code> file, add the following plugin declaration:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
    &lt;groupId&gt;io.syndesis.extension&lt;/groupId&gt;
    &lt;artifactId&gt;extension-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;${syndesis.version}&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
        &lt;goals&gt;
            &lt;goal&gt;generate-metadata&lt;/goal&gt;
            &lt;goal&gt;repackage-extension&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;</code></pre></div></div><div class="paragraph"><p>The <code>extension-maven-plugin</code> defines the following goals:</p></div><div class="ulist"><ul><li><p><strong>generate-metadata</strong> generates the JSON extension definition file that will be in the generated JAR file as follows:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Maven starts with the data structure specifications that are in the <code>META-INF/syndesis/syndesis-extension-definition.json</code> file, if there is one.</p><div class="paragraph"><p>If you are coding in XML, then you must define the extension definition JSON file yourself and it must specify all required data structures.</p></div><div class="paragraph"><p>If you are developing a connector or library extension, then you must define the extension definition JSON file yourself and it must specify all required data structures.</p></div><div class="paragraph"><p>If you are developing a step extension in Java, you can:</p></div><div class="ulist"><ul><li><p>Create the extension definition JSON file yourself.</p></li><li><p>In your Java code, specify annotations that define all required data structures. You do not create an extension definition JSON file.</p></li><li><p>Create an extension definition JSON file and specify some but not all data structures.</p></li></ul></div></li><li><p>For step extensions that you develop in Java, Maven obtains missing specifications from code annotations</p></li><li><p>Maven adds the dependencies list, which specifies dependencies that are provided with a scope of <code>provided</code> and that are managed through the <code>extension-bom</code>.</p></li></ol></div></li><li><p><strong>repackage-extension</strong> packages the extension.</p><div class="ulist"><ul><li><p>Dependencies and related transitive dependencies that are not managed through the <code>extension-bom</code> are in the <code>lib</code> folder of the generated JAR.</p></li><li><p>For library extensions, dependencies whose scope is <code>system</code> are in the <code>lib</code> folder of the generated JAR.</p></li></ul></div></li></ul></div><div class="paragraph"><p>For example, suppose your Maven project has the following <code>pom.xml</code> file:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;

  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;com.company&lt;/groupId&gt;
  &lt;artifactId&gt;my-extension&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;name&gt;MyExtension&lt;/name&gt;
  &lt;description&gt;A Sample Extension&lt;/description&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;dependencyManagement&gt;
    &lt;dependencies&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;io.syndesis.extension&lt;/groupId&gt;
        &lt;artifactId&gt;extension-bom&lt;/artifactId&gt;
        &lt;version&gt;1.3.10&lt;/version&gt;
        &lt;type&gt;pom&lt;/type&gt;
        &lt;scope&gt;import&lt;/scope&gt;
      &lt;/dependency&gt;
    &lt;/dependencies&gt;
  &lt;/dependencyManagement&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;io.syndesis.extension&lt;/groupId&gt;
      &lt;artifactId&gt;extension-api&lt;/artifactId&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.github.lalyos&lt;/groupId&gt;
      &lt;artifactId&gt;jfiglet&lt;/artifactId&gt;
      &lt;version&gt;0.0.8&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
        &lt;version&gt;3.7.0&lt;/version&gt;
        &lt;configuration&gt;
          &lt;source&gt;1.8&lt;/source&gt;
          &lt;target&gt;1.8&lt;/target&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;io.syndesis.extension&lt;/groupId&gt;
        &lt;artifactId&gt;extension-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.3.10&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;goals&gt;
              &lt;goal&gt;generate-metadata&lt;/goal&gt;
              &lt;goal&gt;repackage-extension&lt;/goal&gt;
            &lt;/goals&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;</code></pre></div></div><div class="paragraph"><p>Based on this <code>pom.xml</code> file, the generated extension definition JSON file looks like this:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">{
  "name": "MyExtension",
  "description": "A Sample Extension",
  "extensionId": "com.company:my-extension",
  "version": "1.0.0",
  "dependencies": [ {
    "type": "MAVEN",
    "id": "io.syndesis.extension:extension-api:jar:1.3.10"
  } ],
  "extensionType": "Libraries",
  "schemaVersion": "v1"
}</code></pre></div></div><div class="paragraph"><p>The generated archive has this structure and content:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code>my-extension-1.0.0.jar
|
+- lib
|  |
|Â Â + jfiglet-0.0.8.jar
|
+- META-INF
  |
  +- MANIFEST.MF
     |
     +- syndesis
        |
        +- syndesis-extension-definition.json</code></pre></div></div></div></div><div class="sect1"><h2 id="how-to-specify-data-shapes_extensions">How to specify data shapes in extensions</h2><div class="sectionbody"><div class="paragraph"><p>A data shape holds data type metadata for use by the data mapper. The data mapper transforms this metadata into internal documents that it uses to display the source and target data fields in the data mapper user interface. In an extension definition JSON file for a connector or for a custom step, each action specification defines an input data shape (<code>inputDataShape</code>) and an output data shape (<code>outputDataShape</code>).</p></div><div class="paragraph"><p>When you are developing an extension, it is important to specify data shape properties that allow the data mapper to correctly handle and display the source and target fields. The following data shape properties affect data mapper behavior:</p></div><div class="ulist"><ul><li><p><code>kind</code></p></li><li><p><code>type</code></p></li><li><p><code>specification</code></p></li><li><p><code>name</code></p></li><li><p><code>description</code></p></li></ul></div><div class="paragraph"><div class="title">About the <code>kind</code> property</div><p>The data shape <code>kind</code> property is represented by the <code>DataShapeKinds</code> enum. The possible values for the <code>kind</code> property are:</p></div><div class="ulist"><ul><li><p><code>java</code> indicates that the data type is represented by a Java class. Follow the <code>"kind": "java"</code> declaration by specifying a fully qualified class name for the <code>type</code> property. For example:</p><div class="listingblock"><div class="content"><pre>"outputDataShape": {
     "kind": "java",
     "type": "org.apache.camel.component.telegram.model.IncomingMessage"
},</pre></div></div></li><li><p><code>json-schema</code> indicates that the data type is represented by a JSON schema. When <code>kind</code> is set to <code>json-schema</code>, specify a JSON schema as the value of the data shape&#8217;s <code>specification</code> property. For example:</p><div class="listingblock"><div class="content"><pre>"inputDataShape": {
  "description": "Person data",
  "kind": "json-schema",
  "name": "Person",
  "specification": "{\"$schema\":\"http://json-schema.org/draft-04/schema#\",\"title\":\"Person\",\"type\":\"object\",\"properties\":{\"firstName\":{...}}}"
}</pre></div></div><div class="paragraph"><p>The code for the SAP Concur connector contains <a href="https://github.com/syndesisio/syndesis/blob/master/app/connector/concur/src/main/resources/META-INF/syndesis/connector/concur-api.json">examples of data shapes that are specified by JSON schemas</a>.</p></div></li><li><p><code>json-instance</code> indicates that the data type is represented by a JSON instance. When <code>kind</code> is set to <code>json-instance</code>, specify a JSON instance as the value of the data shape&#8217;s <code>specification</code> property. For example:</p><div class="listingblock"><div class="content"><pre>"inputDataShape": {
  "description": "Person data",
  "kind": "json-instance",
  "name": "Person",
  "specification": "{\"firstName\":\"John\",...}"
}</pre></div></div></li><li><p><code>xml-schema</code> indicates that the data type is represented by an XML schema. When <code>kind</code> is set to <code>xml-schema</code>, specify an XML Schema as the value of the data shape&#8217;s <code>specification</code> property. For example:</p><div class="listingblock"><div class="content"><pre>"inputDataShape": {
  "description": "Person data",
  "kind": "xml-schema",
  "name": "Person",
  "specification": "&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"&gt;...&lt;/xs:schema&gt;"
}</pre></div></div></li><li><p><code>xml-instance</code> indicates that the data type is represented by an XML instance. When <code>kind</code> is set to <code>xml-instance</code>, specify an XML instance as the value of the data shape&#8217;s <code>specification</code> property. For example:</p><div class="listingblock"><div class="content"><pre>"inputDataShape": {
  "description": "Person data",
  "kind": "xml-instance",
  "name": "Person",
  "specification": "&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;Person&gt;&lt;firstName&gt;Jane&lt;/firstName&gt;&lt;/Person&gt;"
}</pre></div></div></li><li><p><code>any</code> indicates that the data type is not structured. For example, it might be a byte array or free format text. The data mapper ignores a data shape when its <code>kind</code> property is set to <code>any</code>. In other words, the data does not appear in the data mapper and therefore you cannot map any fields to or from this data.</p><div class="paragraph"><p>However, for a custom connector, when its <code>kind</code> property is set to <code>any</code>, Syndesis prompts you to specify input and/or output data types when you configure a connection that you have created from the custom connector. This happens when you add a connection to an integration. You can specify the kind of the data shapeâ€™s schema, an appropriate document for the kind of schema that you specify, and a name for the data type.</p></div></li><li><p><code>none</code> indicates that there is no data type. For an input data shape, this indicates that the connection or step does not read data. For an output data shape, this indicates that the connection or step does not modify data. For example, when an input message body is being transferred to an output message body, setting the <code>kind</code> property to <code>none</code> indicates that the data is only passing through. The data mapper ignores data shapes when <code>kind</code> is set to <code>none</code>. In other words, the data does not appear in the data mapper and therefore you cannot map any fields to or from this data.</p></li></ul></div><div class="paragraph"><div class="title">About the <code>type</code> property</div><p>When the value of the <code>kind</code> property is <code>java</code>, the <code>"kind": "java"</code> declaration is followed by a <code>type</code> declaration that specifies a fully qualified Java class name. For example:</p></div><div class="listingblock"><div class="content"><pre>"outputDataShape": {
     "kind": "java",
     "type": "org.apache.camel.component.telegram.model.IncomingMessage"
},</pre></div></div><div class="paragraph"><p>When the <code>kind</code> property is set to anything other than <code>java</code> then any setting for the <code>type</code> property is ignored.</p></div><div class="paragraph"><div class="title">About the <code>specification</code> property</div><p>The setting of the <code>kind</code> property determines the setting of the <code>specification</code> property, as shown in the following table.</p></div><table class="tableblock frame-all grid-all stretch"><colgroup><col style="width:50%"><col style="width:50%"></colgroup><thead><tr><th class="tableblock halign-left valign-top"><code>kind</code> property setting</th><th class="tableblock halign-left valign-top"><code>specification</code> property setting</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>java</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Java inspection result.</p><p class="tableblock">For each extension that you write in Java, use <code>extension-maven-plugin</code> to at least obtain the Java inspection result. The plugin inserts the Java inspection result in the JSON extension definition file as the setting of the <code>specification</code> property. This is the only way to obtain the Java inspection result, which is required for data mapping in Syndesis.</p><p class="tableblock">As a reminder, for step extensions written in Java, <code>extension-maven-plugin</code> generates the JSON extension definition file and populates it with required content. For connector extensions, while <code>extension-maven-plugin</code> inserts the Java inspection result in the JSON extension definition file, you will need to manually add the required content that the plugin does not insert.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>json-schema</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">An actual JSON schema document. The setting cannot be a reference to a document and the JSON schema cannot point to other JSON schema documents by means of references.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>json-instance</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">An actual JSON document that contains example data. The data mapper derives the data types from the example data. The setting cannot be a reference to a document.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>xml-schema</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">An actual XML schema document. The setting cannot be a reference to a document and the XML schema cannot point to other XML schema documents by means of references.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>xml-instance</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">An actual XML instance document. The setting cannot be a reference to a document.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>any</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">The <code>specification</code> property is not required. Any setting is ignored.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>none</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">The <code>specification</code> property is not required. Any setting is ignored.</p></td></tr></tbody></table><div class="paragraph"><div class="title">About the <code>name</code> property</div><p>The data shape <code>name</code> property specifies a human readable name for the data type. The data mapper displays this name in its user interface as the label for the data fields. In the following image, <strong>Person</strong> is an example of where you would see the value of the <code>name</code> property.</p></div><div class="paragraph"><p><span class="image"><img src="images/integrating-applications/PersonDataType.png" alt="Name example"></span></p></div><div class="paragraph"><p>This name also appears in data type indicators in the Syndesis flow visualization.</p></div><div class="paragraph"><div class="title">About the <code>description</code> property</div><p>The data shape <code>description</code> property specifies text that appears as a tooltip when the cursor hovers over the data type name in the data mapper user interface.</p></div></div></div><div class="sect1"><h2 id="develop-step-extensions_extensions">Examples of developing step extensions</h2><div class="sectionbody"><div class="paragraph"><p>A step extension implements one or more custom steps. Each custom step implements one action for processing integration data between connections. The following examples demonstrate the alternatives for developing step extensions:</p></div><div class="ulist"><ul><li><p><a href="#example-route-xml-fragment_step-alternatives">Example of developing a Camel route with XML fragments</a></p></li><li><p><a href="#example-route-builder_step-alternatives">Example of developing a Camel route with <code>RouteBuilder</code></a></p></li><li><p><a href="#example-route-builder-spring-boot_step-alternatives">Example of developing a Camel route with <code>RouteBuilder</code> and Spring Boot</a></p></li><li><p><a href="#example-camel-bean_step-alternatives">Example of using a Camel bean</a></p></li><li><p><a href="#example-step-api_step-alternatives">Example of using the Syndesis Step API</a></p></li></ul></div><div class="paragraph"><p>Syndesis provides custom Java annotations that you can use in conjunction with the <code>syndesis-extension-plugin</code>. When you implement a step extension or a connector extension in Java, you can specify annotations that enable Maven to add action definitions to the extension definition JSON file. To enable annotation processing, add the following dependency to your Maven project:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;io.syndesis.extension&lt;/groupId&gt;
  &lt;artifactId&gt;extension-annotation-processor&lt;/artifactId&gt;
  &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;</code></pre></div></div><div class="paragraph"><p>Because Spring Boot is the integration runtime, to inject beans into a Camel context, be sure to follow standard Spring Boot practices. For example, <a href="https://docs.spring.io/spring-boot/docs/1.5.11.RELEASE/reference/html/boot-features-developing-auto-configuration.html">create an auto configuration class</a> and create beans there. However, the default behavior is that extension code is not subject to package scanning. Consequently, you must create and populate the <code>META-INF/spring.factories</code> file in a step extension.</p></div><div class="sect2"><h3 id="example-route-xml-fragment_step-alternatives">Example of developing a Camel route with XML fragments</h3><div class="paragraph"><p>To develop a custom step, you can implement the action as an XML fragment that is a Camel route that has an input such as <code>direct</code>. The Syndesis runtime invokes this route in the same way that it invokes any other Camel route.</p></div><div class="paragraph"><p>For example, suppose that you want to create a step that logs the body of a message with an optional prefix. The following XML defines a Camel route that does this.</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;routes xmlns="http://camel.apache.org/schema/spring"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
      http://camel.apache.org/schema/spring
      http://camel.apache.org/schema/spring/camel-spring.xsd"&gt;

  &lt;route id="log-body-with-prefix"&gt;
    &lt;from uri="direct:log"/&gt;
    &lt;choice&gt;
      &lt;when&gt;
        &lt;simple&gt;${header.prefix} != ''&lt;/simple&gt;
        &lt;log message="${header.prefix} ${body}"/&gt;
      &lt;/when&gt;
      &lt;otherwise&gt;
        &lt;log message="Output ${body}"/&gt;
      &lt;/otherwise&gt;
    &lt;/choice&gt;
  &lt;/route&gt;

&lt;/routes&gt;</code></pre></div></div><div class="paragraph"><p>When you develop an extension in XML, you must create the extension definition JSON file yourself. For this XML fragment, the <code>src/main/resources/META-INF/syndesis/syndesis-extension-definition.json</code> file could define the action as follows:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">{
  "actionType": "step",
  "id": "log-body-with-prefix",
  "name": "Log body with prefix",
  "description": "A simple body log with a prefix",
  "descriptor": {
    "kind": "ENDPOINT", <b class="conum">(1)</b>
    "entrypoint": "direct:log", <b class="conum">(2)</b>
    "resource": "classpath:log-body-action.xml", <b class="conum">(3)</b>
    "inputDataShape": {
      "kind": "none"
    },
    "outputDataShape": {
      "kind": "none"
    },
  "propertyDefinitionSteps": [ {
    "description": "extension-properties",
    "name": "extension-properties",
    "properties": { <b class="conum">(4)</b>
      "prefix": {
        "componentProperty": false,
        "deprecated": false,
        "description": "The Log body prefix message",
        "displayName": "Log Prefix",
        "javaType": "String",
        "kind": "parameter",
        "required": false,
        "secret": false,
        "type": "string"
      }
    }
  } ]
  }
}</code></pre></div></div><div class="colist arabic"><ol><li><p>The type of the action is set to <code>ENDPOINT</code>. The runtime invokes a Camel endpoint to execute the action provided by this custom step.</p></li><li><p>The Camel endpoint to invoke is <code>direct:log</code>. This is the <code>from</code> specification in the route.</p></li><li><p>This is the location of the XML fragment.</p></li><li><p>These are the properties that the action defined in this custom step exposes to the integrator who will be adding this step to an integration. In Syndesis, each value that the integrator specifies in the user interface gets mapped to a message header that has the same name as the property. In this example, the integrator will see one input field, with the <strong>Log Prefix</strong> display name. For more details, see <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</a>.</p></li></ol></div><div class="admonitionblock warning"><table><tr><td class="icon"><div class="title">Warning</div></td><td class="content"><div class="paragraph"><p>Syndesis does not support full Camel XML configuration. Syndesis supports only the &lt;routes&gt; tag.</p></div></td></tr></table></div></div><div class="sect2"><h3 id="example-route-builder_step-alternatives">Example of developing a Camel route with <code>RouteBuilder</code></h3><div class="paragraph"><p>You can implement a custom step by developing an action as a Camel route with the support of the <code>RouteBuilder</code> class. Such a route has an input such as <code>direct</code>. Syndesis invokes this route in the same way that it invokes any other Camel route.</p></div><div class="paragraph"><p>To implement the example that creates a step that logs the body of a message with an optional prefix, you can write something like this:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java">import org.apache.camel.builder.RouteBuilder;

import io.syndesis.extension.api.annotations.Action;
import io.syndesis.extension.api.annotations.ConfigurationProperty;

@Action( // <b class="conum">(1)</b>
    id = "log-body-with-prefix",
    name = "Log body with prefix",
    description = "A simple body log with a prefix",
    entrypoint = "direct:log")
public class LogAction extends RouteBuilder {
    @ConfigurationProperty( // <b class="conum">(2)</b>
        name = "prefix",
        description = "The Log body prefix message",
        displayName = "Log Prefix",
        type = "string")
    private String prefix;

    @Override
    public void configure() throws Exception {
        from("direct::start") // <b class="conum">(3)</b>
            .choice()
                .when(simple("${header.prefix} != ''"))
                    .log("${header.prefix} ${body}")
                .otherwise()
                    .log("Output ${body}")
            .endChoice();
    }
}</code></pre></div></div><div class="colist arabic"><ol><li><p>The <code>@Action</code> annotation indicates the action definition.</p></li><li><p>The <code>@ConfigurationProperty</code> annotation indicates definitions of user interface form controls. For details, see <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</a>.</p></li><li><p>This is the action implementation.</p></li></ol></div><div class="paragraph"><p>This Java code uses Syndesis annotations, which means that the <code>extension-maven-plugin</code> can automatically generate the action definition. In the extension definition JSON file, the action definition will look like this:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">{
  "id": "log-body-with-prefix",
  "name": "Log body with prefix",
  "description": "A simple body log with a prefix",
  "descriptor": {
    "kind": "ENDPOINT", <b class="conum">(1)</b>
    "entrypoint": "direct:log", <b class="conum">(2)</b>
    "resource": "class:io.syndesis.extension.log.LogAction", <b class="conum">(3)</b>
    "inputDataShape": {
      "kind": "none"
    },
    "outputDataShape": {
      "kind": "none"
    },
    "propertyDefinitionSteps": [ {
      "description": "extension-properties",
      "name": "extension-properties",
      "properties": { <b class="conum">(4)</b>
        "prefix": {
          "componentProperty": false,
          "deprecated": false,
          "description": "The Log body prefix message",
          "displayName": "Log Prefix",
          "javaType": "java.lang.String",
          "kind": "parameter",
          "required": false,
          "secret": false,
          "type": "string",
          "raw": false
        }
      }
    } ]
  },
  "actionType": "step"
}</code></pre></div></div><div class="colist arabic"><ol><li><p>The type of action is <code>ENDPOINT</code>. The runtime invokes a Camel endpoint to execute the action that this step implements.</p></li><li><p>This is the Camel endpoint to invoke. It is the <code>from</code> specification in the route.</p></li><li><p>This is the class that implements <code>RoutesBuilder</code>.</p></li><li><p>These are the properties that the action defined in this custom step exposes to the integrator who will be adding this step to an integration. In Syndesis, each value that the integrator specifies in the user interface gets mapped to a message header that has the same name as the property. In this example, the integrator will see one input field, with the <strong>Log Prefix</strong> display name. For more information, see <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</a>.</p></li></ol></div></div><div class="sect2"><h3 id="example-route-builder-spring-boot_step-alternatives">Example of developing a Camel route with <code>RouteBuilder</code> and Spring Boot</h3><div class="paragraph"><p>You can implement a custom step by developing an action as a Camel route with the support of the <code>RouteBuilder</code> class as well as Spring Boot. In this example, Spring Boot is the facility for registering a <code>RouteBuilder</code> object in a Camel context. Syndesis invokes this route in the same way that it invokes any other Camel route.</p></div><div class="paragraph"><p>To implement the example that creates a step that logs the body of a message with an optional prefix, you can write something like this:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java">import io.syndesis.extension.api.annotations.Action;
import io.syndesis.extension.api.annotations.ConfigurationProperty;
import org.apache.camel.builder.RouteBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ActionsConfiguration {

    @Action( // <b class="conum">(1)</b>
        id = "log-body-with-prefix",
        name = "Log body with prefix",
        description = "A simple body log with a prefix",
        entrypoint = "direct:log")
    @ConfigurationProperty( // <b class="conum">(2)</b>
        name = "prefix",
        description = "The Log body prefix message",
        displayName = "Log Prefix",
        type = "string")
    @Bean // <b class="conum">(3)</b>
    public RouteBuilder logBodyWithprefix() {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                from("direct::start") // <b class="conum">(4)</b>
                    .choice()
                        .when(simple("${header.prefix} != ''"))
                            .log("${header.prefix} ${body}")
                        .otherwise()
                            .log("Output ${body}")
                    .endChoice();
             }
        };
    }
}</code></pre></div></div><div class="colist arabic"><ol><li><p>The <code>@Action</code> annotation indicates the action definition.</p></li><li><p>The <code>@ConfigurationProperty</code> annotation indicates definitions of user interface form controls. For details, see <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</a>.</p></li><li><p>Register the <code>RouteBuilder</code> object as a bean.</p></li><li><p>This is the action implementation.</p></li></ol></div><div class="paragraph"><p>This Java code uses Syndesis annotations, which means that the <code>extension-maven-plugin</code> can automatically generate the action definition. In the extension definition JSON file, the action definition will look like this:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">{
  "id": "log-body-with-prefix",
  "name": "Log body with prefix",
  "description": "A simple body log with a prefix",
  "descriptor": {
    "kind": "ENDPOINT", <b class="conum">(1)</b>
    "entrypoint": "direct:log", <b class="conum">(2)</b>
    "inputDataShape": {
      "kind": "none"
    },
    "outputDataShape": {
      "kind": "none"
    },
    "propertyDefinitionSteps": [ {
      "description": "extension-properties",
      "name": "extension-properties",
      "properties": { <b class="conum">(3)</b>
        "prefix": {
          "componentProperty": false,
          "deprecated": false,
          "description": "The Log body prefix message",
          "displayName": "Log Prefix",
          "javaType": "java.lang.String",
          "kind": "parameter",
          "required": false,
          "secret": false,
          "type": "string",
          "raw": false
        }
      }
    } ]
  },
  "actionType": "step"
}</code></pre></div></div><div class="colist arabic"><ol><li><p>The type of action is <code>ENDPOINT</code>. The runtime invokes a Camel endpoint to execute the action that this step implements.</p></li><li><p>This is the Camel endpoint to invoke. It is the <code>from</code> specification in the route.</p></li><li><p>These are the properties that the action defined in this custom step exposes to the integrator who will be adding this step to an integration. In Syndesis, each value that the integrator specifies in the user interface gets mapped to a message header that has the same name as the property. In this example, the integrator will see one input field, with the <strong>Log Prefix</strong> display name. For more details, see <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</a>.</p></li></ol></div><div class="admonitionblock important"><table><tr><td class="icon"><div class="title">Important</div></td><td class="content"><div class="paragraph"><p>To make configuration classes discoverable by Spring Boot, you must list them in a file named <code>META-INF/spring.factories</code>, for example:</p></div><div class="paragraph"><p><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.company.ActionsConfiguration</code></p></div></td></tr></table></div><div class="paragraph"><p>With Spring Boot, every bean that you eventually register in your configuration classes is available to the Camel context. For details, see the Spring Boot documentation for <a href="https://docs.spring.io/spring-boot/docs/1.5.11.RELEASE/reference/html/boot-features-developing-auto-configuration.html">Creating your own auto-configuration</a>.</p></div></div><div class="sect2"><h3 id="example-camel-bean_step-alternatives">Example of using a Camel bean</h3><div class="paragraph"><p>You can implement a custom step by developing an action as a Camel bean processor. To implement the example that creates a step that logs the body of a message with an optional prefix, you can write something like this:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java">import org.apache.camel.Body;
import org.apache.camel.Handler;
import org.apache.camel.Header;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.syndesis.extension.api.annotations.Action;
import io.syndesis.extension.api.annotations.ConfigurationProperty;

@Action(
    id = "log-body-with-prefix",
    name = "Log body with prefix",
    description = "A simple body log with a prefix")
public class LogAction  {
    private static final Logger LOGGER = LoggerFactory.getLogger(LogAction.class);

    @ConfigurationProperty(
        name = "prefix",
        description = "The Log body prefix message",
        displayName = "Log Prefix",
        type = "string")
    private String prefix;

    @Handler // <b class="conum">(1)</b>
    public void process(@Header("prefix") String prefix, @Body Object body) {
        if (prefix == null) {
            LOGGER.info("Output {}", body);
        } else {
            LOGGER.info("{} {}", prefix, body);
        }
    }
}</code></pre></div></div><div class="colist arabic"><ol><li><p>This is the function that implements the action.</p></li></ol></div><div class="paragraph"><p>This Java code uses Syndesis annotations, which means that the <code>extension-maven-plugin</code> can automatically generate the action definition. In the extension definition JSON file, the action definition will look like this:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">{
  "id": "log-body-with-prefix",
  "name": "Log body with prefix",
  "description": "A simple body log with a prefix",
  "descriptor": {
    "kind": "BEAN", <b class="conum">(1)</b>
    "entrypoint": "io.syndesis.extension.log.LogAction::process", <b class="conum">(2)</b>
    "inputDataShape": {
      "kind": "none"
    },
    "outputDataShape": {
      "kind": "none"
    },
    "propertyDefinitionSteps": [ {
      "description": "extension-properties",
      "name": "extension-properties",
      "properties": {
        "prefix": { <b class="conum">(3)</b>
          "componentProperty": false,
          "deprecated": false,
          "description": "The Log body prefix message",
          "displayName": "Log Prefix",
          "javaType": "java.lang.String",
          "kind": "parameter",
          "required": false,
          "secret": false,
          "type": "string",
          "raw": false
        }
      }
    } ]
  },
  "actionType": "step"
}</code></pre></div></div><div class="colist arabic"><ol><li><p>The type of the action is <code>BEAN</code>. The runtime invokes a Camel bean processor to execute the action in this custom step.</p></li><li><p>This is the Camel bean to invoke.</p></li><li><p>These are the properties that the action defined in this custom step exposes to the integrator who will be adding this step to an integration. In Syndesis, each value that the integrator specifies in the user interface gets mapped to a message header that has the same name as the property. In this example, the integrator will see one input field, with the <strong>Log Prefix</strong> display name. For more details, see <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</a>.</p></li></ol></div><div class="paragraph"><p>When you use beans, you might find it convenient to inject user properties into the bean instead of retrieving them from the exchange header. To do this, implement getter and setter methods for the properties that you want to get injected. The action implementation would look like this:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java">import org.apache.camel.Body;
import org.apache.camel.Handler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.syndesis.extension.api.annotations.Action;
import io.syndesis.extension.api.annotations.ConfigurationProperty;

@Action(
    id = "log-body-with-prefix",
    name = "Log body with prefix",
    description = "A simple body log with a prefix")
public class LogAction  {
    private static final Logger LOGGER = LoggerFactory.getLogger(LogAction.class);

    @ConfigurationProperty(
        name = "prefix",
        description = "The Log body prefix message",
        displayName = "Log Prefix",
        type = "string")
    private String prefix;

    public void setPrefix(String prefix) { // <b class="conum">(1)</b>
        this.prefix = prefix;
    }

    public String getPrefix() { // <b class="conum">(2)</b>
        return prefix;
    }

    @Handler
    public void process(@Body Object body) {
        if (this.prefix == null) {
            LOGGER.info("Output {}", body);
        } else {
            LOGGER.info("{} {}", this.prefix, body);
        }
    }
}</code></pre></div></div><div class="colist arabic"><ol><li><p>This is the property setter method.</p></li><li><p>This is the property getter method.</p></li></ol></div></div><div class="sect2"><h3 id="example-step-api_step-alternatives">Example of using the Syndesis Step API</h3><div class="paragraph"><p>You can implement a custom step by using the Syndesis <code>Step</code> API. This provides a way to interact with runtime route creation. You can use any method provided by the <code>ProcessorDefinition</code> class and you can create more complex routes. Information for the Syndesis API is at <a href="http://javadoc.io/doc/io.syndesis.extension/extension-api" class="bare">http://javadoc.io/doc/io.syndesis.extension/extension-api</a>.</p></div><div class="paragraph"><p>Here is an example of a step extension that uses the Syndesis <code>Step</code> API to implement a split action:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java">import java.util.Map;
import java.util.Optional;

import io.syndesis.extension.api.Step;
import io.syndesis.extension.api.annotations.Action;
import io.syndesis.extension.api.annotations.ConfigurationProperty;
import org.apache.camel.CamelContext;
import org.apache.camel.model.ProcessorDefinition;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.Expression;
import org.apache.camel.builder.Builder;
import org.apache.camel.processor.aggregate.AggregationStrategy;
import org.apache.camel.processor.aggregate.UseOriginalAggregationStrategy;
import org.apache.camel.spi.Language;

@Action(id = "split", name = "Split", description = "Split your exchange")
public class SplitAction implements Step {

    @ConfigurationProperty(
        name = "language",
        displayName = "Language",
        description = "The language used for the expression")
    private String language;

    @ConfigurationProperty(
        name = "expression",
        displayName = "Expression",
        description = "The expression used to split the exchange")
    private String expression;

    public String getLanguage() {
        return language;
    }

    public void setLanguage(String language) {
        this.language = language;
    }

    public String getExpression() {
        return expression;
    }

    public void setExpression(String expression) {
        this.expression = expression;
    }

    @Override
    public Optional&lt;ProcessorDefinition&gt; configure(
            CamelContext context,
            ProcessorDefinition route,
            Map&lt;String, Object&gt; parameters) { // <b class="conum">(1)</b>

        String languageName = language;
        String expressionDefinition = expression;

        if (ObjectHelper.isEmpty(languageName) &amp;&amp; ObjectHelper.isEmpty(expressionDefinition)) {
            route = route.split(Builder.body());
        } else if (ObjectHelper.isNotEmpty(expressionDefinition)) {

            if (ObjectHelper.isEmpty(languageName)) {
                languageName = "simple";
            }

            final Language splitLanguage = context.resolveLanguage(languageName);
            final Expression splitExpression = splitLanguage.createExpression(expressionDefinition);
            final AggregationStrategy aggreationStrategy = new UseOriginalAggregationStrategy(null, false);

            route = route.split(splitExpression).aggregationStrategy(aggreationStrategy);
        }

        return Optional.of(route);
    }
}</code></pre></div></div><div class="colist arabic"><ol><li><p>This is the implementation of the action that the custom step performs.</p></li></ol></div><div class="paragraph"><p>This Java code uses Syndesis annotations, which means that the <code>extension-maven-plugin</code> can automatically generate the action definition. In the extension definition JSON file, the action definition will look like this:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">{
  "id": "split",
  "name": "Split",
  "description": "Split your exchange",
  "descriptor": {
    "kind": "STEP", <b class="conum">(1)</b>
    "entrypoint": "io.syndesis.extension.split.SplitAction", <b class="conum">(2)</b>
    "inputDataShape": {
      "kind": "none"
    },
    "outputDataShape": {
      "kind": "none"
    },
    "propertyDefinitionSteps": [ {
      "description": "extension-properties",
      "name": "extension-properties",
      "properties": {
        "language": {
          "componentProperty": false,
          "deprecated": false,
          "description": "The language used for the expression",
          "displayName": "Language",
          "javaType": "java.lang.String",
          "kind": "parameter",
          "required": false,
          "secret": false,
          "type": "string",
          "raw": false
        },
        "expression": {
          "componentProperty": false,
          "deprecated": false,
          "description": "The expression used to split the exchange",
          "displayName": "Expression",
          "javaType": "java.lang.String",
          "kind": "parameter",
          "required": false,
          "secret": false,
          "type": "string",
          "raw": false
        }
      }
    } ]
  },
  "tags": [],
  "actionType": "step"
}</code></pre></div></div><div class="colist arabic"><ol><li><p>The type of the action is <code>STEP</code>.</p></li><li><p>This is the class that is implementing the <code>Step</code> interface.</p></li></ol></div><div class="paragraph"><div class="title">Additional resource</div><p>For details about user interface properties, see <a href="https://zregvart.github.io/syndesis.io/manual/integrating-applications/#descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</a>.</p></div></div></div></div><div class="sect1"><h2 id="develop-connector-extensions_extensions">Example of developing a connector extension</h2><div class="sectionbody"><div class="paragraph"><p>If Syndesis does not provide a connector for the application or service that you want to connect to in an integration, an experienced developer can code an extension that contributes a new connector to Syndesis. This documentation provides an introduction to developing a connector extension. For details about developing a connector, see <a href="https://syndesis.io/docs/connectors/">Developing Syndesis connectors</a> on the Syndesis community site.</p></div><div class="admonitionblock important"><table><tr><td class="icon"><div class="title">Important</div></td><td class="content"><div class="paragraph"><p>For connector extensions, it is not yet possible to automatically generate the extension definition JSON file from Java code.</p></div></td></tr></table></div><div class="paragraph"><p>A connector is essentially a proxy for a Camel component. A connector configures the underlying component and creates endpoints according to options that are defined in the extension definition and in user-supplied options that the Syndesis web interface collects.</p></div><div class="paragraph"><p>The connector extension definition extends the extension definition that is required for step extensions with the following additional data structures:</p></div><div class="ulist"><ul><li><p><code>componentScheme</code></p><div class="paragraph"><p>Defines the Camel component that the connector uses. You can set <code>componentScheme</code> for the connector or for actions. If you set <code>componentScheme</code> for both the connector and an action, the setting for the action has precedence.</p></div></li><li><p><code>connectorCustomizers</code></p><div class="paragraph"><p>Specifies a list of classes that implement the <a href="https://github.com/syndesisio/syndesis/blob/master/app/integration/component-proxy/src/main/java/io/syndesis/integration/component/proxy/ComponentProxyCustomizer.java">ComponentProxyCustomizer</a> class. Each class customizes the behavior of a connector. For example, a class might manipulate properties before they are applied to the underlying component/endpoint, or a class might add pre/post endpoint logic. For each class, specify the full class name of the implementation, for example, <code>com.mycomponent.MyCustomizer</code>. You can set <code>connectorCustomizers</code> on actions as well as connectors. According to what is set, Syndesis applies customizers to the connector first and then to actions.</p></div></li><li><p><code>connectorFactory</code></p><div class="paragraph"><p>Defines the class that implements the <a href="https://github.com/syndesisio/syndesis/blob/master/app/integration/component-proxy/src/main/java/io/syndesis/integration/component/proxy/ComponentProxyFactory.java">ComponentProxyFactory</a> class, which creates and/or configures the underlying component/endpoint. Specify the full class name of the implementation. You can set <code>connectorFactory</code> for the connector or for actions. Actions have precedence.</p></div></li></ul></div><div class="paragraph"><div class="title">Customizer example</div><p>The following customizer example sets up a <code>DataSource</code> from individual options:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java">public class DataSourceCustomizer implements ComponentProxyCustomizer, CamelContextAware {
    private final static Logger LOGGER = LoggerFactory.getLogger(DataSourceCustomizer.class);

    private CamelContext camelContext;

    @Override
    public void setCamelContext(CamelContext camelContext) { // <b class="conum">(1)</b>
        this.camelContext = camelContext;
    }

    @Override
    public CamelContext getCamelContext() { // <b class="conum">(1)</b>
        return this.camelContext;
    }

    @Override
    public void customize(ComponentProxyComponent component, Map&lt;String, Object&gt; options) {
        if (!options.containsKey("dataSource")) {
            if (options.containsKey("user") &amp;&amp; options.containsKey("password") &amp;&amp; options.containsKey("url")) {
                try {
                    BasicDataSource ds = new BasicDataSource();

                    consumeOption(camelContext, options, "user", String.class, ds::setUsername); // <b class="conum">(2)</b>
                    consumeOption(camelContext, options, "password", String.class, ds::setPassword); // <b class="conum">(2)</b>
                    consumeOption(camelContext, options, "url", String.class, ds::setUrl); // <b class="conum">(2)</b>

                    options.put("dataSource", ds);
                } catch (@SuppressWarnings("PMD.AvoidCatchingGenericException") Exception e) {
                    throw new IllegalArgumentException(e);
                }
            } else {
                LOGGER.debug("Not enough information provided to set-up the DataSource");
            }
        }
    }
}</code></pre></div></div><div class="colist arabic"><ol><li><p>&nbsp;By implementing <code>CamelContextAware</code>, Syndesis injects the Camel context and then invokes the customize method.</p></li><li><p>&nbsp;Processes options and then removes them from the options map.</p></li></ol></div><div class="paragraph"><div class="title">Example of injecting properties</div><p>If the customizer respects Java bean conventions, you can also inject the properties, as shown in this revision of the previous example:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java">public class DataSourceCustomizer implements ComponentProxyCustomizer, CamelContextAware {
    private final static Logger LOGGER = LoggerFactory.getLogger(DataSourceCustomizer.class);

    private CamelContext camelContext;
    private String userName;
    private String password;
    private String url;

    @Override
    public void setCamelContext(CamelContext camelContext) { // <b class="conum">(1)</b>
        this.camelContext = camelContext;
    }

    @Override
    public CamelContext getCamelContext() { // <b class="conum">(1)</b>
        return this.camelContext;
    }

    public void setUserName(String userName) { //<b class="conum">(1)</b>
      this.userName = userName;
    }

    public String getUserName() { // <b class="conum">(2)</b>
      return this.userName;
    }

    public void setPassword(String password) { // <b class="conum">(2)</b>
      this.password = password;
    }

    public String getPassword() { // <b class="conum">(2)</b>
      return this.password;
    }

    public void setUrl(String url) { // <b class="conum">(2)</b>
      this.url = url;
    }

    public String getUrl() { // <b class="conum">(2)</b>
      return this.url;
    }

    @Override
    public void customize(ComponentProxyComponent component, Map&lt;String, Object&gt; options) {
        if (!options.containsKey("dataSource")) {
            if (userName != null &amp;&amp; password != null &amp;&amp; url != null) {
                try {
                    BasicDataSource ds = new BasicDataSource();
                    ds.setUserName(userName);
                    ds.setPassword(password);
                    ds.setUrl(url);

                    options.put("dataSource", ds);
                } catch (@SuppressWarnings("PMD.AvoidCatchingGenericException") Exception e) {
                    throw new IllegalArgumentException(e);
                }
            } else {
                LOGGER.debug("Not enough information provided to set-up the DataSource");
            }
        }
    }
}</code></pre></div></div><div class="colist arabic"><ol><li><p>&nbsp;By implementing <code>CamelContextAware</code>, Syndesis injects the Camel context and then invokes the customize method. This sample code overrides the <code>setCamelContext()</code> and <code>getCamelContext()</code> methods, and sets the user name.</p></li><li><p>&nbsp;The sample code processes the injected options and automatically removes them from the options map.</p></li></ol></div><div class="paragraph"><div class="title">Using a customizer to configure before/after logic</div><p>You can use a customizer to configure before/after logic as shown in this example:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java">public class AWSS3DeleteObjectCustomizer implements ComponentProxyCustomizer {
  	private String filenameKey;

    public void setFilenameKey(String filenameKey) {
      this.filenameKey = filenameKey;
    }

    public String getFilenameKey() {
        return this.filenameKey;
    }

    @Override
    public void customize(ComponentProxyComponent component, Map&lt;String, Object&gt; options) {
      	component.setBeforeProducer(this::beforeProducer);
    }

    public void beforeProducer(final Exchange exchange) throws IOException {
      	exchange.getIn().setHeader(S3Constants.S3_OPERATION, S3Operations.deleteObject);

    	  if (filenameKey != null) {
    		    exchange.getIn().setHeader(S3Constants.KEY, filenameKey);
    	  }
    }
}</code></pre></div></div><div class="paragraph"><div class="title">Customizing behavior of <code>ComponentProxyComponent</code></div><p>The <a href="https://github.com/syndesisio/syndesis/blob/master/app/integration/component-proxy/src/main/java/io/syndesis/integration/component/proxy/ComponentProxyFactory.java">ComponentProxyFactory</a> class creates and/or configures the underlying component/endpoint. To customize the behavior of the <a href="https://github.com/syndesisio/syndesis/blob/master/app/integration/component-proxy/src/main/java/io/syndesis/integration/component/proxy/ComponentProxyComponent.java">ComponentProxyComponent</a> object that <code>ComponentProxyFactory</code> creates, you can override any of the following methods:</p></div><div class="ulist"><ul><li><p><code>createDelegateComponent()</code></p><div class="paragraph"><p>Syndesis invokes this method when the proxy starts and it is used to eventually create a dedicated instance of the component with the scheme defined by the <code>componentScheme</code> option.</p></div><div class="paragraph"><p>The default behavior of this method is to determine if any of the connector/action options applies at the component level. Only in the case that the same option cannot be applied at the endpoint, the method creates a custom component instance and configures it according to the applicable options.</p></div></li><li><p><code>configureDelegateComponent()</code></p><div class="paragraph"><p>Syndesis invokes this method only if a custom component instance has been created to configure additional behavior of the delegated component instance.</p></div></li><li><p><code>createDelegateEndpoint()</code></p><div class="paragraph"><p>Syndesis invokes this method when the proxy creates the endpoint and by default creates the endpoint by using Camel catalog facilities.</p></div></li><li><p><code>configureDelegateEndpoint()</code></p><div class="paragraph"><p>After the delegated endpoint has been created, Syndesis invokes this method to configure additional behavior of the delegated endpoint instance, for example:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java">public class IrcComponentProxyFactory implements ComponentProxyFactory {

    @Override
    public ComponentProxyComponent newInstance(String componentId, String componentScheme) {
        return new ComponentProxyComponent(componentId, componentScheme) {
            @Override
            protected void configureDelegateEndpoint(ComponentDefinition definition, Endpoint endpoint, Map&lt;String, Object&gt; options) throws Exception {
                if (!(endpoint instanceof IrcEndpoint)) {
                    throw new IllegalStateException("Endpoint should be of type IrcEndpoint");
                }

                final IrcEndpoint ircEndpoint = (IrcEndpoint)endpoint;
                final String channels = (String)options.remove("channels");

                if (ObjectHelper.isNotEmpty(channels)) {
                    ircEndpoint.getConfiguration().setChannel(
                        Arrays.asList(channels.split(","))
                    );
                }
            }
        };
    }
}</code></pre></div></div></li></ul></div></div></div><div class="sect1"><h2 id="develop-library-extensions_extensions">How to develop library extensions</h2><div class="sectionbody"><div class="paragraph"><p>A library extension provides a resource that an integration requires at runtime. A library extension does not contribute steps or connectors to Syndesis.</p></div><div class="paragraph"><p>When you save an integration, you can optionally select one or more imported library extensions that you want to include with the integration.</p></div><div class="paragraph"><p>A library extension does not define any actions. Here is a sample definition for a library extension:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-json" data-lang="json">{
  "schemaVersion" : "v1",
  "name" : "Example Library Extension",
  "description" : "Syndesis Extension for adding a runtime library",
  "extensionId" : "io.syndesis.extensions:syndesis-library",
  "version" : "1.0.0",
  "tags" : [ "my-libraries-extension" ],
  "extensionType" : "Libraries"
}</code></pre></div></div><div class="paragraph"><p>See also the sample library extension here: <a href="https://github.com/syndesisio/syndesis-extensions" class="bare">https://github.com/syndesisio/syndesis-extensions</a></p></div><div class="paragraph"><p>Other than the lack of actions, the structure of a library extension is the same as the structure of a step or connector extension.</p></div><div class="paragraph"><p>In a Maven project that creates a library extension, to add dependencies that are not available from a Maven repository, specify a <code>system</code> dependency, for example:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.company&lt;/groupId&gt;
    &lt;artifactId&gt;my-library-extension&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
    &lt;scope&gt;system&lt;/scope&gt;
    &lt;systemPath&gt;${project.basedir}/lib/my-library-extension.jar&lt;/systemPath&gt;
&lt;/dependency&gt;</code></pre></div></div></div></div><div class="sect1"><h2 id="creating-jdbc-driver-library-extensions_extensions">Creating JDBC driver library extensions</h2><div class="sectionbody"><div class="paragraph"><p>To connect to a SQL database other than Apache Derby, MySQL, and PostgreSQL, you can create a library extension that wraps a JDBC driver for the database you want to connect to. After uploading this extension to Syndesis, the Syndesis-provided <strong>Database</strong> connector can access the driver to validate and create connections to the proprietary database. You do not create a new connector for your particular database.</p></div><div class="paragraph"><p>The Syndesis open source community provides a project for creating an extension that wraps a JDBC driver.</p></div><div class="paragraph"><p>Package one driver only in an extension. This makes it easier to manage the extension as part of managing your particular database. However, it is possible to create a library extension that wraps more than one driver.</p></div><div class="paragraph"><div class="title">Prerequisites</div><p>To use the Syndesis project, you must have a GitHub account.</p></div><div class="olist arabic"><div class="title">Procedure</div><ol class="arabic"><li><p>Ensure access to the JDBC driver for the database you want to connect to by doing one of the following:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Confirm that the driver is in a Maven repository.</p></li><li><p>Download the driver.</p></li></ol></div></li><li><p>In a browser tab, go to <a href="https://github.com/syndesisio/syndesis-extensions" class="bare">https://github.com/syndesisio/syndesis-extensions</a></p></li><li><p>Fork the <code>syndesis-extensions</code> repository to your GitHub account.</p></li><li><p>Create a local clone from your fork.</p></li><li><p>In your <code>syndesis-extensions</code> clone:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>If the driver is not in a Maven repository, copy the driver into the <code>syndesis-library-jdbc-driver/lib</code> folder.</p></li><li><p>Edit the <code>syndesis-library-jdbc-driver/pom.xml</code> file:</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>Update the value of the <code>Name</code> element to be a name that you choose for this extension.</p></li><li><p>Update the value of the <code>Description</code> element to provide helpful information about this extension.</p></li><li><p>If you have copied the driver into <code>syndesis-library-jdbc-driver/lib</code> ensure that the <code>systemPath</code> in <code>pom.xml</code> points to that driver file. Optionally change the <code>groupId</code>, <code>artifactId</code> and <code>version</code> to reflect proper values according to the driver.</p></li><li><p>If the driver is in a Maven repository, ensure that a reference to that Maven dependency is in the <code>pom.xml</code> file.</p></li><li><p>Examine the rest of the content of the <code>pom.xml</code> file and change any relevant metadata as needed.</p></li></ol></div></li><li><p>Execute <code>./mvnw -pl :syndesis-library-jdbc-driver clean package</code> to build the extension.</p></li></ol></div></li></ol></div><div class="paragraph"><p>The generated <code>.jar</code> file is in the <code>syndesis-library-jdbc-driver/target</code> folder. Import this <code>.jar</code> file as an extension in Syndesis.</p></div><div class="paragraph"><p>After you import a library extension, when you save an integration in Syndesis you can optionally select the imported library extension and associate it with the integration.</p></div></div></div></div><div id="footer"><div id="footer-text">Last updated 2020-11-26 16:14:52 UTC</div></div></div><footer class="page-footer text-center"><div class="row"><section class="col-md-6"><i class="fab fa-3x fa-github" aria-hidden="true"></i><h4>Get the source code</h4><p>Stay tuned to contribute or build your own solution.</p><p class="link-button"><a href="https://github.com/syndesisio" rel="nofollow" target="_blank" class="btn btn-primary">Syndesis on GitHub</a></p></section><section class="col-md-6"><i class="fas fa-3x fa-comments"></i><h4>Connect with us</h4><p>Chat with the Syndesis community.</p><p class="link-button"><a href="https://gitter.im/syndesisio/community" rel="nofollow" target="_blank" class="btn btn-primary">syndesisio on Gitter</a></p></section></div><div class="rh-logo"><section><a href="https://www.redhat.com" rel="nofollow" title="Red Hat, Inc." target="_blank"><img width="128" height="42" src="/images/redhatnew.svg" alt="Red Hat, Inc."></a></section></div></footer></div></body></html>